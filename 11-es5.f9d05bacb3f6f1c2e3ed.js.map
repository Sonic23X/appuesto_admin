{"version":3,"sources":["webpack:///src/app/shared/components/section-header/section-header.component.ts","webpack:///node_modules/@angular/material/toolbar/index.d.ts.MatToolbar.html","webpack:///node_modules/@angular/cdk/fesm2015/accordion.js","webpack:///node_modules/@angular/material/expansion/index.d.ts.MatExpansionPanel.html","webpack:///node_modules/@angular/material/expansion/index.d.ts.MatExpansionPanelHeader.html","webpack:///src/app/shared/services/menu.service.ts","webpack:///node_modules/@angular/material/fesm2015/toolbar.js","webpack:///node_modules/rxjs/_esm2015/internal/observable/interval.js","webpack:///node_modules/@angular/cdk/fesm2015/drag-drop.js","webpack:///src/app/shared/components/section-header/section-header.module.ts","webpack:///node_modules/@angular/material/fesm2015/expansion.js","webpack:///node_modules/@angular/material/fesm2015/menu.js","webpack:///src/app/shared/components/section-header/section-header.component.html"],"names":["MONTH_YEAR_FORMAT","parse","dateInput","display","monthYearLabel","dateA11yLabel","monthYearA11yLabel","SectionHeaderComponent","router","fb","isMonthsSelectorVisible","hasTheMonthYearCalendarToBeVisible","actionClicked","monthChanged","monthYearChanged","openMenu","form","this","group","month","monthYear","months","name","value","monthYearMaxDate","setactualMonthAsSelected","actualMonth","get","setValue","emit","signOut","then","localStorage","clear","navigate","normalizedYear","yearAux","normalizedMonth","datepicker","ctrlValue","year","close","startOf","valueOf","nextId","CdkAccordion","_stateChanges","_openCloseAllActions","id","_multi","_openCloseAll","changes","next","complete","expanded","multi","c","nextId$1","CdkAccordionItem","accordion","_changeDetectorRef","_expansionDispatcher","_openCloseAllSubscription","EMPTY","closed","opened","destroyed","expandedChange","_expanded","_disabled","_removeUniqueSelectionListener","listen","accordionId","_subscribeToOpenCloseAllActions","unsubscribe","disabled","subscribe","notify","markForCheck","CdkAccordionModule","MenuService","http","restaurantSelected","modifiers","GET_ICONS","DOWNLOAD_TEMPLATE","restaurantId","url","DUPLICATE_MATRIZ_MENU","replace","toString","post","MENUS","menuId","DUPLICATE_MENU","DELETE_MENU","delete","data","CREATE_MENU","EDIT_MENU","put","ORDER_MENU","GET_CATEGORY","CREATE_CATEGORY","categoryId","EDIT_CATEGORY","DUPLICATE_CATEGORY","DELETE_CATEGORY","ORDER_CATEGORY","GET_DISHES","CREATE_DISHE","dishId","EDIT_DISHE","DUPLICATE_DISHE","DELETE_DISHE","ORDER_DISHES","UPDATE_DISH","GET_MODIFIERS","CREATE_MODIFIERS","modifierId","EDIT_MODIFIERS","asObservable","restaurant","DELETE_MODIFIERS","zip","UPLOAD_TEMPLATE","MatToolbar","elementRef","_platform","document","super","_document","isBrowser","_checkToolbarMixedModes","_toolbarRows","length","Array","from","_elementRef","nativeElement","childNodes","filter","node","classList","contains","nodeType","COMMENT_NODE","some","textContent","trim","Error","MatToolbarModule","dispatch","state","subscriber","counter","period","schedule","extendStyles","dest","source","key","hasOwnProperty","toggleNativeDragInteractions","element","enable","userSelect","style","touchAction","webkitUserDrag","webkitTapHighlightColor","msUserSelect","webkitUserSelect","MozUserSelect","parseCssTimeUnitsToMs","multiplier","toLowerCase","indexOf","parseFloat","parseCssPropertyValue","computedStyle","getPropertyValue","split","map","part","passiveEventListenerOptions","passive","activeEventListenerOptions","_config","_ngZone","_viewportRuler","_dragDropRegistry","_passiveTransform","x","y","_activeTransform","_moveEvents","Subject","_pointerMoveSubscription","Subscription","_pointerUpSubscription","_scrollSubscription","_resizeSubscription","_boundaryElement","_nativeInteractionsEnabled","_handles","_disabledHandles","Set","_direction","dragStartDelay","beforeStarted","started","released","ended","entered","exited","dropped","moved","_pointerDown","event","targetHandle","find","handle","target","has","_initializeDragSequence","_rootElement","_pointerMove","preventDefault","_hasStartedDragging","_previewRect","width","height","_preview","getBoundingClientRect","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","_updatePointerDirectionDelta","_dropContainer","_updateActiveDropContainer","activeTransform","_pickupPositionOnPage","_applyRootElementTransform","SVGElement","setAttribute","observers","run","pointerPosition","distance","_getDragDistance","delta","_pointerDirectionDelta","_getPointerPositionOnPage","Math","abs","dragStartThreshold","Date","now","_dragStartTime","_getDragStartDelay","_endDragSequence","isDragging","_startDragSequence","_pointerUp","withRootElement","registerDragItem","_placeholder","handles","forEach","_toggleNativeDragInteractions","template","_previewTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","addEventListener","_initialTransform","boundaryElement","change","_containInsideBoundaryOnResize","removeNode","_anchor","_destroyPreview","_destroyPlaceholder","removeDragItem","_removeSubscriptions","transform","add","direction","container","position","_pointerPositionAtLastDirectionChange","_previewRef","destroy","_placeholderRef","stopDragging","_rootElementTapHighlight","_stopScrolling","_animatePreviewToPlaceholder","_cleanupDragArtifacts","_cleanupCachedDimensions","isTouchEvent","_lastTouchEventTime","parent","preview","_createPreviewElement","placeholder","_createPlaceholderElement","anchor","createComment","insertBefore","body","appendChild","replaceChild","documentRef","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","start","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","draggable","type","_initialContainer","pointerMove","pointerUp","scroll","pipe","startWith","_scrollPosition","getViewportScrollPosition","_boundaryRect","_pickupPositionInElement","_getPointerPositionInElement","startDragging","currentIndex","getItemIndex","isPointerOverContainer","_isOverContainer","item","previousIndex","previousContainer","drop","newContainer","_getSiblingContainerFromPosition","exit","enter","_startScrollingIfNecessary","_sortItem","getTransform","previewConfig","previewClass","previewTemplate","viewRef","viewContainer","createEmbeddedView","context","getRootNode","elementRect","deepCloneNode","left","top","pointerEvents","margin","zIndex","isArray","className","Promise","resolve","placeholderRect","duration","getComputedStyle","transitionedProperties","property","prop","propertyIndex","rawDurations","rawDelays","runOutsideAngular","handler","propertyName","removeEventListener","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","handleElement","referenceRect","point","targetTouches","pageX","pageY","touches","changedTouches","constrainedPoint","constrainPosition","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewRect","minY","maxY","bottom","clamp","right","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","currentPosition","pickupPosition","leftOverflow","rightOverflow","topOverflow","bottomOverflow","setFreeDragPosition","touch","mouse","newValue","round","clone","cloneNode","descendantsWithId","querySelectorAll","descendantCanvases","removeAttribute","i","cloneCanvases","correspondingCloneContext","getContext","drawImage","min","max","parentNode","removeChild","rootNode","rootNodes","ELEMENT_NODE","wrapper","createElement","moveItemInArray","array","fromIndex","toIndex","clamp$1","to","sortingDisabled","autoScrollDisabled","enterPredicate","sorted","_isDragging","_itemPositions","_viewportScrollPosition","_previousSwap","drag","_siblings","_orientation","_activeSiblings","_viewportScrollSubscription","_verticalScrollDirection","_horizontalScrollDirection","_stopScrollTimers","_cachedShadowRoot","_handleScroll","_updateAfterScroll","scrollTop","scrollLeft","_startScrollInterval","scheduler","a","isNumeric","Observable","animationFrame","takeUntil","_scrollNode","incrementVerticalScroll","incrementHorizontalScroll","registerDropContainer","_removeListeners","removeDropContainer","_cacheItems","sibling","_startReceiving","_listenToScrollEvents","pointerX","pointerY","newIndex","_draggables","_getItemIndexFromPointerPosition","activeDraggables","_activeDraggables","getPlaceholderElement","newPositionReference","splice","getRootElement","push","_cacheItemPositions","_reset","items","_withDropContainer","connectedTo","slice","orientation","findIndex","reverse","currentItem","size","pointerDelta","_isPointerNearDropContainer","siblings","isHorizontal","siblingAtNewPosition","clientRect","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","index","isDraggedItem","offset","elementToOffset","adjustClientRect","scrollNode","verticalScrollDirection","horizontalScrollDirection","computedVertical","getVerticalScrollDirection","computedHorizontal","getHorizontalScrollDirection","scrollHeight","clientHeight","scrollWidth","clientWidth","_clientRect","getViewportSize","window","getMutableClientRect","elementToMeasure","sort","b","_stopReceiving","immediateSibling","end","xThreshold","yThreshold","_","floor","_cacheOwnPosition","scrollPosition","newTop","newLeft","extraClientRect","topDifference","leftDifference","_sortFromLastPointerPosition","isInsideClientRect","_canReceive","elementFromPoint","_getShadowRoot","activeSiblings","isReceiving","ShadowRoot","predicate","amount","scrollBy","DragDropRegistry","DragDrop","activeCapturingEventOptions","capture","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","Map","_preventDefaultWhileDragging","startsWith","upEvent","set","e","options","config","_clearGlobalListeners","instance","Éµprov","factory","token","providedIn","DEFAULT_CONFIG","CDK_DRAG_PARENT","CDK_DROP_LIST","CDK_DRAG_CONFIG","dropContainer","_viewContainerRef","_dir","dragDrop","_destroyed","observer","subscription","_dragRef","movedEvent","createDrag","_dropListRef","_syncInputs","_handleEvents","reset","getFreeDragPosition","onStable","take","_updateRootElement","tap","childHandleElements","_parentDrag","withHandles","switchMap","merge","handleInstance","dragRef","disableHandle","enableHandle","freeDragPosition","rootSelectorChange","positionChange","firstChange","dispose","rootElementSelector","getClosestMatchingAncestor","nodeName","boundary","ref","dir","templateRef","withBoundaryElement","_getBoundaryElement","withPlaceholderTemplate","withPreviewTemplate","withDirection","selector","currentElement","matches","msMatchesSelector","parentElement","CdkDropList","_items","_uniqueIdCounter","_group","createDropList","_setupInputSyncSubscription","_dropLists","withItems","reduce","filteredItems","list","withOrientation","DragDropModule","SectionHeaderModule","MAT_ACCORDION","uniqueId","MAT_EXPANSION_PANEL_DEFAULT_OPTIONS","MatExpansionPanel","_uniqueSelectionDispatcher","_animationMode","defaultOptions","_hideToggle","afterExpand","afterCollapse","_inputChanges","_headerId","_bodyAnimationDone","fromState","toState","hideToggle","displayMode","_lazyContent","_portal","_template","_body","focusedElement","activeElement","bodyElement","_togglePosition","togglePosition","MatExpansionPanelHeader","panel","_element","_focusMonitor","_parentChangeSubscription","_animationsDisabled","accordionHideToggleChange","_containsFocus","focusVia","monitor","origin","_handleHeaderFocus","expandedHeight","collapsedHeight","toggle","_getExpandedState","keyCode","_toggle","_handleHeaderKeydown","stopMonitoring","MatExpansionPanelTitle","MatAccordion","arguments","_ownHeaders","_headers","headers","header","notifyOnChanges","_keyManager","withWrap","manager","setFirstItemActive","setLastItemActive","onKeydown","updateActiveItem","show","MatExpansionModule","MAT_MENU_PANEL","MatMenuItem","_parentMenu","role","_hovered","_focused","_highlighted","_triggersSubmenu","addItem","_getHostElement","focus","removeItem","textNodeType","TEXT_NODE","output","MAT_MENU_DEFAULT_OPTIONS","overlapTrigger","xPosition","yPosition","backdropClass","menuPanelUid","MatMenu","_defaultOptions","_xPosition","_yPosition","_directDescendantItems","_tabSubscription","_classList","_panelAnimationState","_animationDone","_overlapTrigger","_hasBackdrop","hasBackdrop","panelId","setPositionClasses","_updateDirectDescendants","withTypeAhead","tabOut","focusedItem","_item","parentMenu","setFocusOrigin","lazyContent","_focusFirstItem","activeItem","first","getAttribute","setActiveItem","depth","newElevation","customElevation","Object","keys","_previousElevation","posX","posY","classes","_isAnimating","activeItemIndex","_allItems","previousPanelClass","_previousPanelClass","panelClass","_MatMenu","ngZone","MAT_MENU_SCROLL_STRATEGY","MAT_MENU_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MatMenuTrigger","_overlay","scrollStrategy","_menuItemInstance","_overlayRef","_menuOpen","_closingActionsSubscription","_hoverSubscription","_menuCloseSubscription","_handleTouchStart","_openedBy","restoreFocus","menuOpened","onMenuOpen","menuClosed","onMenuClose","triggersSubmenu","_scrollStrategy","_checkMenu","_handleHover","closeMenu","overlayRef","_createOverlay","overlayConfig","getConfig","_setPosition","menu","attach","_getPortal","menuData","_menuClosingActions","_initMenu","_startAnimation","menuOpen","detach","_resetAnimation","_attached","_setIsMenuOpen","_restoreFocus","_setMenuElevation","focusFirstItem","setElevation","isOpen","_getOverlayConfig","_subscribeToPositions","create","keydownEvents","positionStrategy","flexibleConnectedTo","withLockedPosition","withTransformOriginOn","positionChanges","connectionPair","overlayX","overlayY","originX","originFallbackX","overlayFallbackY","originY","originFallbackY","overlayFallbackX","offsetY","withPositions","backdrop","backdropClick","detachments","parentClose","hover","active","toggleMenu","v","_menu","reason","_destroyMenu","_MatMenuDirectivesModule","MatMenuModule"],"mappings":"0oFAAA,4GAiBaA,EAAoB,CAC/BC,MAAO,CACLC,UAAW,WAEbC,QAAS,CACPD,UAAW,YACXE,eAAgB,WAChBC,cAAe,KACfC,mBAAoB,cAkBXC,E,WA0CX,WAAoBC,EAAwBC,2BAAxB,KAAAD,SAAwB,KAAAC,KAvCnC,KAAAC,2BAKA,KAAAC,sCAEC,KAAAC,cAAoC,IAAI,IACxC,KAAAC,aAAqC,IAAI,IACzC,KAAAC,iBAAyC,IAAI,IAChD,KAAAC,YAEA,KAAAC,KAAOC,KAAKR,GAAGS,MAAM,CAC1BC,MAAO,CAAC,IACRC,UAAW,CAAC,OAKP,KAAAC,OAAiD,CACtD,CAAEC,KAAM,QAASC,MAAO,GACxB,CAAED,KAAM,UAAWC,MAAO,GAC1B,CAAED,KAAM,QAASC,MAAO,GACxB,CAAED,KAAM,QAASC,MAAO,GACxB,CAAED,KAAM,OAAQC,MAAO,GACvB,CAAED,KAAM,QAASC,MAAO,GACxB,CAAED,KAAM,QAASC,MAAO,GACxB,CAAED,KAAM,SAAUC,MAAO,GACzB,CAAED,KAAM,aAAcC,MAAO,GAC7B,CAAED,KAAM,UAAWC,MAAO,GAC1B,CAAED,KAAM,YAAaC,MAAO,IAC5B,CAAED,KAAM,YAAaC,MAAO,KAMvB,KAAAC,iBAAmB,I,wDAKxBP,KAAKQ,6B,iDAIL,IAAMC,EAAc,IAASC,IAAI,SACjCV,KAAKD,KAAKW,IAAI,SAASC,SAASF,K,0CAIhCT,KAAKL,cAAciB,S,+BAGN,WACb,SAEGC,UACAC,MAAK,WACJC,aAAaC,QACbhB,EAAKT,OAAO0B,SAAS,CAAC,gB,wCAQHC,GACvBlB,KAAKmB,QAAUD,I,yCASfE,EACAC,GAEA,IAAMC,EAAYtB,KAAKD,KAAKW,IAAI,aAAaJ,MAC7CgB,EAAUpB,MAAMkB,EAAgBlB,SAChCoB,EAAUC,KAAKvB,KAAKmB,QAAQI,QAC5BvB,KAAKD,KAAKW,IAAI,aAAaC,SAASW,GACpCD,EAAWG,QACXxB,KAAKH,iBAAiBe,KACpBZ,KAAKD,KAAKW,IAAI,aAAaJ,MAAMmB,QAAQ,SAASC,e,0xBCrIxD,aACA,cAAqC,a,oCCDrC,0JAcIC,EAAS,EAIPC,E,WACF,aAAa,wBAIT5B,KAAK6B,cAAgB,IAAI,IAIzB7B,KAAK8B,qBAAuB,IAAI,IAIhC9B,KAAK+B,GAAL/B,wBAA2B2B,KAC3B3B,KAAKgC,U,uDAiBLhC,KAAKiC,eAAcA,K,iCAOnBjC,KAAKiC,eAAcA,K,kCAMXC,GACRlC,KAAK6B,cAAcM,KAAKD,K,oCAMxBlC,KAAK6B,cAAcO,a,oCAOTC,GACNrC,KAAKsC,OACLtC,KAAK8B,qBAAqBK,KAAKE,K,4BAxCzB,OAAOrC,KAAKgC,Q,aAKhBM,GAAStC,KAAKgC,OAAS,SAAAO,EAAA,CAAsBD,O,KAkFvDE,EAAW,EAMTC,E,WAMF,WAAYC,EAAWC,EAAoBC,GAAqBA,mCAC5D5C,KAAK0C,UAAYA,EACjB1C,KAAK2C,mBAAqBA,EAC1B3C,KAAK4C,qBAAuBA,EAI5B5C,KAAK6C,0BAA4B,IAAaC,MAI9C9C,KAAK+C,OAAS,IAAI,IAIlB/C,KAAKgD,OAAS,IAAI,IAIlBhD,KAAKiD,UAAY,IAAI,IAMrBjD,KAAKkD,eAAiB,IAAI,IAI1BlD,KAAK+B,GAAL/B,8BAAiCwC,KACjCxC,KAAKmD,aACLnD,KAAKoD,aAILpD,KAAKqD,+BAAiC,aAItCrD,KAAKqD,+BACDT,EAAqBU,QAAO,SAK3BvB,EAAIwB,GACGvD,EAAK0C,YAAc1C,EAAK0C,UAAUJ,OAClCtC,EAAK0C,UAAUX,KAAOwB,GAAevD,EAAK+B,KAAOA,IACjD/B,EAAKqC,gBAIbrC,KAAK0C,YACL1C,KAAK6C,0BAA4B7C,KAAKwD,mC,2DAmD1CxD,KAAKgD,OAAOZ,WACZpC,KAAK+C,OAAOX,WACZpC,KAAKiD,UAAUrC,OACfZ,KAAKiD,UAAUb,WACfpC,KAAKqD,iCACLrD,KAAK6C,0BAA0BY,gB,+BAO1BzD,KAAK0D,WACN1D,KAAKqC,UAAYrC,KAAKqC,Y,8BAQrBrC,KAAK0D,WACN1D,KAAKqC,e,6BAQJrC,KAAK0D,WACN1D,KAAKqC,e,wDAOoB,WAC7B,OAAOrC,KAAK0C,UAAUZ,qBAAqB6B,WAI3CtB,YAESrC,EAAK0D,WACN1D,EAAKqC,SAAWA,Q,+BA1FX,OAAOrC,KAAKmD,W,aAKhBd,GACTA,EAAW,SAAAE,EAAA,CAAsBF,GAE7BrC,KAAKmD,YAAcd,IACnBrC,KAAKmD,UAAYd,EACjBrC,KAAKkD,eAAetC,KAAKyB,GACrBA,GACArC,KAAKgD,OAAOpC,OAOZZ,KAAK4C,qBAAqBgB,OAAO5D,KAAK+B,GADlB/B,KAAK0C,UAAY1C,KAAK0C,UAAUX,GAAK/B,KAAK+B,KAI9D/B,KAAK+C,OAAOnC,OAIhBZ,KAAK2C,mBAAmBkB,kB,+BAOf,OAAO7D,KAAKoD,W,aAKhBM,GAAY1D,KAAKoD,UAAY,SAAAb,EAAA,CAAsBmB,O,KA2J9DI,E,s4ECtYN,cACA,uOAGK,4B,OAHL,EAMW,U,+BANX,iBAOE,mGACE,cACA,4GAEF,eAAoC,cAFlC,QAEkC,YAFM,4CAT5C,QAEK,EAAsC,oBAEtC,EAAkC,UAClC,EAAS,O,8xECDd,2HACsC,oBADtC,QACsC,YADQ,wB,8BAL9C,uFACE,aACA,aACA,cAEF,qGACsC,cADtC,QACsC,YAD8B,yB,kCCHpE,sFAOO,iBAAMC,EAAN,WAIL,WAAoBC,2BAAA,KAAAA,OAHb,KAAAC,mBAAqB,IAAI,IACzB,KAAAC,UAAyB,GAF3B,wDAOH,OAAOlE,KAAKgE,KAAKtD,IAAS,IAAYyD,aAPnC,oCAUH,OAAOnE,KAAKgE,KAAKtD,IAAS,IAAY0D,qBAVnC,0CAYsBC,GACzB,IAAMC,EAAM,IAAYC,sBAAsBC,QAC5C,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAK,QAjB7B,8BAmBUD,GACb,IAAMC,EAAM,IAAYK,MAAMH,QAC5B,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKtD,IAAS4D,KAxBvB,oCA0BgBM,GACnB,IAAMN,EAAM,IAAYO,eAAeL,QACrC,WACAI,EAAOH,YAET,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAK,QA/B7B,iCAiCaD,GAChB,IAAMC,EAAM,IAAYQ,YAAYN,QAClC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKe,OAAYT,KAtC1B,iCAwCaU,EAAWX,GAC3B,IAAMC,EAAM,IAAYW,YAAYT,QAClC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAKU,KA7C7B,+BA+CWA,EAAWJ,GACzB,IAAMN,EAAM,IAAYY,UAAUV,QAAQ,WAAYI,EAAOH,YAC7D,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KAjD5B,gCAmDYX,EAAsBW,GACrC,IAAMV,EAAM,IAAYc,WAAWZ,QACjC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KAxD5B,kCA2DcJ,GACjB,IAAMN,EAAM,IAAYe,aAAab,QAAQ,WAAYI,EAAOH,YAChE,OAAOzE,KAAKgE,KAAKtD,IAAS4D,KA7DvB,qCA+DiBU,EAAWJ,GAC/B,IAAMN,EAAM,IAAYgB,gBAAgBd,QACtC,WACAI,EAAOH,YAET,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAKU,KApE7B,mCAsEeA,EAAWO,GAC7B,IAAMjB,EAAM,IAAYkB,cAAchB,QACpC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KA3E5B,wCA6EoBO,GACvB,IAAMjB,EAAM,IAAYmB,mBAAmBjB,QACzC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAK,QAlF7B,qCAoFiBiB,GACpB,IAAMjB,EAAM,IAAYoB,gBAAgBlB,QACtC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKe,OAAYT,KAzF1B,oCA2FgBM,EAAgBI,GACnC,IAAMV,EAAM,IAAYqB,eAAenB,QACrC,WACAI,EAAOH,YAET,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KAhG5B,gCAmGYO,GACf,IAAMjB,EAAM,IAAYsB,WAAWpB,QACjC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKtD,IAAS4D,KAxGvB,mCA0GeU,EAAWO,GAC7B,IAAMjB,EAAM,IAAYuB,aAAarB,QACnC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAKU,KA/G7B,iCAiHaA,EAAWc,GAC3B,IAAMxB,EAAM,IAAYyB,WAAWvB,QAAQ,WAAYsB,EAAOrB,YAC9D,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KAnH5B,sCAqHkBc,GACrB,IAAMxB,EAAM,IAAY0B,gBAAgBxB,QACtC,WACAsB,EAAOrB,YAET,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAK,QA1H7B,mCA4HewB,GAClB,IAAMxB,EAAM,IAAY2B,aAAazB,QAAQ,WAAYsB,EAAOrB,YAChE,OAAOzE,KAAKgE,KAAKe,OAAYT,KA9H1B,kCAgIciB,EAAoBP,GACrC,IAAMV,EAAM,IAAY4B,aAAa1B,QACnC,eACAe,EAAWd,YAEb,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KArI5B,uCAuImBc,GACtB,IAAMxB,EAAM,IAAY6B,YAAY3B,QAAQ,WAAYsB,EAAOrB,YAC/D,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAK,MAzI5B,kCA2IcD,GACjB,IAAMC,EAAM,IAAY8B,cAAc5B,QACpC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKtD,IAAS4D,KAhJvB,qCAkJiBU,EAAWX,GAC/B,IAAMC,EAAM,IAAY+B,iBAAiB7B,QACvC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKU,KAAUJ,EAAKU,KAvJ7B,mCAyJeA,EAAWsB,GAC7B,IAAMhC,EAAM,IAAYiC,eAAe/B,QACrC,eACA8B,EAAW7B,YAEb,OAAOzE,KAAKgE,KAAKmB,IAASb,EAAKU,KA9J5B,qCAgKiBsB,GACpB,IAAMhC,EAAM,IAAYiC,eAAe/B,QACrC,eACA8B,EAAW7B,YAEb,OAAOzE,KAAKgE,KAAKe,OAAYT,KArK1B,sCAyKH,OAAOtE,KAAKiE,mBAAmBuC,iBAzK5B,uCA2KmBC,GACtBzG,KAAKiE,mBAAmB9B,KAAKsE,KA5K1B,0CA+KsBH,GACzB,IAAMhC,EAAM,IAAYoC,iBAAiBlC,QACvC,eACA8B,EAAW7B,YAEb,OAAOzE,KAAKgE,KAAKe,OAAOT,KApLrB,gCAuLYqC,EAAetC,GAC9B,IAAMC,EAAM,IAAYsC,gBAAgBpC,QACtC,iBACAH,EAAaI,YAEf,OAAOzE,KAAKgE,KAAKU,KAAKJ,EAAKqC,OA5LxB,K,oGAAA,I,kCCTP,gGAqCME,E,YAMF,WAAYC,EAAYC,EAAWC,GAASA,sCACxCC,+DAAMH,KACDC,UAAYA,EAEjB/G,EAAKkH,UAAYF,EAJuBA,E,8EAS3B,WACR,eAAgBhH,KAAK+G,UAAUI,YAGpCnH,KAAKoH,0BACLpH,KAAKqH,aAAanF,QAAQyB,WAAU,kBAG9B3D,EAAKoH,gC,gDAOU,WAChBpH,KAAKqH,aAAaC,QAMCC,MAAMC,KAAKxH,KAAKyH,YAAYC,cAAcC,YAC7DC,QAILC,YAAIA,QAAMA,EAAKC,WAAaD,EAAKC,UAAUC,SAAS,uBAC/CH,QAILC,YAAIA,OAAIA,EAAKG,YAAchI,EAAKkH,UAAYlH,EAAKkH,UAAUe,aAAe,MACrEC,MAILL,YAAIA,SAAOA,EAAKM,cAAeN,EAAKM,YAAYC,YAqDxD,WACI,MAAMC,MAAM,kMADhB,O,GAnH6B,aATzB,WAAYZ,GAAYA,wBACpBzH,KAAKyH,YAAcA,MAsIrBa,E,qMC1IN,SAASC,EAASC,GAAMA,IACZC,EAAgCD,EAAlC,WAAcE,EAAoBF,EAAtB,QAAWG,EAAWH,EAAb,OAC3BC,EAAWtG,KAAKuG,GAChB1I,KAAK4I,SAAS,CAAEH,aAAYC,QAASA,EAAU,EAAGC,UAAUA,G,oGCsBhE,SAASE,EAAaC,EAAMC,GACxB,IAAK,IAAIC,KAAOD,EACRA,EAAOE,eAAeD,KACtBF,EAAKE,GAA0BD,EAAOC,IAG9C,OAAOF,EASX,SAASI,EAA6BC,EAASC,GAE3C,IAAMC,EAAaD,EAAS,GAAK,OACjCP,EAAaM,EAAQG,MAAO,CACxBC,YAAaH,EAAS,GAAK,OAC3BI,eAAgBJ,EAAS,GAAK,OAC9BK,wBAAyBL,EAAS,GAAK,cACvCC,WAAYA,EACZK,aAAcL,EACdM,iBAAkBN,EAClBO,cAAeP,IAqBvB,SAASQ,EAAsBvJ,GAG3B,IAAMwJ,EAAaxJ,EAAMyJ,cAAcC,QAAQ,OAAS,EAAI,EAAI,IAChE,OAAOC,WAAW3J,GAASwJ,EAuC/B,SAASI,EAAsBC,EAAe9J,GAG1C,OADc8J,EAAcC,iBAAiB/J,GAChCgK,MAAM,KAAKC,KAIxBC,YAAIA,OAAIA,EAAKnC,UAxIjB,yVAuKA,IAAMoC,EAA8B,YAAgC,CAAEC,SAAQA,IAKxEC,EAA6B,YAAgC,CAAED,SAAQA,IAkCvE,E,WASF,WAAYtB,EAASwB,EAASzD,EAAW0D,EAASC,EAAgBC,GAAkBA,mCAChF9K,KAAK2K,QAAUA,EACf3K,KAAKkH,UAAYA,EACjBlH,KAAK4K,QAAUA,EACf5K,KAAK6K,eAAiBA,EACtB7K,KAAK8K,kBAAoBA,EAOzB9K,KAAK+K,kBAAoB,CAAEC,EAAG,EAAGC,EAAG,GAIpCjL,KAAKkL,iBAAmB,CAAEF,EAAG,EAAGC,EAAG,GAInCjL,KAAKmL,YAAc,IAAIC,EAAA,EAIvBpL,KAAKqL,yBAA2BC,EAAA,EAAaxI,MAI7C9C,KAAKuL,uBAAyBD,EAAA,EAAaxI,MAI3C9C,KAAKwL,oBAAsBF,EAAA,EAAaxI,MAIxC9C,KAAKyL,oBAAsBH,EAAA,EAAaxI,MAIxC9C,KAAK0L,iBAAmB,KAIxB1L,KAAK2L,8BAIL3L,KAAK4L,SAAW,GAIhB5L,KAAK6L,iBAAmB,IAAIC,IAI5B9L,KAAK+L,WAAa,MAKlB/L,KAAKgM,eAAiB,EACtBhM,KAAKoD,aAILpD,KAAKiM,cAAgB,IAAIb,EAAA,EAIzBpL,KAAKkM,QAAU,IAAId,EAAA,EAInBpL,KAAKmM,SAAW,IAAIf,EAAA,EAIpBpL,KAAKoM,MAAQ,IAAIhB,EAAA,EAIjBpL,KAAKqM,QAAU,IAAIjB,EAAA,EAInBpL,KAAKsM,OAAS,IAAIlB,EAAA,EAIlBpL,KAAKuM,QAAU,IAAInB,EAAA,EAKnBpL,KAAKwM,MAAQxM,KAAKmL,YAAY3E,eAI9BxG,KAAKyM,aAIJC,YAGG,GAFA1M,EAAKiM,cAAc9J,OAEfnC,EAAK4L,SAAStE,OAAQ,CAEtB,IAAMqF,EAAe3M,EAAK4L,SAASgB,MAInCC,YAEI,IAAMC,EAASJ,EAAMI,OACrB,QAASA,IAAWA,IAAWD,GAAUA,EAAO9E,SAAS,QAEzD4E,GAAiB3M,EAAK6L,iBAAiBkB,IAAIJ,IAAkB3M,EAAK0D,UAClE1D,EAAKgN,wBAAwBL,EAAcD,QAGzC1M,EAAK0D,UACX1D,EAAKgN,wBAAwBhN,EAAKiN,aAAcP,IAMxD1M,KAAKkN,aAIJR,YAIG,GADAA,EAAMS,iBACDnN,EAAKoN,oBAAV,CAkCIpN,EAAK0L,mBAGA1L,EAAKqN,eAAkBrN,EAAKqN,aAAaC,OAAUtN,EAAKqN,aAAaE,UACtEvN,EAAKqN,cAAgBrN,EAAKwN,UAAYxN,EAAKiN,cAAcQ,0BAIjE,IAAMC,EAA6B1N,EAAK2N,+BAA+BjB,GAGvE,GAFA1M,EAAK4N,aACL5N,EAAK6N,6BAA6BH,GAC9B1N,EAAK8N,eACL9N,EAAK+N,2BAA2BL,OAE/B,CAED,IAAMM,EAAkBhO,EAAKkL,iBAC7B8C,EAAgBhD,EACZ0C,EAA2B1C,EAAIhL,EAAKiO,sBAAsBjD,EAAIhL,EAAK+K,kBAAkBC,EACzFgD,EAAgB/C,EACZyC,EAA2BzC,EAAIjL,EAAKiO,sBAAsBhD,EAAIjL,EAAK+K,kBAAkBE,EACzFjL,EAAKkO,2BAA2BF,EAAgBhD,EAAGgD,EAAgB/C,GAEzC,oBAAfkD,YAA8BnO,EAAKiN,wBAAwBkB,YAGlEnO,EAAKiN,aAAamB,aAAa,YAA/BpO,oBADsCgO,EAAgBhD,EACtDhL,YAD2DgO,EAAgB/C,EAC3EjL,MAMJA,EAAKmL,YAAYkD,UAAU/G,QAC3BtH,EAAK4K,QAAQ0D,KAAI,WAIbtO,EAAKmL,YAAYhJ,KAAK,CAClB4G,OAAQ/I,EACRuO,gBAAiBb,EACjBhB,QACA8B,SAAUxO,EAAKyO,iBAAiBf,GAChCgB,MAAO1O,EAAK2O,gCA5ExB,CAEI,IAAMJ,EAAkBvO,EAAK4O,0BAA0BlC,GAWvD,GATkBmC,KAAKC,IAAIP,EAAgBvD,EAAIhL,EAAKiO,sBAAsBjD,GAExD6D,KAAKC,IAAIP,EAAgBtD,EAAIjL,EAAKiO,sBAAsBhD,IAEzBjL,EAAK2K,QAAQoE,mBAKzC,CAGjB,KADuBC,KAAKC,OAASjP,EAAKkP,eAAiBlP,EAAKmP,mBAAmBzC,IAG/E,YADA1M,EAAKoP,iBAAiB1C,GAMrB1M,EAAK8N,gBAAmB9N,EAAK8N,eAAeuB,eAC7CrP,EAAKoN,uBACLpN,EAAK4K,QAAQ0D,KAAI,kBAGXtO,EAAKsP,mBAAmB5C,UAwD9C1M,KAAKuP,WAIJ7C,YACG1M,EAAKoP,iBAAiB1C,IAE1B1M,KAAKwP,gBAAgBrG,GACrB2B,EAAkB2E,iBAAiBzP,M,qEA2BnC,OAAOA,KAAK0P,e,uCAOZ,OAAO1P,KAAKiN,e,kCASJ0C,GAYR,OAXA,KAA0B/D,SAAW+D,EAAQrF,KAI7CuC,YAAMA,OAAI,YAAcA,MACxB,KAA0BjB,SAASgE,SAInC/C,YAAMA,OAAI3D,EAA6B2D,GAAOA,MAC9C,KAA0BgD,gCACnB,O,0CASSC,GAEhB,OADA,KAA0BC,iBAAmBD,EACtC,O,8CASaA,GAEpB,OADA,KAA0BE,qBAAuBF,EAC1C,O,sCAWKG,GAEZ,IAAM9G,EAAU,YAAc8G,GAU9B,OATI9G,IAAY,KAA0B8D,eAClC,KAA0BA,cAC1B,KAA0BiD,4BAA4B,KAA0BjD,cAEpF9D,EAAQgH,iBAAiB,YAAa,KAA0B1D,aAAc/B,GAC9EvB,EAAQgH,iBAAiB,aAAc,KAA0B1D,aAAcjC,GAC/E,KAA0B4F,yBAC1B,KAA0BnD,aAAe9D,GAEtC,O,0CASSkH,GAAgBA,WAWhC,OAVA,KAA0B3E,iBAAmB2E,EAAkB,YAAcA,GAAmB,KAChG,KAA0B5E,oBAAoBhI,cAC1C4M,IACA,KAA0B5E,oBAAsB,KAA0BZ,eACrEyF,OAAO,IACP3M,WAAU,kBAGT,EAA0B4M,qCAE7B,O,gCAOPvQ,KAAKkQ,4BAA4BlQ,KAAKiN,cAGlCjN,KAAKqP,cAGLmB,EAAWxQ,KAAKiN,cAEpBuD,EAAWxQ,KAAKyQ,SAChBzQ,KAAK0Q,kBACL1Q,KAAK2Q,sBACL3Q,KAAK8K,kBAAkB8F,eAAe5Q,MACtCA,KAAK6Q,uBACL7Q,KAAKiM,cAAc7J,WACnBpC,KAAKkM,QAAQ9J,WACbpC,KAAKmM,SAAS/J,WACdpC,KAAKoM,MAAMhK,WACXpC,KAAKqM,QAAQjK,WACbpC,KAAKsM,OAAOlK,WACZpC,KAAKuM,QAAQnK,WACbpC,KAAKmL,YAAY/I,WACjBpC,KAAK4L,SAAW,GAChB5L,KAAK6L,iBAAiB7K,QACtBhB,KAAK8N,sBACL9N,KAAKyL,oBAAoBhI,cACzBzD,KAAK0L,iBAAmB1L,KAAKiN,aAAejN,KAAKgQ,qBAC7ChQ,KAAK+P,iBAAmB/P,KAAKyQ,QAAU,O,mCAO3C,OAAOzQ,KAAKoN,qBAAuBpN,KAAK8K,kBAAkBuE,WAAWrP,Q,8BAOrEA,KAAKiN,aAAa3D,MAAMwH,UAAY9Q,KAAKoQ,mBAAqB,GAC9DpQ,KAAKkL,iBAAmB,CAAEF,EAAG,EAAGC,EAAG,GACnCjL,KAAK+K,kBAAoB,CAAEC,EAAG,EAAGC,EAAG,K,oCAO1B4B,GACN7M,KAAK4L,SAAS5B,QAAQ6C,IAAW,GACjC7M,KAAK6L,iBAAiBkF,IAAIlE,K,mCAQrBA,GACT7M,KAAK6L,iBAAiB9G,OAAO8H,K,oCASnBmE,GAEV,OADA,KAA0BjF,WAAaiF,EAChC,O,yCAOQC,GACfjR,KAAK8N,eAAiBmD,I,4CAQtB,IAAMC,EAAWlR,KAAKqP,aAAerP,KAAKkL,iBAAmBlL,KAAK+K,kBAClE,MAAO,CAAEC,EAAGkG,EAASlG,EAAGC,EAAGiG,EAASjG,K,0CASpB3K,GAOhB,OANA,KAA0B4K,iBAAmB,CAAEF,EAAG,EAAGC,EAAG,GACxD,KAA0BF,kBAAkBC,EAAI1K,EAAM0K,EACtD,KAA0BD,kBAAkBE,EAAI3K,EAAM2K,EACjD,KAA0B6C,gBAC3B,KAA0BI,2BAA2B5N,EAAM0K,EAAG1K,EAAM2K,GAEjE,O,qDAQP,IAAMiG,EAAWlR,KAAKmR,sCAClBD,GAAYlR,KAAK8N,gBACjB9N,KAAK+N,2BAA2BmD,K,6CASpClR,KAAKqL,yBAAyB5H,cAC9BzD,KAAKuL,uBAAuB9H,cAC5BzD,KAAKwL,oBAAoB/H,gB,wCAQrBzD,KAAKwN,UACLgD,EAAWxQ,KAAKwN,UAEhBxN,KAAKoR,aACLpR,KAAKoR,YAAYC,UAErBrR,KAAKwN,SAAWxN,KAAKoR,YAAc,O,4CAQ/BpR,KAAK0P,cACLc,EAAWxQ,KAAK0P,cAEhB1P,KAAKsR,iBACLtR,KAAKsR,gBAAgBD,UAEzBrR,KAAK0P,aAAe1P,KAAKsR,gBAAkB,O,uCAQ9B5E,GAAMA,WAKd1M,KAAK8K,kBAAkBuE,WAAWrP,QAGvCA,KAAK6Q,uBACL7Q,KAAK8K,kBAAkByG,aAAavR,MACpCA,KAAK6P,gCACD7P,KAAK4L,WACL5L,KAAKiN,aAAa3D,MAAMG,wBAA0BzJ,KAAKwR,0BAEtDxR,KAAKoN,sBAGVpN,KAAKmM,SAAShK,KAAK,CAAE4G,OAAQ/I,OACzBA,KAAK8N,gBAEL9N,KAAK8N,eAAe2D,iBACpBzR,KAAK0R,+BAA+B5Q,MAAK,WAIrCd,EAAK2R,sBAAsBjF,GAC3B1M,EAAK4R,2BACL5R,EAAK8K,kBAAkByG,aAAavR,QAOxCA,KAAK+K,kBAAkBC,EAAIhL,KAAKkL,iBAAiBF,EACjDhL,KAAK+K,kBAAkBE,EAAIjL,KAAKkL,iBAAiBD,EACjDjL,KAAK4K,QAAQ0D,KAAI,WAIbtO,EAAKoM,MAAMjK,KAAK,CACZ4G,OAAQ/I,EACRwO,SAAUxO,EAAKyO,iBAAiBzO,EAAK4O,0BAA0BlC,SAGvE1M,KAAK4R,2BACL5R,KAAK8K,kBAAkByG,aAAavR,W,yCASzB0M,GAOf,GALA1M,KAAKkM,QAAQ/J,KAAK,CAAE4G,OAAQ/I,OACxB6R,EAAanF,KACb1M,KAAK8R,oBAAsB9C,KAAKC,OAEpCjP,KAAK6P,gCACD7P,KAAK8N,eAAgB,CAErB,IAAM3E,EAAUnJ,KAAKiN,aAEf8E,EAA4B5I,EAAmB,WAE/C6I,EAAUhS,KAAKwN,SAAWxN,KAAKiS,wBAE/BC,EAAclS,KAAK0P,aAAe1P,KAAKmS,4BAEvCC,EAASpS,KAAKyQ,QAAUzQ,KAAKyQ,SAAWzQ,KAAKkH,UAAUmL,cAAc,IAE3EN,EAAOO,aAAaF,EAAQjJ,GAI5BA,EAAQG,MAAMpK,QAAU,OACxBc,KAAKkH,UAAUqL,KAAKC,YAAYT,EAAOU,aAAaP,EAAa/I,KA09B3CuJ,EAz9BG1S,KAAKkH,UA69B/BwL,EAAYC,mBACfD,EAAYE,yBACZF,EAAYG,sBACZH,EAAYI,qBACZJ,EAAYH,MAj+BiCC,YAAYR,GACrDhS,KAAK8N,eAAeiF,QAw9BhC,IAAkCL,I,8CA78BNM,EAAkBtG,GAAMA,WAI5CA,EAAMuG,kBAEN,IAAM5D,EAAarP,KAAKqP,aAElB6D,EAAkBrB,EAAanF,GAE/ByG,GAA0BD,GAA2D,IAAxC,EAA6BE,OAE1EnD,EAAcjQ,KAAKiN,aAEnBoG,GAAoBH,GAAmBlT,KAAK8R,qBAC9C9R,KAAK8R,oBAlpBe,IAkpBiC9C,KAAKC,MAW9D,GAJIvC,EAAMI,QAA8BJ,EAAc,OAAE4G,WAA4B,cAAf5G,EAAM6G,MACvE7G,EAAMS,mBAGNkC,GAAc8D,GAA0BE,GAA5C,CAMIrT,KAAK4L,SAAStE,SACdtH,KAAKwR,yBAA2BvB,EAAY3G,MAAMG,wBAClDwG,EAAY3G,MAAMG,wBAA0B,eAEhDzJ,KAAKoN,oBAAsBpN,KAAK4N,aAChC5N,KAAKwT,kBAAuCxT,KAAoB,eAGhEA,KAAK6Q,uBACL7Q,KAAKqL,yBAA2BrL,KAAK8K,kBAAkB2I,YAAY9P,UAAU3D,KAAKkN,cAClFlN,KAAKuL,uBAAyBvL,KAAK8K,kBAAkB4I,UAAU/P,UAAU3D,KAAKuP,YAC9EvP,KAAKwL,oBAAsBxL,KAAK8K,kBAAkB6I,OAAOC,KAAK,OAAAC,EAAA,GAAU,OAAOlQ,WAAU,WAIrF3D,EAAK8T,gBAAkB9T,EAAK6K,eAAekJ,+BAE3C/T,KAAK0L,mBACL1L,KAAKgU,cAAgBhU,KAAK0L,iBAAiB+B,yBAI/CzN,KAAKiU,yBAA2BjU,KAAK+P,kBAAoB/P,KAAK+P,iBAAiBD,SAC3E,CAAE9E,EAAG,EAAGC,EAAG,GACXjL,KAAKkU,6BAA6BlB,EAAkBtG,GAExD,IAAM6B,EAAkBvO,KAAKiO,sBAAwBjO,KAAK4O,0BAA0BlC,GACpF1M,KAAK2O,uBAAyB,CAAE3D,EAAG,EAAGC,EAAG,GACzCjL,KAAKmR,sCAAwC,CAAEnG,EAAGuD,EAAgBvD,EAAGC,EAAGsD,EAAgBtD,GACxFjL,KAAKkP,eAAiBF,KAAKC,MAC3BjP,KAAK8K,kBAAkBqJ,cAAcnU,KAAM0M,M,4CAQzBA,GAAMA,WAKxB1M,KAAKiN,aAAa3D,MAAMpK,QAAU,GACfc,KAAKyQ,QAAmB,WAAEgC,aAAazS,KAAKiN,aAAcjN,KAAKyQ,SAClFzQ,KAAK0Q,kBACL1Q,KAAK2Q,sBACL3Q,KAAKgU,cAAgBhU,KAAKqN,oBAE1BrN,KAAK4K,QAAQ0D,KAAI,WAKb,IAAM2C,EAA+BjR,EAAoB,eAEnDoU,EAAenD,EAAUoD,aAAarU,GAEtCuO,EAAkBvO,EAAK4O,0BAA0BlC,GAEjD8B,EAAWxO,EAAKyO,iBAAiBzO,EAAK4O,0BAA0BlC,IAEhE4H,EAAyBrD,EAAUsD,iBAAiBhG,EAAgBvD,EAAGuD,EAAgBtD,GAC7FjL,EAAKoM,MAAMjK,KAAK,CAAE4G,OAAQ/I,EAAMwO,aAChCxO,EAAKuM,QAAQpK,KAAK,CACdqS,KAAMxU,EACNoU,eACAK,cAAezU,EAAKwT,kBAAkBa,aAAarU,GACnDiR,UAAWA,EACXyD,kBAAmB1U,EAAKwT,kBACxBc,yBACA9F,aAEJyC,EAAU0D,KAAK3U,EAAMoU,EAAcpU,EAAKwT,kBAAmBc,EAAwB9F,GACnFxO,EAAK8N,eAAiB9N,EAAKwT,uB,oDAUHvI,WAAHD,EAAGC,EAAL,EAAKA,IAAF,EAGtB2J,EAAe5U,KAAKwT,kBAAkBqB,iCAAiC7U,KAAMgL,EAAGC,IAK/E2J,GAAgB5U,KAAK8N,iBAAmB9N,KAAKwT,mBAC9CxT,KAAKwT,kBAAkBe,iBAAiBvJ,EAAGC,KAC3C2J,EAAe5U,KAAKwT,mBAEpBoB,GAAgBA,IAAiB5U,KAAK8N,gBACtC9N,KAAK4K,QAAQ0D,KAAI,WAKbtO,EAAKsM,OAAOnK,KAAK,CAAEqS,KAAMxU,EAAMiR,UAA8BjR,EAAoB,iBAC9DA,EAAoB,eAAE8U,KAAK9U,GAE9CA,EAAK8N,eAAiB,EACtB9N,EAAK8N,eAAeiH,MAAM/U,EAAMgL,EAAGC,GACnCjL,EAAKqM,QAAQlK,KAAK,CACdqS,KAAMxU,EACNiR,UAAW,EACXmD,aAAc,EAAkCC,aAAarU,QAItDA,KAAoB,eAAEgV,2BAA2BhK,EAAGC,GACpDjL,KAAoB,eAAEiV,UAAUjV,KAAMgL,EAAGC,EAAGjL,KAAK2O,wBACpE3O,KAAKwN,SAASlE,MAAMwH,UAChBoE,EAAalK,EAAIhL,KAAKiU,yBAAyBjJ,EAAGC,EAAIjL,KAAKiU,yBAAyBhJ,K,8CAUxF,IAMI+G,EANEmD,EAAgBnV,KAAK+P,iBAErBqF,EAAepV,KAAKoV,aAEpBC,EAAkBF,EAAgBA,EAAcrF,SAAW,KAGjE,GAAIuF,EAAiB,CAEjB,IAAMC,EAAU,EAAmCC,cAAcC,mBAAmBH,EAAiB,EAAmCI,SACxIzD,EAAU0D,EAAYJ,EAAStV,KAAKkH,WACpClH,KAAKoR,YAAckE,EACnBtD,EAAQ1I,MAAMwH,UACVoE,EAAalV,KAAKiO,sBAAsBjD,EAAGhL,KAAKiO,sBAAsBhD,OAEzE,CAED,IAAM9B,EAAUnJ,KAAKiN,aAEf0I,EAAcxM,EAAQsE,yBAC5BuE,EAAU4D,EAAczM,IAChBG,MAAMgE,MAAd0E,UAAyB2D,EAAYrI,MAArC0E,MACAA,EAAQ1I,MAAMiE,OAAdyE,UAA0B2D,EAAYpI,OAAtCyE,MACAA,EAAQ1I,MAAMwH,UAAYoE,EAAaS,EAAYE,KAAMF,EAAYG,KA4BzE,OA1BAjN,EAAamJ,EAAQ1I,MAAO,CAGxByM,cAAe,OAEfC,OAAQ,IACR9E,SAAU,QACV4E,IAAK,IACLD,KAAM,IACNI,OAAQ,SAEZ/M,EAA6B8I,GAAQA,GACrCA,EAAQlK,UAAUiJ,IAAI,oBACtBiB,EAAQ5D,aAAa,MAAOpO,KAAK+L,YAC7BqJ,IACI7N,MAAM2O,QAAQd,GACdA,EAAaxF,SAIbuG,YAASA,OAAInE,EAAQlK,UAAUiJ,IAAIoF,MAGnCnE,EAAQlK,UAAUiJ,IAAIqE,IAGvBpD,I,qDAOmB,WAE1B,IAAKhS,KAAK4N,UACN,OAAOwI,QAAQC,UAGnB,IAAMC,EAAkBtW,KAAK0P,aAAajC,wBAE1CzN,KAAKwN,SAAS1F,UAAUiJ,IAAI,sBAE5B/Q,KAAKwN,SAASlE,MAAMwH,UAAYoE,EAAaoB,EAAgBT,KAAMS,EAAgBR,KAMnF,IAAMS,EA/7Bd,SAA4CpN,GAExC,IAAMgB,EAAgBqM,iBAAiBrN,GAEjCsN,EAAyBvM,EAAsBC,EAAe,uBAE9DuM,EAAWD,EAAuB7J,MAIxC+J,YAAIA,MAAa,cAATA,GAAiC,QAATA,KAEhC,IAAKD,EACD,OAAO,EAKX,IAAME,EAAgBH,EAAuBzM,QAAQ0M,GAE/CG,EAAe3M,EAAsBC,EAAe,uBAEpD2M,EAAY5M,EAAsBC,EAAe,oBACvD,OAAON,EAAsBgN,EAAaD,IACtC/M,EAAsBiN,EAAUF,IAxBxC,CA+7B4D5W,KAAKwN,UACzD,OAAiB,IAAb+I,EACOH,QAAQC,UAEZrW,KAAK4K,QAAQmM,mBAAkB,kBAI3B,IAAIX,SAIXC,YAEI,IAAMW,EAILtK,SAJKsK,EAILtK,KACQA,GAAUA,EAAMI,SAAW9M,EAAKwN,UAAmC,cAAvBd,EAAMuK,gBACnDjX,EAAKwN,SAAS0J,oBAAoB,gBAAiBF,GACnDX,IACAc,aAAaC,KAOfA,EAAUC,WAAW,EAAyC,IAAXd,GACzDvW,EAAKwN,SAAS2C,iBAAiB,gBAAiB6G,W,kDAWxD,IAII9E,EAJEoF,EAAoBtX,KAAKgQ,qBAEzBuH,EAAsBD,EAAoBA,EAAkBxH,SAAW,KAW7E,OARIyH,GACAvX,KAAKsR,gBAAkB,EAAuCiE,cAAcC,mBAAmB+B,EAAqB,EAAuC9B,SAC3JvD,EAAcwD,EAAY1V,KAAKsR,gBAAiBtR,KAAKkH,YAGrDgL,EAAc0D,EAAc5V,KAAKiN,cAErCiF,EAAYpK,UAAUiJ,IAAI,wBACnBmB,I,mDASkBc,EAAkBtG,GAE3C,IAAMiJ,EAAc3V,KAAKiN,aAAaQ,wBAEhC+J,EAAgBxE,IAAqBhT,KAAKiN,aAAe,KAAO+F,EAEhEyE,EAAgBD,EAAgBA,EAAc/J,wBAA0BkI,EAExE+B,EAAQ7F,EAAanF,GAASA,EAAMiL,cAAc,GAAKjL,EAK7D,MAAO,CACH1B,EAAGyM,EAAc5B,KAAOF,EAAYE,MAJ9B6B,EAAME,MAAQH,EAAc5B,KAAO7V,KAAK8T,gBAAgB+B,MAK9D5K,EAAGwM,EAAc3B,IAAMH,EAAYG,KAH7B4B,EAAMG,MAAQJ,EAAc3B,IAAM9V,KAAK8T,gBAAgBgC,Q,gDAY3CpJ,GAGtB,IAAMgL,EAAQ7F,EAAanF,GAAUA,EAAMoL,QAAQ,IAAMpL,EAAMqL,eAAe,GAAMrL,EACpF,MAAO,CACH1B,EAAG0M,EAAME,MAAQ5X,KAAK8T,gBAAgB+B,KACtC5K,EAAGyM,EAAMG,MAAQ7X,KAAK8T,gBAAgBgC,O,qDASfpJ,GAE3B,IAAMgL,EAAQ1X,KAAK4O,0BAA0BlC,GAEvCsL,EAAmBhY,KAAKiY,kBAAoBjY,KAAKiY,kBAAkBP,EAAO1X,MAAQ0X,EAElFQ,EAAoBlY,KAAK8N,eAAiB9N,KAAK8N,eAAeqK,SAAW,KAO/E,GANsB,MAAlBnY,KAAKmY,UAA0C,MAAtBD,EACzBF,EAAiB/M,EAAIjL,KAAKiO,sBAAsBhD,EAEzB,MAAlBjL,KAAKmY,UAA0C,MAAtBD,IAC9BF,EAAiBhN,EAAIhL,KAAKiO,sBAAsBjD,GAEhDhL,KAAKgU,cAAe,CAAC,IAAD,EACehU,KAAKiU,yBAA7BmE,EADS,EACZpN,EAAeqN,EADH,EACApN,EAEdqN,EAAetY,KAAKgU,cAEpBuE,EAAiCvY,KAAkB,aAEnDwY,EAAOF,EAAaxC,IAAMuC,EAE1BI,EAAOH,EAAaI,QAAUH,EAAYhL,OAAS8K,GAKzDL,EAAiBhN,EAAI2N,EAAMX,EAAiBhN,EAH/BsN,EAAazC,KAAOuC,EAEpBE,EAAaM,OAASL,EAAYjL,MAAQ8K,IAEvDJ,EAAiB/M,EAAI0N,EAAMX,EAAiB/M,EAAGuN,EAAMC,GAEzD,OAAOT,I,mDAQkBa,GAAsBA,IACvC7N,EAAS6N,EAAX,EAAK5N,EAAM4N,EAAR,EAEHnK,EAAQ1O,KAAK2O,uBAEbmK,EAA0B9Y,KAAKmR,sCAG/B4H,EAAUlK,KAAKC,IAAI9D,EAAI8N,EAAwB9N,GAE/CgO,EAAUnK,KAAKC,IAAI7D,EAAI6N,EAAwB7N,GAarD,OARI8N,EAAU/Y,KAAK2K,QAAQsO,kCACvBvK,EAAM1D,EAAIA,EAAI8N,EAAwB9N,EAAI,GAAK,EAC/C8N,EAAwB9N,EAAIA,GAE5BgO,EAAUhZ,KAAK2K,QAAQsO,kCACvBvK,EAAMzD,EAAIA,EAAI6N,EAAwB7N,EAAI,GAAK,EAC/C6N,EAAwB7N,EAAIA,GAEzByD,I,sDAQP,GAAK1O,KAAKiN,cAAiBjN,KAAK4L,SAAhC,CAIA,IAAMsN,EAAelZ,KAAK4L,SAAStE,OAAS,IAAMtH,KAAKqP,aACnD6J,IAAiBlZ,KAAK2L,6BACtB3L,KAAK2L,2BAA6BuN,EAClChQ,EAA6BlJ,KAAKiN,aAAciM,O,kDAS5B/P,GACxBA,EAAQ+N,oBAAoB,YAAalX,KAAKyM,aAAc/B,GAC5DvB,EAAQ+N,oBAAoB,aAAclX,KAAKyM,aAAcjC,K,iDAStCQ,EAAGC,GAE1B,IAAM6F,EAAYoE,EAAalK,EAAGC,GAGJ,MAA1BjL,KAAKoQ,oBACLpQ,KAAKoQ,kBAAoBpQ,KAAKiN,aAAa3D,MAAMwH,WAAa,IAKlE9Q,KAAKiN,aAAa3D,MAAMwH,UAAY9Q,KAAKoQ,kBACrCU,EAAY,IAAM9Q,KAAKoQ,kBAAoBU,I,uCAQlCqI,GAEb,IAAMC,EAAiBpZ,KAAKiO,sBAC5B,OAAImL,EACO,CAAEpO,EAAGmO,EAAgBnO,EAAIoO,EAAepO,EAAGC,EAAGkO,EAAgBlO,EAAImO,EAAenO,GAErF,CAAED,EAAG,EAAGC,EAAG,K,iDAQlBjL,KAAKgU,cAAgBhU,KAAKqN,sB,uDAQE,MACbrN,KAAK+K,kBAAdC,EADsB,EACxB,EAAKC,EADmB,EACrB,EACP,KAAW,IAAND,GAAiB,IAANC,GAAYjL,KAAKqP,eAAiBrP,KAAK0L,iBAAvD,CAIA,IAAM4M,EAAetY,KAAK0L,iBAAiB+B,wBAErCkI,EAAc3V,KAAKiN,aAAaQ,wBAGtC,KAA4B,IAAvB6K,EAAahL,OAAuC,IAAxBgL,EAAa/K,QACnB,IAAtBoI,EAAYrI,OAAsC,IAAvBqI,EAAYpI,QAD5C,CAKA,IAAM8L,EAAef,EAAazC,KAAOF,EAAYE,KAE/CyD,EAAgB3D,EAAYiD,MAAQN,EAAaM,MAEjDW,EAAcjB,EAAaxC,IAAMH,EAAYG,IAE7C0D,EAAiB7D,EAAY+C,OAASJ,EAAaI,OAGrDJ,EAAahL,MAAQqI,EAAYrI,OAC7B+L,EAAe,IACfrO,GAAKqO,GAELC,EAAgB,IAChBtO,GAAKsO,IAITtO,EAAI,EAIJsN,EAAa/K,OAASoI,EAAYpI,QAC9BgM,EAAc,IACdtO,GAAKsO,GAELC,EAAiB,IACjBvO,GAAKuO,IAITvO,EAAI,EAEJD,IAAMhL,KAAK+K,kBAAkBC,GAAKC,IAAMjL,KAAK+K,kBAAkBE,GAC/DjL,KAAKyZ,oBAAoB,CAAExO,IAAGD,U,yCASnB0B,GAEf,IAAMpM,EAAQN,KAAKgM,eACnB,MAAqB,iBAAV1L,EACAA,EAEFuR,EAAanF,GACXpM,EAAMoZ,MAEVpZ,EAAQA,EAAMqZ,MAAQ,I,+BAl5B7B,OAAO3Z,KAAKoD,cAAgBpD,KAAK8N,iBAAkB9N,KAAK8N,eAAepK,W,aAM9DpD,GAET,IAAMsZ,EAAW,SAAArX,EAAA,CAAsBjC,GACnCsZ,IAAa5Z,KAAKoD,YAClBpD,KAAKoD,UAAYwW,EACjB5Z,KAAK6P,qC,KA8uCjB,SAASqF,EAAalK,EAAGC,GAGrB,MAAM,eAAN,OAAsB4D,KAAKgL,MAAM7O,GAAjC,eAA0C6D,KAAKgL,MAAM5O,GAArD,UAOJ,SAAS2K,EAAc/N,GAEnB,IAAMiS,EAA2BjS,EAAKkS,WAAUA,GAE1CC,EAAoBF,EAAMG,iBAAiB,QAE3CC,EAAqBrS,EAAKoS,iBAAiB,UAEjDH,EAAMK,gBAAgB,MACtB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAkB1S,OAAQ8S,IAC1CJ,EAAkBI,GAAGD,gBAAgB,MAIzC,GAAID,EAAmB5S,OAGnB,IADA,IAAM+S,EAAgBP,EAAMG,iBAAiB,UACpCG,EAAI,EAAGA,EAAIF,EAAmB5S,OAAQ8S,IAAK,CAEhD,IAAME,EAA4BD,EAAcD,GAAGG,WAAW,MAC1DD,GACAA,EAA0BE,UAAUN,EAAmBE,GAAI,EAAG,GAI1E,OAAON,EASX,SAASnB,EAAMrY,EAAOma,EAAKC,GACvB,OAAO7L,KAAK6L,IAAID,EAAK5L,KAAK4L,IAAIC,EAAKpa,IAOvC,SAASkQ,EAAW3I,GACZA,GAAQA,EAAK8S,YACb9S,EAAK8S,WAAWC,YAAY/S,GAQpC,SAASgK,EAAanF,GAIlB,MAAyB,MAAlBA,EAAM6G,KAAK,GAwBtB,SAASmC,EAAYJ,EAASpO,GAE1B,IAAM2T,EAAWvF,EAAQwF,UAAU,GACnC,GAAID,EAAS7S,WAAad,EAAU6T,aAAc,CAE9C,IAAMC,EAAU9T,EAAU+T,cAAc,OAExC,OADAD,EAAQxI,YAAYqI,GACbG,EAEX,OAAO,EAuBX,SAASE,EAAgBC,EAAOC,EAAWC,GAEvC,IAAM7T,EAAO8T,EAAQF,EAAWD,EAAM7T,OAAS,GAEzCiU,EAAKD,EAAQD,EAASF,EAAM7T,OAAS,GAC3C,GAAIE,IAAS+T,EAAb,CAOA,IAHA,IAAMzO,EAASqO,EAAM3T,GAEfkH,EAAQ6M,EAAK/T,GAAQ,EAAI,EACtB4S,EAAI5S,EAAM4S,IAAMmB,EAAInB,GAAK1L,EAC9ByM,EAAMf,GAAKe,EAAMf,EAAI1L,GAEzByM,EAAMI,GAAMzO,GA4ChB,SAASwO,EAAQhb,EAAOoa,GACpB,OAAO7L,KAAK6L,IAAI,EAAG7L,KAAK4L,IAAIC,EAAKpa,I,IA+E/B,E,WAQF,WAAY6I,EAAS2B,EAAmB5D,EAAW0D,EAASC,GAAeA,mCACvE7K,KAAK8K,kBAAoBA,EACzB9K,KAAK4K,QAAUA,EACf5K,KAAK6K,eAAiBA,EAItB7K,KAAK0D,YAIL1D,KAAKwb,mBAKLxb,KAAKyb,sBAKLzb,KAAK0b,eAAiB,qBAOtB1b,KAAKiM,cAAgB,IAAIb,EAAA,EAIzBpL,KAAKqM,QAAU,IAAIjB,EAAA,EAKnBpL,KAAKsM,OAAS,IAAIlB,EAAA,EAIlBpL,KAAKuM,QAAU,IAAInB,EAAA,EAInBpL,KAAK2b,OAAS,IAAIvQ,EAAA,EAIlBpL,KAAK4b,eAIL5b,KAAK6b,eAAiB,GAItB7b,KAAK8T,gBAAkB,CAAEgC,IAAK,EAAGD,KAAM,GAIvC7V,KAAK8b,wBAA0B,CAAEhG,IAAK,EAAGD,KAAM,GAK/C7V,KAAK+b,cAAgB,CAAEC,KAAM,KAA2BtN,MAAO,GAI/D1O,KAAKic,UAAY,GAIjBjc,KAAKkc,aAAe,WAIpBlc,KAAKmc,gBAAkB,IAAIrQ,IAI3B9L,KAAK+L,WAAa,MAIlB/L,KAAKoc,4BAA8B9Q,EAAA,EAAaxI,MAIhD9C,KAAKqc,yBAA2B,EAIhCrc,KAAKsc,2BAA6B,EAIlCtc,KAAKuc,kBAAoB,IAAInR,EAAA,EAI7BpL,KAAKwc,kBAAoB,KAIzBxc,KAAKyc,cAAgB,WAIjB,GAAKzc,EAAKqP,aAAV,CAIA,IAAMlG,EAAU,YAAcnJ,EAAKmJ,SACnCnJ,EAAK0c,mBAAmB1c,EAAK8T,gBAAiB3K,EAAQwT,UAAWxT,EAAQyT,cAK7E5c,KAAK6c,qBAAuB,WAIxB7c,EAAKyR,iBDjkEV,WAA0C,IAAxB9I,EAAwB,uDAAf,EAAGmU,EAAY,yDAAAC,EAO7C,QANK,OAAAC,EAAA,GAAUrU,IAAWA,EAAS,KAC/BA,EAAS,GAERmU,GAA2C,mBAAvBA,EAAUlU,WAC/BkU,EAAY,EAAAC,GAET,IAAIE,EAAA,GAAWxU,YAAUA,OAC5BA,EAAWsI,IAAI+L,EAAUlU,SAASL,EAAUI,EAAQ,CAAEF,aAAYC,QAAS,EAAGC,YACvEF,KATR,CCkkEc,EAAGyU,EAAAH,GACPnJ,KAAK,OAAAuJ,EAAA,GAAUnd,EAAKuc,oBACpB5Y,WAAU,WAKX,IAAMkE,EAAO7H,EAAKod,YACoB,IAAlCpd,EAAKqc,yBACLgB,EAAwBxV,GApMnB,GAsMkC,IAAlC7H,EAAKqc,0BACVgB,EAAwBxV,EAvMnB,GAyM+B,IAApC7H,EAAKsc,2BACLgB,EAA0BzV,GA1MrB,GA4MoC,IAApC7H,EAAKsc,4BACVgB,EAA0BzV,EA7MrB,OAiNjB7H,KAAKmJ,QAAU,YAAcA,GAC7BnJ,KAAKkH,UAAYA,EACjB4D,EAAkByS,sBAAsBvd,M,uDAOxCA,KAAKyR,iBACLzR,KAAKuc,kBAAkBna,WACvBpC,KAAKwd,mBACLxd,KAAKiM,cAAc7J,WACnBpC,KAAKqM,QAAQjK,WACbpC,KAAKsM,OAAOlK,WACZpC,KAAKuM,QAAQnK,WACbpC,KAAK2b,OAAOvZ,WACZpC,KAAKmc,gBAAgBnb,QACrBhB,KAAKod,YAAc,KACnBpd,KAAK8K,kBAAkB2S,oBAAoBzd,Q,mCAO3C,OAAOA,KAAK4b,c,8BAMT,WAEGzS,EAAU,YAAcnJ,KAAKmJ,SACnCnJ,KAAKiM,cAAc9J,OACnBnC,KAAK4b,eACL5b,KAAK0d,cACL1d,KAAKic,UAAUrM,SAIf+N,YAAOA,OAAIA,EAAQC,gBAAgB5d,MACnCA,KAAKwd,mBACLxd,KAAK4K,QAAQmM,mBAAkB,kBAGzB5N,EAAQgH,iBAAiB,SAAUnQ,EAAKyc,kBAC9Czc,KAAK6d,0B,4BASHrJ,EAAMsJ,EAAUC,GAClB/d,KAAK+S,QAIL,IAAIiL,EAAWhe,KAAKwb,gBAAkBxb,KAAKie,YAAYjU,QAAQwK,IAAS,GACtD,IAAdwJ,IAGAA,EAAWhe,KAAKke,iCAAiC1J,EAAMsJ,EAAUC,IAGrE,IAAMI,EAAmBne,KAAKoe,kBAExBhK,EAAe+J,EAAiBnU,QAAQwK,GAExCtC,EAAcsC,EAAK6J,wBAErBC,EAAuBH,EAAiBH,GAc5C,GAVIM,IAAyB9J,IACzB8J,EAAuBH,EAAiBH,EAAW,IAInD5J,GAAgB,GAChB+J,EAAiBI,OAAOnK,EAAc,GAItCkK,IAAyBte,KAAK8K,kBAAkBuE,WAAWiP,GAAuB,CAElF,IAAMnV,EAAUmV,EAAqBE,iBAClBrV,EAAsB,cAAEmJ,aAAaJ,EAAa/I,GACrEgV,EAAiBI,OAAOP,EAAU,EAAGxJ,QAGrC,YAAcxU,KAAKmJ,SAASqJ,YAAYN,GACxCiM,EAAiBM,KAAKjK,GAG1BtC,EAAY5I,MAAMwH,UAAY,GAG9B9Q,KAAK0e,sBACL1e,KAAKqM,QAAQlK,KAAK,CAAEqS,OAAMvD,UAAWjR,KAAMoU,aAAcpU,KAAKqU,aAAaG,O,2BAO1EA,GACDxU,KAAK2e,SACL3e,KAAKsM,OAAOnK,KAAK,CAAEqS,OAAMvD,UAAWjR,S,2BAYnCwU,EAAMJ,EAAcM,EAAmBJ,EAAwB9F,GAChExO,KAAK2e,SACL3e,KAAKuM,QAAQpK,KAAK,CACdqS,OACAJ,eACAK,cAAeC,EAAkBL,aAAaG,GAC9CvD,UAAWjR,KACX0U,oBACAJ,yBACA9F,e,gCAUEoQ,GAAMA,WAUZ,OATA,KAA0BX,YAAcW,EACxCA,EAAMhP,SAIN4E,YAAIA,OAAIA,EAAKqK,mBAAmB,MAC5B,KAA0BxP,cAC1B,KAA0BqO,cAEvB,O,oCASG1M,GAEV,OADA,KAA0BjF,WAAaiF,EAChC,O,kCAUC8N,GAER,OADA,KAA0B7C,UAAY6C,EAAYC,QAC3C,O,sCASKC,GAEZ,OADA,KAA0B9C,aAAe8C,EAClC,O,mCAOExK,GACT,OAAKxU,KAAK4b,YASHqD,EAF6B,eAAtBjf,KAAKkc,cAAqD,QAApBlc,KAAK+L,WACrD/L,KAAK6b,eAAekD,QAAQG,UAAYlf,KAAK6b,gBAKjDsD,YAAWA,OAAIA,EAAYnD,OAASxH,KAZzBxU,KAAKie,YAAYjU,QAAQwK,K,oCAoBpC,OAAOxU,KAAKmc,gBAAgBiD,KAAO,I,gCAU7B5K,EAAMsJ,EAAUC,EAAUsB,GAEhC,IAAIrf,KAAKwb,iBAAoBxb,KAAKsf,4BAA4BxB,EAAUC,GAAxE,CAIA,IAAMwB,EAAWvf,KAAK6b,eAEhBmC,EAAWhe,KAAKke,iCAAiC1J,EAAMsJ,EAAUC,EAAUsB,GACjF,MAAkB,IAAdrB,GAAmBuB,EAASjY,OAAS,GAAzC,CAIA,IAAMkY,EAAqC,eAAtBxf,KAAKkc,aAEpB9H,EAAe6K,EAAUM,GAI/BJ,YAAWA,OAAIA,EAAYnD,OAASxH,KAE9BiL,EAAuBF,EAASvB,GAEhC7E,EAAkBoG,EAASnL,GAAcsL,WAEzCC,EAAcF,EAAqBC,WAEnChR,EAAQ0F,EAAe4J,EAAW,GAAK,EAC7Che,KAAK+b,cAAcC,KAAOyD,EAAqBzD,KAC/Chc,KAAK+b,cAAcrN,MAAQ8Q,EAAeH,EAAarU,EAAIqU,EAAapU,EAGxE,IAAM2U,EAAa5f,KAAK6f,iBAAiB1G,EAAiBwG,EAAajR,GAGjEoR,EAAgB9f,KAAK+f,oBAAoB3L,EAAcmL,EAAU7Q,GAIjEsR,EAAWT,EAASR,QAE1B7D,EAAgBqE,EAAUnL,EAAc4J,GACxChe,KAAK2b,OAAOxZ,KAAK,CACbsS,cAAeL,EACfA,aAAc4J,EACd/M,UAAWjR,KACXwU,SAEJ+K,EAAS3P,SAAQ,SAKhB+N,EAASsC,GAEN,GAAID,EAASC,KAAWtC,EAAxB,CAIA,IAAMuC,EAAgBvC,EAAQ3B,OAASxH,EAEjC2L,EAASD,EAAgBN,EAAaE,EAEtCM,EAAkBF,EAAgB1L,EAAK6J,wBACzCV,EAAQ3B,KAAKwC,iBAEjBb,EAAQwC,QAAUA,EAKdX,GAGAY,EAAgB9W,MAAMwH,UAAtBsP,sBAAiDvR,KAAKgL,MAAM8D,EAAQwC,QAApEC,aACAC,EAAiB1C,EAAQ+B,WAAY,EAAGS,KAGxCC,EAAgB9W,MAAMwH,UAAtBsP,yBAAoDvR,KAAKgL,MAAM8D,EAAQwC,QAAvEC,UACAC,EAAiB1C,EAAQ+B,WAAYS,EAAQ,Y,iDAW9BrC,EAAUC,GACjC,IAAI/d,KAAKyb,mBAAT,CAIA,IAAI6E,EAEAC,EAA0B,EAE1BC,EAA4B,EAEhC,GAAIxgB,KAAKsf,4BAA4BxB,EAAUC,GAAW,CAAC,IAAD,IAEhD5U,EAAU,YAAcnJ,KAAKmJ,SAASA,EAguBxD,SAAoCA,EAASuW,EAAY5B,EAAUC,GAE/D,IAAM0C,EAAmBC,EAA2BhB,EAAY3B,GAE1D4C,EAAqBC,EAA6BlB,EAAY5B,GAEhEyC,EAA0B,EAE1BC,EAA4B,EAKhC,GAAIC,EAAkB,CAElB,IAAM9D,EAAYxT,EAAQwT,UACD,IAArB8D,EACI9D,EAAY,IACZ4D,EAA0B,GAGzBpX,EAAQ0X,aAAelE,EAAYxT,EAAQ2X,eAChDP,EAA0B,GAGlC,GAAII,EAAoB,CAEpB,IAAM/D,EAAazT,EAAQyT,WACA,IAAvB+D,EACI/D,EAAa,IACb4D,EAA4B,GAG3BrX,EAAQ4X,YAAcnE,EAAazT,EAAQ6X,cAChDR,EAA4B,GAGpC,MAAO,CAACD,EAAyBC,GArCrC,CA9tB2CrX,EAASnJ,KAAKihB,YAAanD,EAAUC,GADnEwC,GAD2CpX,0BAClBqX,EADkBrX,MAGxCoX,GAA2BC,KAC3BF,EAAanX,GAIrB,IAAKoX,IAA4BC,EAA2B,CAAC,IAAD,EAC9BxgB,KAAK6K,eAAeqW,kBAAtC5T,EADgD,EAClD,MAASC,EADyC,EAC3C,OAEPmS,EAAa,CAAEpS,QAAOC,SAAQuI,IAAK,EAAG8C,MAAOtL,EAAOoL,OAAQnL,EAAQsI,KAAM,GAChF0K,EAA0BG,EAA2BhB,EAAY3B,GACjEyC,EAA4BI,EAA6BlB,EAAY5B,GACrEwC,EAAaa,QAEbb,GAAeC,IAA4BvgB,KAAKqc,0BAChDmE,IAA8BxgB,KAAKsc,4BACnCgE,IAAetgB,KAAKod,cACpBpd,KAAKqc,yBAA2BkE,EAChCvgB,KAAKsc,2BAA6BkE,EAClCxgB,KAAKod,YAAckD,GACdC,GAA2BC,IAA8BF,EAC1DtgB,KAAK4K,QAAQmM,kBAAkB/W,KAAK6c,sBAGpC7c,KAAKyR,qB,uCASbzR,KAAKuc,kBAAkBpa,S,0CASvB,IAAMgH,EAAU,YAAcnJ,KAAKmJ,SACnCnJ,KAAKihB,YAAcG,EAAqBjY,GACxCnJ,KAAK8T,gBAAkB,CAAEgC,IAAK3M,EAAQwT,UAAW9G,KAAM1M,EAAQyT,c,4CAO9C,WAEX4C,EAAqC,eAAtBxf,KAAKkc,aAC1Blc,KAAK6b,eAAiB7b,KAAKoe,kBAAkB9T,KAI7C0R,YAEI,IAAMqF,EAAmBrhB,EAAK8K,kBAAkBuE,WAAW2M,GAGvDA,EAAKqC,wBACLrC,EAAKwC,iBACT,MAAO,CAAExC,OAAMmE,OAAQ,EAAGT,WAAY0B,EAAqBC,OAC3DC,MAAK,SAKRvE,EAAGwE,GALK,OAME/B,EAAezC,EAAE2C,WAAW7J,KAAO0L,EAAE7B,WAAW7J,KACnDkH,EAAE2C,WAAW5J,IAAMyL,EAAE7B,WAAW5J,S,+BAQpC,WACJ9V,KAAK4b,eAEL5b,KAAKoe,kBAAkBxO,SAIvB4E,YAAIA,OAAIA,EAAKgK,iBAAiBlV,MAAMwH,UAAY,MAChD9Q,KAAKic,UAAUrM,SAIf+N,YAAOA,OAAIA,EAAQ6D,eAAexhB,MAClCA,KAAKoe,kBAAoB,GACzBpe,KAAK6b,eAAiB,GACtB7b,KAAK+b,cAAcC,KAAO,KAC1Bhc,KAAK+b,cAAcrN,MAAQ,EAC3B1O,KAAKyR,iBACLzR,KAAKwd,qB,0CAUWpJ,EAAcmL,EAAU7Q,GAExC,IAAM8Q,EAAqC,eAAtBxf,KAAKkc,aAEpB/C,EAAkBoG,EAASnL,GAAcsL,WAEzC+B,EAAmBlC,EAASnL,GAAwB,EAAT1F,GAE7CoR,EAAgB3G,EAAgBqG,EAAe,QAAU,UAAY9Q,EACzE,GAAI+S,EAAkB,CAElB,IAAM1O,EAAQyM,EAAe,OAAS,MAEhCkC,EAAMlC,EAAe,QAAU,UAKtB,IAAX9Q,EACAoR,GAAiB2B,EAAiB/B,WAAW3M,GAASoG,EAAgBuI,GAGtE5B,GAAiB3G,EAAgBpG,GAAS0O,EAAiB/B,WAAWgC,GAG9E,OAAO5B,I,kDASiBhC,EAAUC,GAASA,MACS/d,KAAKihB,YAAjDnL,EADmCiI,EACrC,IAAOnF,EAD8BmF,EAChC,MAASrF,EADuBqF,EACzB,OAAUlI,EADekI,EACjB,KAEpB4D,EA3rBmB,IAwrBkB5D,EACX,MAI1B6D,EA7rBmB,IAwrBkB7D,EACJ,OAKvC,OAAOA,EAAWjI,EAAM8L,GAAc7D,EAAWrF,EAASkJ,GACtD9D,EAAWjI,EAAO8L,GAAc7D,EAAWlF,EAAQ+I,I,uCAU1CxI,EAAiBwG,EAAajR,GAE3C,IAAM8Q,EAAqC,eAAtBxf,KAAKkc,aAEtB0D,EAAaJ,EAAeG,EAAY9J,KAAOsD,EAAgBtD,KAC/D8J,EAAY7J,IAAMqD,EAAgBrD,IAMtC,OAJe,IAAXpH,IACAkR,GAAcJ,EAAeG,EAAYrS,MAAQ6L,EAAgB7L,MAC7DqS,EAAYpS,OAAS4L,EAAgB5L,QAEtCqS,I,uDAWsBpL,EAAMsJ,EAAUC,EAAUrP,GAAMA,WAEvD8Q,EAAqC,eAAtBxf,KAAKkc,aAC1B,OAAO+C,EAAUjf,KAAK6b,gBAAgB,WAMfgG,EAAG1G,OAAvBa,EAAuBb,EAAvBa,KAAM0D,EAAiBvE,EAAjBuE,WACL,GAAI1D,IAASxH,EAGT,OAAO2G,EAAM7T,OAAS,EAE1B,GAAIoH,EAAO,CAEP,IAAMsC,EAAYwO,EAAe9Q,EAAM1D,EAAI0D,EAAMzD,EAGjD,GAAI+Q,IAAShc,EAAK+b,cAAcC,MAAQhL,IAAchR,EAAK+b,cAAcrN,MACrE,OAAM,EAGd,OAAO8Q,EAGH1B,GAAYjP,KAAKiT,MAAMpC,EAAW7J,OAASiI,GAAYjP,KAAKiT,MAAMpC,EAAW9G,OAC7EmF,GAAYlP,KAAKiT,MAAMpC,EAAW5J,MAAQiI,GAAYlP,KAAKiT,MAAMpC,EAAWhH,a,oCASpF1Y,KAAKoe,kBAAoBpe,KAAKie,YAAYc,QAC1C/e,KAAK0e,sBACL1e,KAAK+hB,sB,yCAaUC,EAAgBC,EAAQC,EAASC,GAAgBA,WAE1DC,EAAgBJ,EAAelM,IAAMmM,EAErCI,EAAiBL,EAAenM,KAAOqM,EACzCC,GACA9B,EAAiB8B,EAAiBC,EAAeC,GAKrDriB,KAAK6b,eAAejM,SAAQ,YAKxByQ,EADDX,aAC8B0C,EAAeC,MAIhDriB,KAAK6b,eAAejM,SAAQ,YAIzBoM,aACKhc,EAAK8K,kBAAkBuE,WAAW2M,IAGlCA,EAAKsG,kCAGbN,EAAelM,IAAMmM,EACrBD,EAAenM,KAAOqM,I,yCAQtB,YAAcliB,KAAKmJ,SAAS+N,oBAAoB,SAAUlX,KAAKyc,eAC/Dzc,KAAKoc,4BAA4B3Y,gB,uCAQpBuH,EAAGC,GAChB,OAAOsX,EAAmBviB,KAAKihB,YAAajW,EAAGC,K,uDAUlBuJ,EAAMxJ,EAAGC,GACtC,OAAOjL,KAAKic,UAAUrP,MAItB+Q,YAAOA,OAAIA,EAAQ6E,YAAYhO,EAAMxJ,EAAGC,Q,kCAShCuJ,EAAMxJ,EAAGC,GACjB,IAAKsX,EAAmBviB,KAAKihB,YAAajW,EAAGC,KAAOjL,KAAK0b,eAAelH,EAAMxU,MAC1E,OAAM,EAGV,IAAMyiB,EAAsCziB,KAAK0iB,iBAAiBD,iBAAiBzX,EAAGC,GAGtF,IAAKwX,EACD,OAAM,EAGV,IAAM/a,EAAgB,YAAc1H,KAAKmJ,SAOzC,OAAOsZ,IAAqB/a,GAAiBA,EAAcK,SAAS0a,K,sCAOxD9E,GAEZ,IAAMgF,EAAiB3iB,KAAKmc,gBACvBwG,EAAe5V,IAAI4Q,KACpBgF,EAAe5R,IAAI4M,GACnB3d,KAAK+hB,oBACL/hB,KAAK6d,2B,qCAQEF,GACX3d,KAAKmc,gBAAgBpX,OAAO4Y,GAC5B3d,KAAKoc,4BAA4B3Y,gB,8CAQd,WACnBzD,KAAK8b,wBAA6C9b,KAAoB,eAAE+T,4BACxE/T,KAAKoc,4BAA8Bpc,KAAK8K,kBAAkB6I,OAAOhQ,WAAU,WAIvE,GAAI3D,EAAKqP,aAAc,CAEnB,IAAMsQ,EAAiC3f,EAAoB,eAAE+T,4BAC7D/T,EAAK0c,mBAAmB1c,EAAK8b,wBAAyB6D,EAAY7J,IAAK6J,EAAY9J,KAAM7V,EAAKihB,kBAEzFjhB,EAAK4iB,eACV5iB,EAAK+hB,yB,uCAgBb,OAHK/hB,KAAKwc,oBACNxc,KAAKwc,kBA0YjB,SAAuBrT,GACnB,GAAI,cAAsB,CAEtB,IAAM0R,EAAW1R,EAAQuM,YAAcvM,EAAQuM,cAAgB,KAC/D,GAAImF,aAAoBgI,WACpB,OAAOhI,EAGf,OAAO,KARX,CA1YmD,YAAc7a,KAAKmJ,WAAanJ,KAAKkH,WAEzElH,KAAKwc,sB,KA2NpB,SAAS6D,EAAiBX,EAAY5J,EAAKD,GACvC6J,EAAW5J,KAAOA,EAClB4J,EAAWhH,OAASgH,EAAW5J,IAAM4J,EAAWnS,OAChDmS,EAAW7J,MAAQA,EACnB6J,EAAW9G,MAAQ8G,EAAW7J,KAAO6J,EAAWpS,MAUpD,SAAS2R,EAAU9D,EAAO2H,GACtB,IAAK,IAAI1I,EAAI,EAAGA,EAAIe,EAAM7T,OAAQ8S,IAC9B,GAAI0I,EAAU3H,EAAMf,GAAIA,EAAGe,GACvB,OAAOf,EAGf,OAAQ,EASZ,SAASmI,EAAmB7C,EAAY1U,EAAGC,GAAEA,IACjC6K,EAA6B4J,EAA/B,IAAOhH,EAAwBgH,EAA1B,OAAU7J,EAAgB6J,EAAlB,KAAQ9G,EAAU8G,EAAZ,MACzB,OAAOzU,GAAK6K,GAAO7K,GAAKyN,GAAU1N,GAAK6K,GAAQ7K,GAAK4N,EAOxD,SAASwI,EAAqBjY,GAE1B,IAAMuW,EAAavW,EAAQsE,wBAK3B,MAAO,CACHqI,IAAK4J,EAAW5J,IAChB8C,MAAO8G,EAAW9G,MAClBF,OAAQgH,EAAWhH,OACnB7C,KAAM6J,EAAW7J,KACjBvI,MAAOoS,EAAWpS,MAClBC,OAAQmS,EAAWnS,QAS3B,SAAS8P,EAAwBxV,EAAMkb,GAC/Blb,IAASsZ,OACT,EAA4B6B,SAAS,EAAGD,GAIxC,EAA4BpG,WAAaoG,EASjD,SAASzF,EAA0BzV,EAAMkb,GACjClb,IAASsZ,OACT,EAA4B6B,SAASD,EAAQ,GAI7C,EAA4BnG,YAAcmG,EASlD,SAASrC,EAA2BhB,EAAY3B,GAASA,IAC7CjI,EAAwB4J,EAA1B,IAAOhH,EAAmBgH,EAArB,OAELkC,EA7tCyB,IA2tCClC,EAAb,OAGnB,OAAI3B,GAAYjI,EAAM8L,GAAc7D,GAAYjI,EAAM8L,EAC3C,EAEF7D,GAAYrF,EAASkJ,GAAc7D,GAAYrF,EAASkJ,EACtD,EAEJ,EAQX,SAAShB,EAA6BlB,EAAY5B,GAASA,IAC/CjI,EAAuB6J,EAAzB,KAAQ9G,EAAiB8G,EAAnB,MAENiC,EA/uCyB,IA6uCAjC,EAAZ,MAGnB,OAAI5B,GAAYjI,EAAO8L,GAAc7D,GAAYjI,EAAO8L,EAC7C,EAEF7D,GAAYlF,EAAQ+I,GAAc7D,GAAYlF,EAAQ+I,EACpD,EAEJ,EA2EX,IAaMsB,EA2TAC,EAxUAC,EAA8B,YAAgC,CAChE1Y,SAAQA,EACR2Y,SAAQA,I,IAWNH,E,WAKF,WAAYrY,EAAS1D,GAAUA,mCAC3BlH,KAAK4K,QAAUA,EAIf5K,KAAKqjB,eAAiB,IAAIvX,IAI1B9L,KAAKsjB,eAAiB,IAAIxX,IAI1B9L,KAAKujB,qBAAuB,IAAIzX,IAIhC9L,KAAKwjB,iBAAmB,IAAIC,IAK5BzjB,KAAKyT,YAAc,IAAIrI,EAAA,EAKvBpL,KAAK0T,UAAY,IAAItI,EAAA,EAIrBpL,KAAK2T,OAAS,IAAIvI,EAAA,EAKlBpL,KAAK0jB,6BAIJhX,YACO1M,EAAKujB,qBAAqBnE,MAC1B1S,EAAMS,kBAGdnN,KAAKkH,UAAYA,E,mEAOCyN,GACb3U,KAAKqjB,eAAetW,IAAI4H,IACzB3U,KAAKqjB,eAAetS,IAAI4D,K,uCAQfqH,GAAKA,WAClBhc,KAAKsjB,eAAevS,IAAIiL,GAIS,IAA7Bhc,KAAKsjB,eAAelE,MACpBpf,KAAK4K,QAAQmM,mBAAkB,WAM3B/W,EAAKkH,UAAUiJ,iBAAiB,YAAanQ,EAAK0jB,6BAA8BP,Q,0CASxExO,GAChB3U,KAAKqjB,eAAete,OAAO4P,K,qCAOhBqH,GACXhc,KAAKsjB,eAAeve,OAAOiX,GAC3Bhc,KAAKuR,aAAayK,GACe,IAA7Bhc,KAAKsjB,eAAelE,MACpBpf,KAAKkH,UAAUgQ,oBAAoB,YAAalX,KAAK0jB,6BAA8BP,K,oCAS7EnH,EAAMtP,GAAMA,WAEtB,IAAI1M,KAAKujB,qBAAqBxW,IAAIiP,KAGlChc,KAAKujB,qBAAqBxS,IAAIiL,GACS,IAAnChc,KAAKujB,qBAAqBnE,MAAY,CAEtC,IAAMvN,EAAenF,EAAM6G,KAAKoQ,WAAW,SAIrCC,EAAU/R,EAAe,WAAa,UAI5C7R,KAAKwjB,iBACAK,IAPahS,EAAe,YAAc,YAO3B,CAChBmF,QAIC8M,YAACA,OAAK9jB,EAAKyT,YAAYtR,KAAK,IAC7B4hB,QAASZ,IAERU,IAAID,EAAS,CACd5M,QAIC8M,YAACA,OAAK9jB,EAAK0T,UAAUvR,KAAK,IAC3B4hB,SAAQA,IAEPF,IAAI,SAAU,CACf7M,QAIC8M,YAACA,OAAK9jB,EAAK2T,OAAOxR,KAAK2hB,IAGxBC,SAAQA,IAMPF,IAAI,cAAe,CACpB7M,QAAShX,KAAK0jB,6BACdK,QAASZ,IAEbnjB,KAAK4K,QAAQmM,mBAAkB,WAI3B/W,EAAKwjB,iBAAiB5T,SAAQ,SAK7BoU,EAAQ3jB,GACLL,EAAKkH,UAAUiJ,iBAAiB9P,EAAM2jB,EAAOhN,QAASgN,EAAOD,kB,mCAUhE/H,GACThc,KAAKujB,qBAAqBxe,OAAOiX,GACM,IAAnChc,KAAKujB,qBAAqBnE,MAC1Bpf,KAAKikB,0B,iCAQFjI,GACP,OAAOhc,KAAKujB,qBAAqBxW,IAAIiP,K,oCAK5B,WACThc,KAAKsjB,eAAe1T,SAIpBsU,YAAQA,OAAIlkB,EAAK4Q,eAAesT,MAChClkB,KAAKqjB,eAAezT,SAIpBsU,YAAQA,OAAIlkB,EAAKyd,oBAAoByG,MACrClkB,KAAKikB,wBACLjkB,KAAKyT,YAAYrR,WACjBpC,KAAK0T,UAAUtR,a,8CAOI,WACnBpC,KAAKwjB,iBAAiB5T,SAAQ,SAK7BoU,EAAQ3jB,GACLL,EAAKkH,UAAUgQ,oBAAoB7W,EAAM2jB,EAAOhN,QAASgN,EAAOD,YAEpE/jB,KAAKwjB,iBAAiBxiB,Y,MAWMmjB,WAAQ,aAAmB,CAAEC,QAAS,WAAsC,OAAO,IAAInB,EAAiB,aAAS,KAAS,aAAS,OAAeoB,MAAOpB,EAAkBqB,WAAY,S,GAuErNC,EAAiB,CACnBxV,mBAAoB,EACpBkK,gCAAiC,G,IAK/BiK,E,WAOF,WAAYhc,EAAW0D,EAASC,EAAgBC,GAAkBA,wBAC9D9K,KAAKkH,UAAYA,EACjBlH,KAAK4K,QAAUA,EACf5K,KAAK6K,eAAiBA,EACtB7K,KAAK8K,kBAAoBA,E,wDASlB3B,GAAiCob,IAAxBP,EAAwBO,uDAAfA,EACzB,OAAO,IAAI,EAAQpb,EAAS6a,EAAQhkB,KAAKkH,UAAWlH,KAAK4K,QAAS5K,KAAK6K,eAAgB7K,KAAK8K,qB,qCAQjF3B,GACX,OAAO,IAAI,EAAYA,EAASnJ,KAAK8K,kBAAmB9K,KAAKkH,UAAWlH,KAAK4K,QAAS5K,KAAK6K,oB,MAavEsZ,WAAQ,aAAmB,CAAEC,QAAS,WAA8B,OAAO,IAAIlB,EAAS,aAAS,KAAW,aAAS,KAAS,aAAS,KAAgB,aAAS,KAAuBmB,MAAOnB,EAAUoB,WAAY,S,GAkP1OE,EAAkB,IAAI,IAAe,mBA6KrCC,EAAgB,IAAI,IAAe,iBAKnCC,GAAkB,IAAI,IAAe,kBAAmB,CAC1DJ,WAAY,OACZF,QAMJ,WACI,MAAO,CAAErV,mBAAoB,EAAGkK,gCAAiC,MAM/D,G,WAYF,WAAY9P,EAASwb,EAAezd,EAAW0D,EAASga,EAAmBZ,EAAQa,EAAMC,EAAUniB,GAAmBA,mCAClH3C,KAAKmJ,QAAUA,EACfnJ,KAAK2kB,cAAgBA,EACrB3kB,KAAKkH,UAAYA,EACjBlH,KAAK4K,QAAUA,EACf5K,KAAK4kB,kBAAoBA,EACzB5kB,KAAK6kB,KAAOA,EACZ7kB,KAAK2C,mBAAqBA,EAC1B3C,KAAK+kB,WAAa,IAAI3Z,EAAA,EAKtBpL,KAAKgM,eAAiB,EACtBhM,KAAKoD,aAILpD,KAAKkM,QAAU,IAAI,IAInBlM,KAAKmM,SAAW,IAAI,IAIpBnM,KAAKoM,MAAQ,IAAI,IAIjBpM,KAAKqM,QAAU,IAAI,IAInBrM,KAAKsM,OAAS,IAAI,IAIlBtM,KAAKuM,QAAU,IAAI,IAKnBvM,KAAKwM,MAAQ,IAAIyQ,EAAA,GAIhB+H,YAEG,IAAMC,EAAejlB,EAAKklB,SAAS1Y,MAAMoH,KAAK,OAAAtJ,EAAA,IAI9C6a,YAAUA,MAAI,CACVpc,OAAQ/I,EACRuO,gBAAiB4W,EAAW5W,gBAC5B7B,MAAOyY,EAAWzY,MAClBgC,MAAOyW,EAAWzW,MAClBF,SAAU2W,EAAW3W,cACnB7K,UAAUqhB,GAChB,OAAO,WAIHC,EAAaxhB,kBAGrBzD,KAAKklB,SAAWJ,EAASM,WAAWjc,EAAS6a,GAC7ChkB,KAAKklB,SAASlgB,KAAOhF,KAQjB2kB,GACA3kB,KAAKklB,SAASrG,mBAAmB8F,EAAcU,cAEnDrlB,KAAKslB,YAAYtlB,KAAKklB,UACtBllB,KAAKulB,cAAcvlB,KAAKklB,U,qEAuBxB,OAAOllB,KAAKklB,SAAS7G,0B,uCAOrB,OAAOre,KAAKklB,SAAS1G,mB,8BAOrBxe,KAAKklB,SAASM,U,4CAOd,OAAOxlB,KAAKklB,SAASO,wB,wCAKR,WAKbzlB,KAAK4K,QAAQ8a,SAASlf,eACjBoN,KAAK,OAAA+R,EAAA,GAAK,GAAI,OAAAxI,EAAA,GAAUnd,KAAK+kB,aAC7BphB,WAAU,WAIX3D,EAAK4lB,qBAEL5lB,EAAK4L,SAAS1J,QAAQ0R,KAAK,OAAAC,EAAA,GAAU7T,EAAK4L,UAE1C,OAAAia,EAAA,IAIClW,YAEG,IAAMmW,EAAsBnW,EACvB/H,QAILiF,YAAMA,OAAIA,EAAOkZ,cAAgB/lB,KAC5BsK,KAILuC,YAAMA,OAAIA,EAAO1D,WACjBnJ,EAAKklB,SAASc,YAAYF,MAG9B,OAAAG,EAAA,IAICtW,YAAOA,OACsB,OAAAuW,EAAA,mCAASvW,EAAQrF,KAI3CkK,YAAIA,OACOA,EAAK3S,cAAc+R,KAAK,OAAAC,EAAA,GAAUW,YAE5C,OAAA2I,EAAA,GAAUnd,EAAK+kB,aAAaphB,WAIjCwiB,YAGI,IAAMC,EAAUpmB,EAAKklB,SAEfrY,EAASsZ,EAAehd,QAAQzB,cACtCye,EAAeziB,SAAW0iB,EAAQC,cAAcxZ,GAAUuZ,EAAQE,aAAazZ,MAE/E7M,EAAKumB,kBACLvmB,EAAKklB,SAASzL,oBAAoBzZ,EAAKumB,uB,kCAQvCrkB,GAER,IAAMskB,EAAqBtkB,EAA6B,oBAElDukB,EAAiBvkB,EAA0B,iBAG7CskB,IAAuBA,EAAmBE,aAC1C1mB,KAAK4lB,qBAGLa,IAAmBA,EAAeC,aAAe1mB,KAAKumB,kBACtDvmB,KAAKklB,SAASzL,oBAAoBzZ,KAAKumB,oB,oCAO3CvmB,KAAK+kB,WAAW5iB,OAChBnC,KAAK+kB,WAAW3iB,WAChBpC,KAAKklB,SAASyB,Y,2CASd,IAAMxd,EAAUnJ,KAAKmJ,QAAQzB,cAEvBuI,EAAcjQ,KAAK4mB,oBACrBC,GAA2B1d,EAASnJ,KAAK4mB,qBAAuBzd,EACpE,GAAI8G,GAAeA,EAAYjI,WAAahI,KAAKkH,UAAU6T,aACvD,MAAM1S,MAAM,iFACkB4H,EAAY6W,SAD9B,OAGhB9mB,KAAKklB,SAAS1V,gBAAgBS,GAAe9G,K,4CAS7C,IAAM4d,EAAW/mB,KAAKqQ,gBACtB,IAAK0W,EACD,OAAO,KAEX,GAAwB,iBAAbA,EACP,OAAOF,GAA2B7mB,KAAKmJ,QAAQzB,cAAeqf,GAGlE,IAAM5d,EAAU,YAAc4d,GAC9B,GAAI,gBAAgB5d,EAAQpB,SAAS/H,KAAKmJ,QAAQzB,eAC9C,MAAMW,MAAM,4EAEhB,OAAOc,I,kCAQC6d,GAAIA,WACZA,EAAI/a,cAActI,WAAU,WAIxB,IAAKqjB,EAAI3X,aAAc,CAEnB,IAAM4X,EAAMjnB,EAAK6kB,KAEX7Y,EAAiBhM,EAAKgM,eAEtBkG,EAAclS,EAAKgQ,qBAAuB,CAC5CF,SAAU9P,EAAKgQ,qBAAqBkX,YACpCzR,QAASzV,EAAKgQ,qBAAqBhL,KACnCuQ,cAAevV,EAAK4kB,mBACpB,KAEE5S,EAAUhS,EAAK+P,iBAAmB,CACpCD,SAAU9P,EAAK+P,iBAAiBmX,YAChCzR,QAASzV,EAAK+P,iBAAiB/K,KAC/BuQ,cAAevV,EAAK4kB,mBACpB,KACJoC,EAAItjB,SAAW1D,EAAK0D,SACpBsjB,EAAI7O,SAAWnY,EAAKmY,SACpB6O,EAAIhb,eAA4C,iBAAnBA,GAA+BA,EACxDA,EAAiB,YAAqBA,GAC1Cgb,EAAI/O,kBAAoBjY,EAAKiY,kBAC7B+O,EAAI5R,aAAepV,EAAKoV,aACxB4R,EACKG,oBAAoBnnB,EAAKonB,uBACzBC,wBAAwBnV,GACxBoV,oBAAoBtV,GACrBiV,GACAD,EAAIO,cAAcN,EAAI3mB,a,oCAWxB0mB,GAAIA,WACdA,EAAI9a,QAAQvI,WAAU,WAIlB3D,EAAKkM,QAAQtL,KAAK,CAAEmI,OAAQ/I,IAG5BA,EAAK2C,mBAAmBkB,kBAE5BmjB,EAAI7a,SAASxI,WAAU,WAInB3D,EAAKmM,SAASvL,KAAK,CAAEmI,OAAQ/I,OAEjCgnB,EAAI5a,MAAMzI,WAIV+I,YACI1M,EAAKoM,MAAMxL,KAAK,CAAEmI,OAAQ/I,EAAMwO,SAAU9B,EAAM8B,WAGhDxO,EAAK2C,mBAAmBkB,kBAE5BmjB,EAAI3a,QAAQ1I,WAIZ+I,YACI1M,EAAKqM,QAAQzL,KAAK,CACdqQ,UAAWvE,EAAMuE,UAAUjM,KAC3BwP,KAAMxU,EACNoU,aAAc1H,EAAM0H,kBAG5B4S,EAAI1a,OAAO3I,WAIX+I,YACI1M,EAAKsM,OAAO1L,KAAK,CACbqQ,UAAWvE,EAAMuE,UAAUjM,KAC3BwP,KAAMxU,OAGdgnB,EAAIza,QAAQ5I,WAIZ+I,YACI1M,EAAKuM,QAAQ3L,KAAK,CACd6T,cAAe/H,EAAM+H,cACrBL,aAAc1H,EAAM0H,aACpBM,kBAAmBhI,EAAMgI,kBAAkB1P,KAC3CiM,UAAWvE,EAAMuE,UAAUjM,KAC3BsP,uBAAwB5H,EAAM4H,uBAC9BE,KAAMxU,EACNwO,SAAU9B,EAAM8B,gB,+BAxRxB,OAAOxO,KAAKoD,WAAcpD,KAAK2kB,eAAiB3kB,KAAK2kB,cAAcjhB,U,aAM1DpD,GACTN,KAAKoD,UAAY,SAAAb,EAAA,CAAsBjC,GACvCN,KAAKklB,SAASxhB,SAAW1D,KAAKoD,c,KAmetC,SAASyjB,GAA2B1d,EAASqe,GAGzC,IADA,IAAIC,EAAoCte,EAAsB,cACvDse,GAAgB,CAEnB,GAAIA,EAAeC,QAAUD,EAAeC,QAAQF,GAChD,EAAsCG,kBAAkBH,GACxD,OAAOC,EAEXA,EAAiBA,EAAeG,cAEpC,OAAO,K,IAwFLC,GAzEA,G,WACF,aAAa,wBAIT7nB,KAAK8nB,OAAS,IAAIhc,IAClB9L,KAAKoD,a,2DAkBLpD,KAAK8nB,OAAO9mB,U,+BAZC,OAAOhB,KAAKoD,W,aAKhB9C,GACTN,KAAKoD,UAAY,SAAAb,EAAA,CAAsBjC,O,KA0C3CynB,GAAmB,E,KAajBF,G,WAQF,WAAY1e,EAAS2b,EAAUniB,EAAoBkiB,EAAMmD,GAAOA,mCAC5DhoB,KAAKmJ,QAAUA,EACfnJ,KAAK2C,mBAAqBA,EAC1B3C,KAAK6kB,KAAOA,EACZ7kB,KAAKgoB,OAASA,EAIdhoB,KAAK+kB,WAAa,IAAI3Z,EAAA,EAMtBpL,KAAK8e,YAAc,GAInB9e,KAAKgf,YAAc,WAKnBhf,KAAK+B,GAAL/B,wBAA2B+nB,MAC3B/nB,KAAKoD,aAILpD,KAAKwb,mBAKLxb,KAAK0b,eAAiB,qBAOtB1b,KAAKyb,sBAILzb,KAAKuM,QAAU,IAAI,IAInBvM,KAAKqM,QAAU,IAAI,IAKnBrM,KAAKsM,OAAS,IAAI,IAIlBtM,KAAK2b,OAAS,IAAI,IAClB3b,KAAKqlB,aAAeP,EAASmD,eAAe9e,GAC5CnJ,KAAKqlB,aAAargB,KAAOhF,KACzBA,KAAKqlB,aAAa3J,eAAiB,SAKlCM,EAAMrH,GAL4B,OAMxB3U,EAAK0b,eAAeM,EAAKhX,KAAM2P,EAAK3P,OAE/ChF,KAAKkoB,4BAA4BloB,KAAKqlB,cACtCrlB,KAAKulB,cAAcvlB,KAAKqlB,cACxBwC,EAAYM,WAAW1J,KAAKze,MACxBgoB,GACAA,EAAOF,OAAO/W,IAAI/Q,M,kEAwBN,WAChBA,KAAKie,YAAY/b,QACZ0R,KAAK,OAAAC,EAAA,GAAU7T,KAAKie,aAAc,OAAAd,EAAA,GAAUnd,KAAK+kB,aACjDphB,WAIJib,YACG5e,EAAKqlB,aAAa+C,UAAUxJ,EAAMyJ,QAAO,SAKxCC,EAAetM,GALyB,OAMjCA,EAAK2I,gBAAkB3kB,GACvBsoB,EAAc7J,KAAKzC,EAAKkJ,UAErBoD,IACP,U,oCAQR,IAAMrI,EAAQ4H,EAAYM,WAAWne,QAAQhK,MACzCigB,GAAS,GACT4H,EAAYM,WAAW5J,OAAO0B,EAAO,GAErCjgB,KAAKgoB,QACLhoB,KAAKgoB,OAAOF,OAAO/iB,OAAO/E,MAE9BA,KAAKqlB,aAAasB,UAClB3mB,KAAK+kB,WAAW5iB,OAChBnC,KAAK+kB,WAAW3iB,a,8BAShBpC,KAAKqlB,aAAatS,U,2BAcjByB,EAAMJ,EAAcM,EAAmBJ,GACxCtU,KAAKqlB,aAAa1Q,KAAKH,EAAK0Q,SAAU9Q,EAAcM,EAAkB2Q,aAAc/Q,EAAwB,CAAEtJ,EAAG,EAAGC,EAAG,M,4BAWrHuJ,EAAMsJ,EAAUC,GAClB/d,KAAKqlB,aAAatQ,MAAMP,EAAK0Q,SAAUpH,EAAUC,K,2BAShDvJ,GACDxU,KAAKqlB,aAAavQ,KAAKN,EAAK0Q,Y,mCASnB1Q,GACT,OAAOxU,KAAKqlB,aAAahR,aAAaG,EAAK0Q,Y,kDAQnB8B,GAAIA,WACxBhnB,KAAK6kB,MACL7kB,KAAK6kB,KAAKvU,OACLsD,KAAK,OAAAC,EAAA,GAAU7T,KAAK6kB,KAAKvkB,OAAQ,OAAA6c,EAAA,GAAUnd,KAAK+kB,aAChDphB,WAILrD,YAAKA,OAAI0mB,EAAIO,cAAcjnB,MAE/B0mB,EAAI/a,cAActI,WAAU,WAKxB,IAAM4b,EAAW,YAAYvf,EAAK8e,aAAaxU,KAI/CqK,YAAIA,MACuB,iBAATA,EACSkT,EAAYM,WAAWvb,MAI1C2b,YAAIA,OAAIA,EAAKxmB,KAAO4S,KAAWA,KAEnC3U,EAAKgoB,QACLhoB,EAAKgoB,OAAOF,OAAOlY,SAInB+E,aACoC,IAA5B4K,EAASvV,QAAQ2K,IACjB4K,EAASd,KAAK9J,MAI1BqS,EAAItjB,SAAW1D,EAAK0D,SACpBsjB,EAAI7O,SAAWnY,EAAKmY,SACpB6O,EAAIxL,gBAAkB,SAAAjZ,EAAA,CAAsBvC,EAAKwb,iBACjDwL,EAAIvL,mBAAqB,SAAAlZ,EAAA,CAAsBvC,EAAKyb,oBACpDuL,EACKlI,YAAYS,EAAS3X,QAI1B+M,YAAIA,OAAIA,GAAQA,IAAS3U,KAAOsK,KAIhCie,YAAIA,OAAIA,EAAKlD,iBACRmD,gBAAgBxoB,EAAKgf,kB,oCASpBgI,GAAIA,WACdA,EAAI/a,cAActI,WAAU,WAIxB3D,EAAK2C,mBAAmBkB,kBAE5BmjB,EAAI3a,QAAQ1I,WAIZ+I,YACI1M,EAAKqM,QAAQzL,KAAK,CACdqQ,UAAWjR,EACXwU,KAAM9H,EAAM8H,KAAKxP,KACjBoP,aAAc1H,EAAM0H,kBAG5B4S,EAAI1a,OAAO3I,WAIX+I,YACI1M,EAAKsM,OAAO1L,KAAK,CACbqQ,UAAWjR,EACXwU,KAAM9H,EAAM8H,KAAKxP,OAErBhF,EAAK2C,mBAAmBkB,kBAE5BmjB,EAAIrL,OAAOhY,WAIX+I,YACI1M,EAAK2b,OAAO/a,KAAK,CACb6T,cAAe/H,EAAM+H,cACrBL,aAAc1H,EAAM0H,aACpBnD,UAAWjR,EACXwU,KAAM9H,EAAM8H,KAAKxP,UAGzBgiB,EAAIza,QAAQ5I,WAIZ+I,YACI1M,EAAKuM,QAAQ3L,KAAK,CACd6T,cAAe/H,EAAM+H,cACrBL,aAAc1H,EAAM0H,aACpBM,kBAAmBhI,EAAMgI,kBAAkB1P,KAC3CiM,UAAWvE,EAAMuE,UAAUjM,KAC3BwP,KAAM9H,EAAM8H,KAAKxP,KACjBsP,uBAAwB5H,EAAM4H,uBAC9B9F,SAAU9B,EAAM8B,WAIpBxO,EAAK2C,mBAAmBkB,oB,+BAzO5B,OAAO7D,KAAKoD,aAAgBpD,KAAKgoB,QAAUhoB,KAAKgoB,OAAOtkB,U,aAM9CpD,GAKTN,KAAKqlB,aAAa3hB,SAAW1D,KAAKoD,UAAY,SAAAb,EAAA,CAAsBjC,O,MAqOhE6nB,WAAa,G,IAyKnBM,G,2ECjnKN,kC,IAAaC,E,yEC5Bb,oaAwDA,IAAMC,EAAgB,IAAI,IAAe,iBAiHrCC,EAAW,EA6BTC,EAAsC,IAAI,IAAe,uCAQzDC,E,YAUF,WAAYpmB,EAAWC,EAAoBomB,EAA4BnE,EAAmB1d,EAAW8hB,EAAgBC,GAAeA,sCAChIhiB,+DAAMvE,EAAWC,EAAoBomB,KAChCnE,kBAAoBA,EACzB5kB,EAAKgpB,eAAiBA,EACtBhpB,EAAKkpB,eAILlpB,EAAKmpB,YAAc,IAAI,IAIvBnpB,EAAKopB,cAAgB,IAAI,IAIzBppB,EAAKqpB,cAAgB,IAAI,IAIzBrpB,EAAKspB,UAALtpB,qCAA+C4oB,KAI/C5oB,EAAKupB,mBAAqB,IAAI,IAC9BvpB,EAAK0C,UAAYA,EACjB1C,EAAKkH,UAAYA,EAGjBlH,EAAKupB,mBAAmB3V,KAAK,aAAqB,SAKjD5I,EAAGC,GAL8C,OAMvCD,EAAEwe,YAAcve,EAAEue,WAAaxe,EAAEye,UAAYxe,EAAEwe,YACrD9lB,WAIL+I,YAC4B,SAApBA,EAAM8c,YACgB,aAAlB9c,EAAM+c,QACNzpB,EAAKmpB,YAAYvoB,OAEM,cAAlB8L,EAAM+c,SACXzpB,EAAKopB,cAAcxoB,WAI3BqoB,IACAjpB,EAAK0pB,WAAaT,EAAeS,YAnD2FT,E,0EAuFhI,QAAIjpB,KAAK0C,WACE1C,KAAKqC,UAA2C,YAA/BrC,KAAK0C,UAAUinB,c,0CAS3C,OAAO3pB,KAAKqC,SAAW,WAAa,c,+BAOpCrC,KAAKqC,UAAYrC,KAAKqC,W,8BAOtBrC,KAAKqC,c,6BAOLrC,KAAKqC,c,2CAKW,WACZrC,KAAK4pB,cAEL5pB,KAAKgD,OAAO4Q,KAAK,YAAU,MAA4B,aAAO,kBAGxD5T,EAAKqC,WAAarC,EAAK6pB,WAAW,YAAK,IAAIlmB,WAAU,WAIvD3D,EAAK6pB,QAAU,IAAI,IAAe7pB,EAAK4pB,aAAaE,UAAW9pB,EAAK4kB,wB,kCAQpE1iB,GACRlC,KAAKqpB,cAAclnB,KAAKD,K,oCAMxB+E,iEACAjH,KAAKupB,mBAAmBnnB,WACxBpC,KAAKqpB,cAAcjnB,a,uCAOnB,GAAIpC,KAAK+pB,MAAO,CAEZ,IAAMC,EAAiBhqB,KAAKkH,UAAU+iB,cAEhCC,EAAclqB,KAAK+pB,MAAMriB,cAC/B,OAAOsiB,IAAmBE,GAAeA,EAAYniB,SAASiiB,GAElE,OAAM,I,iCAzGN,OAAOhqB,KAAKkpB,aAAgBlpB,KAAK0C,WAAa1C,KAAK0C,UAAUgnB,Y,aAMlDppB,GACXN,KAAKkpB,YAAc,SAAA3mB,EAAA,CAAsBjC,K,qCAOzC,OAAON,KAAKmqB,iBAAoBnqB,KAAK0C,WAAa1C,KAAK0C,UAAU0nB,gB,aAMlD9pB,GACfN,KAAKmqB,gBAAkB7pB,M,GA1FC,KA2T1B+pB,E,WAQF,WAAYC,EAAOC,EAAUC,EAAe7nB,EAAoBsmB,GAAeA,mCAC3EjpB,KAAKsqB,MAAQA,EACbtqB,KAAKuqB,SAAWA,EAChBvqB,KAAKwqB,cAAgBA,EACrBxqB,KAAK2C,mBAAqBA,EAC1B3C,KAAKyqB,0BAA4B,IAAa3nB,MAI9C9C,KAAK0qB,uBAEL,IAAMC,EAA4BL,EAAM5nB,UACpC4nB,EAAM5nB,UAAUb,cAAc+R,KAAK,aAInC1R,YAAOA,SAAOA,EAAoB,aAAKA,EAAwB,oBAC/D,IAGJlC,KAAKyqB,0BACD,YAAMH,EAAMtnB,OAAQsnB,EAAMvnB,OAAQ4nB,EAA2BL,EAAMjB,cAAczV,KAAK,aAItF1R,YAAOA,SACOA,EAAoB,YAC1BA,EAAkB,UAClBA,EAAwB,qBAE3ByB,WAAU,kBAGT3D,EAAK2C,mBAAmBkB,kBAElCymB,EAAMvnB,OACD6Q,KAAK,aAAO,kBAGX0W,EAAMM,qBACPjnB,WAAU,kBAGT6mB,EAAcK,SAASN,EAAU,cACvCC,EAAcM,QAAQP,GAAU5mB,WAIhConB,YACQA,GAAUT,EAAM5nB,WAChB4nB,EAAM5nB,UAAUsoB,mBAAmBhrB,MAGvCipB,IACAjpB,KAAKirB,eAAiBhC,EAAegC,eACrCjrB,KAAKkrB,gBAAkBjC,EAAeiC,iB,iEAe1ClrB,KAAK0qB,yB,gCAeA1qB,KAAK0D,UACN1D,KAAKsqB,MAAMa,W,oCAQf,OAAOnrB,KAAKsqB,MAAMjoB,W,0CAOlB,OAAOrC,KAAKsqB,MAAMc,sB,oCAOlB,OAAOprB,KAAKsqB,MAAMvoB,K,2CAOlB,OAAO/B,KAAKsqB,MAAMF,iB,oCAOlB,OAAQpqB,KAAKsqB,MAAMZ,aAAe1pB,KAAKsqB,MAAM5mB,W,+BAOxCgJ,GACL,OAAQA,EAAM2e,SAEV,KAAK,IACL,KAAK,IACI,YAAe3e,KAChBA,EAAMS,iBACNnN,KAAKsrB,WAET,MACJ,QAII,YAHItrB,KAAKsqB,MAAM5nB,WACX1C,KAAKsqB,MAAM5nB,UAAU6oB,qBAAqB7e,O,8BAYxBqX,IAA5BgH,EAA4BhH,uDAAnB,UAAWA,EAAQA,uCAC9B/jB,KAAKwqB,cAAcK,SAAS7qB,KAAKuqB,SAAUQ,EAAQhH,K,oCAMnD/jB,KAAKyqB,0BAA0BhnB,cAC/BzD,KAAKwqB,cAAcgB,eAAexrB,KAAKuqB,Y,+BAnFvC,OAAOvqB,KAAKsqB,MAAM5mB,a,KAiMpB+nB,E,sCAmBAC,E,YACF,aAAa,sCACTzkB,gEAAS0kB,aAIJC,YAAc,IAAI,IACvB5rB,EAAKkpB,eASLlpB,EAAK2pB,YAAc,UAInB3pB,EAAKoqB,eAAiB,QAnBb,E,iFAkCO,WAChBpqB,KAAK6rB,SAAS3pB,QACT0R,KAAK,YAAU5T,KAAK6rB,WACpBloB,WAIJmoB,YACG9rB,EAAK4rB,YAAYpG,MAAMsG,EAAQlkB,QAI/BmkB,YAAMA,OAAIA,EAAOzB,MAAM5nB,YAAc1C,MACrCA,EAAK4rB,YAAYI,qBAErBhsB,KAAKisB,YAAc,IAAI,IAAgBjsB,KAAK4rB,aAAaM,a,2CAOxCxf,GACZ,IAAG2e,EAAY3e,EAAd,QAEAyf,EAAUnsB,KAAKisB,YACjBZ,IAAY,IACP,YAAe3e,KAChByf,EAAQC,qBACR1f,EAAMS,kBAGLke,IAAY,IACZ,YAAe3e,KAChByf,EAAQE,oBACR3f,EAAMS,kBAIVnN,KAAKisB,YAAYK,UAAU5f,K,yCAOhBqf,GACf/rB,KAAKisB,YAAYM,iBAAiBR,K,iCAxDnB,OAAO/rB,KAAKkpB,a,aAKhBsD,GAAQxsB,KAAKkpB,YAAc,SAAA3mB,EAAA,CAAsBiqB,O,GA/BzC,KA0JrBC,E,yEC78BN,wkBA0RMC,EAAiB,IAAI,IAAe,kBAyEpCC,E,YAOF,WAAYllB,EAAaT,EAAUwjB,EAAeoC,GAAYA,sCAE1D3lB,kEACKQ,YAAcA,EACnBzH,EAAKwqB,cAAgBA,EACrBxqB,EAAK4sB,YAAcA,EAInB5sB,EAAK6sB,KAAO,WAIZ7sB,EAAK8sB,SAAW,IAAI,IAIpB9sB,EAAK+sB,SAAW,IAAI,IAIpB/sB,EAAKgtB,gBAILhtB,EAAKitB,oBACDzC,GAIAA,EAAcM,QAAQ9qB,EAAKyH,aAAYA,GAEvCmlB,GAAeA,EAAYM,SAC3BN,EAAYM,QAAZN,2BAEJ5sB,EAAKkH,UAAYF,EAnCyC4lB,E,oEA2C5B7I,IAA5BgH,EAA4BhH,uDAAnB,UAAWA,EAAQA,uCAC1B/jB,KAAKwqB,cACLxqB,KAAKwqB,cAAcK,SAAS7qB,KAAKmtB,kBAAmBpC,EAAQhH,GAG5D/jB,KAAKmtB,kBAAkBC,MAAMrJ,GAEjC/jB,KAAK+sB,SAAS5qB,KAAKnC,Q,oCAMfA,KAAKwqB,eACLxqB,KAAKwqB,cAAcgB,eAAexrB,KAAKyH,aAEvCzH,KAAK4sB,aAAe5sB,KAAK4sB,YAAYS,YACrCrtB,KAAK4sB,YAAYS,WAAWrtB,MAEhCA,KAAK8sB,SAAS1qB,WACdpC,KAAK+sB,SAAS3qB,a,qCAOd,OAAOpC,KAAK0D,SAAW,KAAO,M,wCAO9B,OAAO1D,KAAKyH,YAAYC,gB,qCAYbgF,GACP1M,KAAK0D,WACLgJ,EAAMS,iBACNT,EAAMuG,qB,0CAaVjT,KAAK8sB,SAAS3qB,KAAKnC,Q,iCAQnB,IAAMmJ,EAAUnJ,KAAKyH,YAAYC,cAE3B4lB,EAAettB,KAAKkH,UAAYlH,KAAKkH,UAAUqmB,UAAY,EAE7DC,EAAS,GACb,GAAIrkB,EAAQxB,WAMR,IAJA,IAAML,EAAS6B,EAAQxB,WAAWL,OAIzB8S,EAAI,EAAGA,EAAI9S,EAAQ8S,IACpBjR,EAAQxB,WAAWyS,GAAGpS,WAAaslB,IACnCE,GAAUrkB,EAAQxB,WAAWyS,GAAGjS,aAI5C,OAAOqlB,EAAOplB,W,GA9IQ,YAAmB,a,0CA0Q3CqlB,EAA2B,IAAI,IAAe,2BAA4B,CAC5EnJ,WAAY,OACZF,QAMJ,WACI,MAAO,CACHsJ,gBAAeA,EACfC,UAAW,QACXC,UAAW,QACXC,cAAe,uCAUnBC,EAAe,EAonBbC,E,sKAzmBF,WAAYtmB,EAAamD,EAASojB,GAAgBA,wBAC9ChuB,KAAKyH,YAAcA,EACnBzH,KAAK4K,QAAUA,EACf5K,KAAKguB,gBAAkBA,EACvBhuB,KAAKiuB,WAAajuB,KAAKguB,gBAAgBL,UACvC3tB,KAAKkuB,WAAaluB,KAAKguB,gBAAgBJ,UAIvC5tB,KAAKmuB,uBAAyB,IAAI,IAIlCnuB,KAAKouB,iBAAmB,IAAatrB,MAIrC9C,KAAKquB,WAAa,GAIlBruB,KAAKsuB,qBAAuB,OAI5BtuB,KAAKuuB,eAAiB,IAAI,IAI1BvuB,KAAK6tB,cAAgB7tB,KAAKguB,gBAAgBH,cAC1C7tB,KAAKwuB,gBAAkBxuB,KAAKguB,gBAAgBN,eAC5C1tB,KAAKyuB,aAAezuB,KAAKguB,gBAAgBU,YAIzC1uB,KAAK+C,OAAS,IAAI,IAMlB/C,KAAKwB,MAAQxB,KAAK+C,OAClB/C,KAAK2uB,QAAL3uB,yBAAiC8tB,K,wDA2GjC9tB,KAAK4uB,uB,2CAKW,WAChB5uB,KAAK6uB,2BACL7uB,KAAKisB,YAAc,IAAI,IAAgBjsB,KAAKmuB,wBAAwBjC,WAAW4C,gBAC/E9uB,KAAKouB,iBAAmBpuB,KAAKisB,YAAY8C,OAAOprB,WAAU,kBAGpD3D,EAAK+C,OAAOnC,KAAK,UAIvBZ,KAAKmuB,uBAAuBjsB,QAAQ0R,KAAK,YAAU5T,KAAKmuB,wBAAyB,aAIjFvP,YAAKA,OAAI,4CAASA,EAAMtU,KAIvBkK,YAAIA,OAAKA,EAAKuY,kBAAeppB,WAI9BqrB,YAAWA,OAAIhvB,EAAKisB,YAAYM,iBAAiByC,Q,oCAMjDhvB,KAAKmuB,uBAAuB9c,UAC5BrR,KAAKouB,iBAAiB3qB,cACtBzD,KAAK+C,OAAOX,a,iCAUZ,OADuCpC,KAAKmuB,uBAA+B,QACrCva,KAAK,YAAU5T,KAAKmuB,wBAAyB,aAInFvP,YAAKA,OAAI,4CAASA,EAAMtU,KAIvBkK,YAAIA,OAAKA,EAAKsY,oB,8BAYXmC,M,iCASGA,M,qCAMIviB,GAEX,IAAM2e,EAAU3e,EAAM2e,QAEhBc,EAAUnsB,KAAKisB,YACrB,OAAQZ,GACJ,KAAK,IACI,YAAe3e,KAChBA,EAAMS,iBACNnN,KAAK+C,OAAOnC,KAAK,YAErB,MACJ,KAAK,IACGZ,KAAKkvB,YAAiC,QAAnBlvB,KAAKgR,WACxBhR,KAAK+C,OAAOnC,KAAK,WAErB,MACJ,KAAK,IACGZ,KAAKkvB,YAAiC,QAAnBlvB,KAAKgR,WACxBhR,KAAK+C,OAAOnC,KAAK,WAErB,MACJ,KAAK,IACL,KAAK,IACI,YAAe8L,KAChB2e,IAAY,IAAOc,EAAQC,qBAAuBD,EAAQE,oBAC1D3f,EAAMS,kBAEV,MACJ,QACQke,IAAY,KAAYA,IAAY,KACpCc,EAAQgD,eAAe,YAE3BhD,EAAQG,UAAU5f,M,uCAQN,WAATqe,EAAS,iEAEhB/qB,KAAKovB,YACLpvB,KAAK4K,QAAQ8a,SAASlf,eACjBoN,KAAK,YAAK,IACVjQ,WAAU,kBAGT3D,EAAKqvB,gBAAgBtE,MAG3B/qB,KAAKqvB,gBAAgBtE,K,sCAUbA,GAEZ,IAAMoB,EAAUnsB,KAAKisB,YAKrB,GAJAE,EAAQgD,eAAepE,GAAQqB,sBAI1BD,EAAQmD,YAActvB,KAAKmuB,uBAAuB7mB,OAOnD,IALA,IAAI6B,EAAUnJ,KAAKmuB,uBAAuBoB,MAAMpC,kBAAkBvF,cAK3Dze,GAAS,CACZ,GAAqC,SAAjCA,EAAQqmB,aAAa,QAAoB,CACzCrmB,EAAQikB,QACR,MAGAjkB,EAAUA,EAAQye,iB,wCAW9B5nB,KAAKisB,YAAYwD,eAAe,K,mCAOvBC,GAIT,IAEMC,EAAYA,yBAFA9gB,KAAK4L,IA1VC,EA0V6BiV,EAAO,KAItDE,EAAkBC,OAAOC,KAAK9vB,KAAKquB,YAAYzhB,MAIrDrK,YAACA,OAAIA,EAAEohB,WAAW,sBACbiM,GAAmBA,IAAoB5vB,KAAK+vB,qBACzC/vB,KAAK+vB,qBACL/vB,KAAKquB,WAAWruB,KAAK+vB,wBAEzB/vB,KAAKquB,WAAWsB,MAChB3vB,KAAK+vB,mBAAqBJ,K,2CAW8B/B,IAA7CoC,EAA6CpC,uDAAtC5tB,KAAK2tB,UAAWsC,EAAsBrC,uDAAf5tB,KAAK4tB,UAE5CsC,EAAUlwB,KAAKquB,WACrB6B,EAAQ,mBAA8B,WAATF,EAC7BE,EAAQ,kBAA6B,UAATF,EAC5BE,EAAQ,kBAA6B,UAATD,EAC5BC,EAAQ,kBAA6B,UAATD,I,wCAQ5BjwB,KAAKsuB,qBAAuB,U,wCAQ5BtuB,KAAKsuB,qBAAuB,S,uCAOf5hB,GACb1M,KAAKuuB,eAAepsB,KAAKuK,GACzB1M,KAAKmwB,kB,wCAMSzjB,GACd1M,KAAKmwB,gBAOiB,UAAlBzjB,EAAM+c,SAA4D,IAArCzpB,KAAKisB,YAAYmE,kBAC9C1jB,EAAMvD,QAAQwT,UAAY,K,iDAWR,WACtB3c,KAAKqwB,UAAUnuB,QACV0R,KAAK,YAAU5T,KAAKqwB,YACpB1sB,WAIJib,YACG5e,EAAKmuB,uBAAuB3I,MAAM5G,EAAMhX,QAIxC4M,YAAIA,OAAIA,EAAKoY,cAAgB5sB,MAC7BA,EAAKmuB,uBAAuBnC,uB,gCA5XlB,OAAOhsB,KAAKiuB,Y,aAKhB3tB,GACI,WAAVA,GAAgC,UAAVA,GA/blC,WACI,MAAM+H,MAAM,kIADhB,GAkcQrI,KAAKiuB,WAAa3tB,EAClBN,KAAK4uB,uB,gCAMS,OAAO5uB,KAAKkuB,Y,aAKhB5tB,GACI,UAAVA,GAA+B,UAAVA,GArcjC,WACI,MAAM+H,MAAM,gIADhB,GAwcQrI,KAAKkuB,WAAa5tB,EAClBN,KAAK4uB,uB,qCAMc,OAAO5uB,KAAKwuB,iB,aAKhBluB,GACfN,KAAKwuB,gBAAkB,SAAAjsB,EAAA,CAAsBjC,K,kCAM7B,OAAON,KAAKyuB,c,aAKhBnuB,GACZN,KAAKyuB,aAAe,SAAAlsB,EAAA,CAAsBjC,K,+BAS/B4vB,GAAQA,WAEbI,EAAqBtwB,KAAKuwB,oBAC5BD,GAAsBA,EAAmBhpB,QACzCgpB,EAAmBjmB,MAAM,KAAKuF,SAI7BuG,YACGnW,EAAKquB,WAAWlY,SAGxBnW,KAAKuwB,oBAAsBL,EACvBA,GAAWA,EAAQ5oB,SACnB4oB,EAAQ7lB,MAAM,KAAKuF,SAIlBuG,YACGnW,EAAKquB,WAAWlY,SAEpBnW,KAAKyH,YAAYC,cAAcyO,UAAY,M,gCAWjC,OAAOnW,KAAKwwB,Y,aAKhBN,GAAWlwB,KAAKwwB,WAAaN,M,MA4ezCO,E,YAMF,WAAY3pB,EAAY4pB,EAAQzH,GAAeA,4FACrCniB,EAAY4pB,EAAQzH,I,yBAPX8E,GA4CjB4C,EAA2B,IAAI,IAAe,4BAMpD,SAASC,EAAiCC,GACtC,OAAO,kBAGDA,EAAQC,iBAAiBC,cAMnC,IAcMvmB,EAA8B,YAAgC,CAAEC,SAAQA,IAMxEumB,E,WAWF,WAAYC,EAAU1G,EAAU3F,EAAmBsM,EAAgBtE,EAAauE,EAAmBtM,EAAM2F,GAAcA,mCACnHxqB,KAAKixB,SAAWA,EAChBjxB,KAAKuqB,SAAWA,EAChBvqB,KAAK4kB,kBAAoBA,EACzB5kB,KAAK4sB,YAAcA,EACnB5sB,KAAKmxB,kBAAoBA,EACzBnxB,KAAK6kB,KAAOA,EACZ7kB,KAAKwqB,cAAgBA,EACrBxqB,KAAKoxB,YAAc,KACnBpxB,KAAKqxB,aACLrxB,KAAKsxB,4BAA8B,IAAaxuB,MAChD9C,KAAKuxB,mBAAqB,IAAazuB,MACvC9C,KAAKwxB,uBAAyB,IAAa1uB,MAK3C9C,KAAKyxB,kBAAoB,kBAGnBzxB,EAAK0xB,UAAY,SAGvB1xB,KAAK0xB,UAAY,KAMjB1xB,KAAK2xB,gBAIL3xB,KAAK4xB,WAAa,IAAI,IAOtB5xB,KAAK6xB,WAAa7xB,KAAK4xB,WAIvB5xB,KAAK8xB,WAAa,IAAI,IAOtB9xB,KAAK+xB,YAAc/xB,KAAK8xB,WACxBvH,EAAS7iB,cAAcyI,iBAAiB,aAAcnQ,KAAKyxB,kBAAmBjnB,GAC1E2mB,IACAA,EAAkBlE,iBAAmBjtB,KAAKgyB,mBAE9ChyB,KAAKiyB,gBAAkBf,E,kEAgDvBlxB,KAAKkyB,aACLlyB,KAAKmyB,iB,oCAMDnyB,KAAKoxB,cACLpxB,KAAKoxB,YAAYzK,UACjB3mB,KAAKoxB,YAAc,MAEvBpxB,KAAKuqB,SAAS7iB,cAAcwP,oBAAoB,aAAclX,KAAKyxB,kBAAmBjnB,GACtFxK,KAAKwxB,uBAAuB/tB,cAC5BzD,KAAKsxB,4BAA4B7tB,cACjCzD,KAAKuxB,mBAAmB9tB,gB,wCAqBxB,SAAUzD,KAAKmxB,oBAAqBnxB,KAAK4sB,e,mCAOzC,OAAO5sB,KAAKqxB,UAAYrxB,KAAKoyB,YAAcpyB,KAAKF,a,iCAM1C,WACN,IAAIE,KAAKqxB,UAAT,CAGArxB,KAAKkyB,aAEL,IAAMG,EAAaryB,KAAKsyB,iBAElBC,EAAgBF,EAAWG,YACjCxyB,KAAKyyB,aAAgCF,EAA+B,kBACpEA,EAAc7D,YAAuC,MAAzB1uB,KAAK0yB,KAAKhE,aAAuB1uB,KAAKgyB,kBAC9DhyB,KAAK0yB,KAAKhE,YACd2D,EAAWM,OAAO3yB,KAAK4yB,cACnB5yB,KAAK0yB,KAAKtD,aACVpvB,KAAK0yB,KAAKtD,YAAYuD,OAAO3yB,KAAK6yB,UAEtC7yB,KAAKsxB,4BAA8BtxB,KAAK8yB,sBAAsBnvB,WAAU,kBAGlE3D,EAAKoyB,eACXpyB,KAAK+yB,YACD/yB,KAAK0yB,gBAAgB3E,GACrB/tB,KAAK0yB,KAAKM,qB,kCAQdhzB,KAAK0yB,KAAKlxB,MAAMZ,S,8BAQcmjB,IAA5BgH,EAA4BhH,uDAAnB,UAAWA,EAAQA,uCAC1B/jB,KAAKwqB,cACLxqB,KAAKwqB,cAAcK,SAAS7qB,KAAKuqB,SAAUQ,EAAQhH,GAGnD/jB,KAAKuqB,SAAS7iB,cAAc0lB,MAAMrJ,K,qCAQ5B,WACV,GAAK/jB,KAAKoxB,aAAgBpxB,KAAKizB,SAA/B,CAIA,IAAMP,EAAO1yB,KAAK0yB,KAClB1yB,KAAKsxB,4BAA4B7tB,cACjCzD,KAAKoxB,YAAY8B,SACbR,aAAgB3E,GAChB2E,EAAKS,kBACDT,EAAKtD,YAELsD,EAAKnE,eACA3a,KAAK,aAIVlH,YAAKA,MAAsB,SAAlBA,EAAM+c,WAAsB,YAAK,GAE1C,YAAUiJ,EAAKtD,YAAYgE,YACtBzvB,UAAU,CACXxB,KAAM,kBAGmBuwB,EAAiB,YAAEQ,UAE5C9wB,SAAU,kBAGJpC,EAAKqzB,gBAAeA,MAI9BrzB,KAAKqzB,gBAAeA,KAIxBrzB,KAAKqzB,gBAAeA,GAChBX,EAAKtD,aACLsD,EAAKtD,YAAY8D,UAGzBlzB,KAAKszB,mB,kCASLtzB,KAAK0yB,KAAKxD,WAAalvB,KAAKgyB,kBAAoBhyB,KAAK4sB,mBACrD5sB,KAAK0yB,KAAK1hB,UAAYhR,KAAKinB,IAC3BjnB,KAAKuzB,oBACLvzB,KAAKqzB,gBAAeA,GACpBrzB,KAAK0yB,KAAKc,eAAexzB,KAAK0xB,WAAa,a,0CAQ3C,GAAI1xB,KAAK0yB,KAAKe,aAAc,CAKxB,IAHA,IAAI/D,EAAQ,EAERR,EAAalvB,KAAK0yB,KAAKxD,WACpBA,GACHQ,IACAR,EAAaA,EAAWA,WAE5BlvB,KAAK0yB,KAAKe,aAAa/D,M,sCAYvB1vB,KAAK2xB,eACA3xB,KAAK0xB,UAKA1xB,KAAKgyB,mBACXhyB,KAAKotB,MAAMptB,KAAK0xB,WAHhB1xB,KAAKotB,SAMbptB,KAAK0xB,UAAY,O,qCAQNgC,GACX1zB,KAAKqxB,UAAYqC,EACjB1zB,KAAKqxB,UAAYrxB,KAAK4xB,WAAWhxB,OAASZ,KAAK8xB,WAAWlxB,OACtDZ,KAAKgyB,oBACLhyB,KAAKmxB,kBAAkBnE,aAAe0G,K,mCAUrC1zB,KAAK0yB,MA56ClB,WACI,MAAMrqB,MAAM,0KADhB,K,uCAu7CQ,IAAKrI,KAAKoxB,YAAa,CAEnB,IAAMpN,EAAShkB,KAAK2zB,oBACpB3zB,KAAK4zB,sBAAyC5P,EAAwB,kBACtEhkB,KAAKoxB,YAAcpxB,KAAKixB,SAAS4C,OAAO7P,GAIxChkB,KAAKoxB,YAAY0C,gBAAgBnwB,YAErC,OAAO3D,KAAKoxB,c,0CAQZ,OAAO,IAAI,IAAc,CACrB2C,iBAAkB/zB,KAAKixB,SAAS/f,WAC3B8iB,oBAAoBh0B,KAAKuqB,UACzB0J,qBACAC,sBAAsB,wCAC3BrG,cAAe7tB,KAAK0yB,KAAK7E,eAAiB,mCAC1CqD,eAAgBlxB,KAAKiyB,kBACrBjhB,UAAWhR,KAAK6kB,S,4CAWF3T,GAASA,WACvBlR,KAAK0yB,KAAK9D,oBACV1d,EAASijB,gBAAgBxwB,WAIzB2M,YAKuBtQ,EAAK0yB,KAAwB,mBAHA,UAAnCpiB,EAAO8jB,eAAeC,SAAuB,QAAU,SAEpB,QAAnC/jB,EAAO8jB,eAAeE,SAAqB,QAAU,c,mCAYjEP,GAAiBA,qBAC+B,WAAxB/zB,KAAK0yB,KAAK/E,UAAyB,CAAC,MAAO,SAAW,CAAC,QAAS,OADvEoG,GACrBQ,EADqBR,KACZS,EADYT,sBAEiC,UAAxB/zB,KAAK0yB,KAAK9E,UAAwB,CAAC,SAAU,OAAS,CAAC,MAAO,UAFvEmG,GAErBO,EAFqBP,KAEXU,EAFWV,KAGrBW,EAA6BJ,EAApBK,EAA8BF,EACvCJ,EAA+BE,EAArBK,EAA8BJ,EAEzCK,EAAU,EACV70B,KAAKgyB,mBAGL4C,EAAmBL,EAAkC,WAAxBv0B,KAAK0yB,KAAK/E,UAAyB,QAAU,MAC1E6G,EAAkBH,EAAuB,QAAZE,EAAoB,QAAU,MAC3DM,EAAuB,WAAbP,EAtaS,MAwabt0B,KAAK0yB,KAAKhF,iBAChBgH,EAAuB,QAAbJ,EAAqB,SAAW,MAC1CK,EAAuC,QAArBF,EAA6B,SAAW,OAE9DV,EAAiBe,cAAc,CAC3B,CAAEP,UAASG,UAASL,WAAUC,WAAUO,WACxC,CAAEN,QAASC,EAAiBE,UAASL,SAAUO,EAAkBN,WAAUO,WAC3E,CACIN,UACAG,QAASC,EACTN,WACAC,SAAUG,EACVI,SAAUA,GAEd,CACIN,QAASC,EACTE,QAASC,EACTN,SAAUO,EACVN,SAAUG,EACVI,SAAUA,O,4CASD,WAEXE,EAA8B/0B,KAAiB,YAAEg1B,gBAEjDC,EAAiCj1B,KAAiB,YAAEi1B,cAEpDC,EAAcl1B,KAAK4sB,YAAc5sB,KAAK4sB,YAAY7pB,OAAS,cAE3DoyB,EAAQn1B,KAAK4sB,YAAc5sB,KAAK4sB,YAAYE,WAAWlZ,KAAK,aAIlEwhB,YAAMA,OAAIA,IAAWp1B,EAAKmxB,qBAAqB,aAAO,kBAGhDnxB,EAAKqxB,cAAe,cAC1B,OAAO,YAAM0D,EAAUG,EAAaC,EAAOF,K,uCAO9BvoB,GACR,YAAgCA,KAGjC1M,KAAK0xB,UAA6B,IAAjBhlB,EAAM0G,OAAe,QAAU,KAI5CpT,KAAKgyB,mBACLtlB,EAAMS,oB,qCASHT,GAEX,IAAM2e,EAAU3e,EAAM2e,QAClBrrB,KAAKgyB,oBAAuB3G,IAAY,KAA4B,QAAbrrB,KAAKinB,KAC3DoE,IAAY,KAA2B,QAAbrrB,KAAKinB,MAChCjnB,KAAKF,a,mCAQA4M,GACL1M,KAAKgyB,mBAELtlB,EAAMuG,kBACNjT,KAAKF,YAGLE,KAAKq1B,e,qCAQC,WAELr1B,KAAKgyB,oBAGVhyB,KAAKuxB,mBAAqBvxB,KAAK4sB,YAAYE,WAItClZ,KAAK,aAIVwhB,YAAMA,OAAIA,IAAWp1B,EAAKmxB,oBAAsBiE,EAAO1xB,YAAY,YAAM,EAAG,EAAAqZ,IACvEpZ,WAAU,WAIX3D,EAAK0xB,UAAY,QAIb1xB,EAAK0yB,gBAAgB3E,GAAW/tB,EAAK0yB,KAAKvC,aAG1CnwB,EAAK0yB,KAAKnE,eACL3a,KAAK,YAAK,GAAI,YAAM,EAAG,EAAAmJ,GAAgB,YAAU/c,EAAK4sB,YAAYE,aAClEnpB,WAAU,kBAGT3D,EAAKF,cAGXE,EAAKF,iB,mCAgBb,OAHKE,KAAK6pB,SAAW7pB,KAAK6pB,QAAQ3C,cAAgBlnB,KAAK0yB,KAAKxL,cACxDlnB,KAAK6pB,QAAU,IAAI,IAAe7pB,KAAK0yB,KAAKxL,YAAalnB,KAAK4kB,oBAE3D5kB,KAAK6pB,U,mDAreqB,OAAO7pB,KAAK0yB,M,aAKhB4C,GAC7Bt1B,KAAK0yB,KAAO4C,I,2BAMH,OAAOt1B,KAAKu1B,O,aAKhB7C,GAAKA,WACNA,IAAS1yB,KAAKu1B,QAGlBv1B,KAAKu1B,MAAQ7C,EACb1yB,KAAKwxB,uBAAuB/tB,cACxBivB,IACA1yB,KAAKwxB,uBAAyBkB,EAAKlxB,MAAMgF,eAAe7C,WAIxD6xB,YACIx1B,EAAKy1B,eAEW,UAAXD,GAAiC,QAAXA,IAAqBx1B,EAAK4sB,aACjD5sB,EAAK4sB,YAAY7pB,OAAOnC,KAAK40B,U,+BA8BzC,OAAOx1B,KAAKqxB,Y,0BAOZ,OAAOrxB,KAAK6kB,MAA4B,QAApB7kB,KAAK6kB,KAAKvkB,MAAkB,MAAQ,U,KA4kB1Do1B,E,sCAYAC,E,msFCvjEA,gHAA2C,c,OAA3C,EAAyE,U,wBAAzE,iBACE,0GACA,oFAAsB,oF,8BAStB,qU,MAAA,c,oMAA+D,2BAE7D,cAFF,QAAyC,EAAqB,0CAA9D,oLAA+D,qC,8BALjE,yvB,iIAGE,wB,wCAHF,+eAKE,8GAA+D,gCALjE,QACE,SADF,SAKE,SAAY,EAA4B,yBAL1C,wjB,8BAUA,2wCAKE,2tB,MAAA,c,iuCAOA,sP,MAAA,c,qNACE,wTAAkC,uCAEpC,2KACA,sMAMC,UAND,MAEE,sB,8CACA,qB,kCAHF,mNAMC,gCAtBH,QACE,QAIA,SAEE,WACA,EAAwB,kBAH1B,SAIE,aAJF,SAKE,IAEF,SAAiC,YAC/B,UAGF,SAIE,aACA,2BAAiC,cArBrC,+rBAKE,ytBAOA,oNACE,oH,8BAnCV,6FACE,yFACE,+FACE,+EACE,8DAAG,6BAEL,oGAKF,oS,MAAA,e,0RACE,qGAUA,qGA4BJ,8FACE,0HAAkE,UAAlE,MAAmC,c,kCAAnC,iBACA,6FACE,gEACE,2I,MAAA,c,oKACE,+DAAG,iCAGP,wFAAyC,UAAzC,MAAI,c,oCAAJ,iBACE,+DAAG,4CAAa,gCArDlB,QAAwB,EAAkB,YAK5C,SAA0B,EAAkB,MAC1C,SAEE,EAA+B,yBAQjC,SAEE,EAA0C,oCA8B1C,SAAG,qBAA2B,gCAlD3B,uBAOP,8LAyCA,SAAiB,EAAuB,UAEpC","file":"x","sourcesContent":["import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';\r\nimport * as firebase from 'firebase/app';\r\nimport { Router } from '@angular/router';\r\nimport * as moment from 'moment';\r\nimport { FormBuilder } from '@angular/forms';\r\nimport {\r\n  MomentDateAdapter,\r\n  MAT_MOMENT_DATE_ADAPTER_OPTIONS,\r\n} from '@angular/material-moment-adapter';\r\nimport {\r\n  DateAdapter,\r\n  MAT_DATE_FORMATS,\r\n  MAT_DATE_LOCALE,\r\n} from '@angular/material/core';\r\nimport { MatDatepicker } from '@angular/material/datepicker';\r\n\r\n// Formats of the month/year calendar.\r\nexport const MONTH_YEAR_FORMAT = {\r\n  parse: {\r\n    dateInput: 'MM/YYYY',\r\n  },\r\n  display: {\r\n    dateInput: 'MMMM YYYY',\r\n    monthYearLabel: 'MMM YYYY',\r\n    dateA11yLabel: 'LL',\r\n    monthYearA11yLabel: 'MMMM YYYY',\r\n  },\r\n};\r\n\r\n@Component({\r\n  selector: 'app-section-header',\r\n  templateUrl: './section-header.component.html',\r\n  styleUrls: ['./section-header.component.scss'],\r\n  providers: [\r\n    {\r\n      provide: DateAdapter,\r\n      useClass: MomentDateAdapter,\r\n      deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS],\r\n    },\r\n\r\n    { provide: MAT_DATE_FORMATS, useValue: MONTH_YEAR_FORMAT },\r\n  ],\r\n})\r\nexport class SectionHeaderComponent implements OnInit {\r\n  @Input() sectionName: string;\r\n  @Input() actionName: string;\r\n  @Input() isMonthsSelectorVisible = false;\r\n\r\n  /**\r\n   * Indicates if the month/year calendar should be visible.\r\n   */\r\n  @Input() hasTheMonthYearCalendarToBeVisible = false;\r\n\r\n  @Output() actionClicked: EventEmitter<void> = new EventEmitter<void>();\r\n  @Output() monthChanged: EventEmitter<number> = new EventEmitter<number>();\r\n  @Output() monthYearChanged: EventEmitter<number> = new EventEmitter<number>();\r\n  public openMenu = false;\r\n\r\n  public form = this.fb.group({\r\n    month: [''],\r\n    monthYear: [moment()],\r\n  });\r\n\r\n  public yearAux: moment.Moment;\r\n\r\n  public months: Array<{ name: string; value: number }> = [\r\n    { name: 'Enero', value: 0 },\r\n    { name: 'Febrero', value: 1 },\r\n    { name: 'Marzo', value: 2 },\r\n    { name: 'Abril', value: 3 },\r\n    { name: 'Mayo', value: 4 },\r\n    { name: 'Junio', value: 5 },\r\n    { name: 'Julio', value: 6 },\r\n    { name: 'Agosto', value: 7 },\r\n    { name: 'Septiembre', value: 8 },\r\n    { name: 'Octubre', value: 9 },\r\n    { name: 'Noviembre', value: 10 },\r\n    { name: 'Diciembre', value: 11 },\r\n  ];\r\n\r\n  /**\r\n   * Max date to limit the month year calendar.\r\n   */\r\n  public monthYearMaxDate = moment();\r\n\r\n  constructor(private router: Router, private fb: FormBuilder) {}\r\n\r\n  ngOnInit(): void {\r\n    this.setactualMonthAsSelected();\r\n  }\r\n\r\n  private setactualMonthAsSelected(): void {\r\n    const actualMonth = moment().get('month');\r\n    this.form.get('month').setValue(actualMonth);\r\n  }\r\n\r\n  public emitActionClicked(): void {\r\n    this.actionClicked.emit();\r\n  }\r\n\r\n  public logout(): void {\r\n    firebase\r\n      .auth()\r\n      .signOut()\r\n      .then(() => {\r\n        localStorage.clear();\r\n        this.router.navigate(['/login']);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Function that stores the selected year at a global variable.\r\n   * @param normalizedYear Moment type date so store.\r\n   */\r\n  public chosenYearHandler(normalizedYear: moment.Moment): void {\r\n    this.yearAux = normalizedYear;\r\n  }\r\n\r\n  /**\r\n   * Function that takes the selected month and saved to emit the selected date.\r\n   * @param normalizedMonth Month to create the date to emit.\r\n   * @param datepicker Reference to the calendar to call its functions.\r\n   */\r\n  public chosenMonthHandler(\r\n    normalizedMonth: moment.Moment,\r\n    datepicker: MatDatepicker<moment.Moment>\r\n  ) {\r\n    const ctrlValue = this.form.get('monthYear').value;\r\n    ctrlValue.month(normalizedMonth.month());\r\n    ctrlValue.year(this.yearAux.year());\r\n    this.form.get('monthYear').setValue(ctrlValue);\r\n    datepicker.close();\r\n    this.monthYearChanged.emit(\r\n      this.form.get('monthYear').value.startOf('month').valueOf()\r\n    );\r\n  }\r\n}\r\n","<ng-content></ng-content>\n<ng-content select=\"mat-toolbar-row\"></ng-content>\n","import { Directive, Input, EventEmitter, Optional, SkipSelf, ChangeDetectorRef, Output, NgModule } from '@angular/core';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Subject, Subscription } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to generate unique ID for each accordion.\n * @type {?}\n */\nlet nextId = 0;\n/**\n * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.\n */\nclass CdkAccordion {\n    constructor() {\n        /**\n         * Emits when the state of the accordion changes\n         */\n        this._stateChanges = new Subject();\n        /**\n         * Stream that emits true/false when openAll/closeAll is triggered.\n         */\n        this._openCloseAllActions = new Subject();\n        /**\n         * A readonly id value to use for unique selection coordination.\n         */\n        this.id = `cdk-accordion-${nextId++}`;\n        this._multi = false;\n    }\n    /**\n     * Whether the accordion should allow multiple expanded accordion items simultaneously.\n     * @return {?}\n     */\n    get multi() { return this._multi; }\n    /**\n     * @param {?} multi\n     * @return {?}\n     */\n    set multi(multi) { this._multi = coerceBooleanProperty(multi); }\n    /**\n     * Opens all enabled accordion items in an accordion where multi is enabled.\n     * @return {?}\n     */\n    openAll() {\n        this._openCloseAll(true);\n    }\n    /**\n     * Closes all enabled accordion items in an accordion where multi is enabled.\n     * @return {?}\n     */\n    closeAll() {\n        this._openCloseAll(false);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this._stateChanges.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n    /**\n     * @private\n     * @param {?} expanded\n     * @return {?}\n     */\n    _openCloseAll(expanded) {\n        if (this.multi) {\n            this._openCloseAllActions.next(expanded);\n        }\n    }\n}\nCdkAccordion.decorators = [\n    { type: Directive, args: [{\n                selector: 'cdk-accordion, [cdkAccordion]',\n                exportAs: 'cdkAccordion',\n            },] }\n];\nCdkAccordion.propDecorators = {\n    multi: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    CdkAccordion.ngAcceptInputType_multi;\n    /**\n     * Emits when the state of the accordion changes\n     * @type {?}\n     */\n    CdkAccordion.prototype._stateChanges;\n    /**\n     * Stream that emits true/false when openAll/closeAll is triggered.\n     * @type {?}\n     */\n    CdkAccordion.prototype._openCloseAllActions;\n    /**\n     * A readonly id value to use for unique selection coordination.\n     * @type {?}\n     */\n    CdkAccordion.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordion.prototype._multi;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion-item.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to generate unique ID for each accordion item.\n * @type {?}\n */\nlet nextId$1 = 0;\nconst Éµ0 = undefined;\n/**\n * An basic directive expected to be extended and decorated as a component.  Sets up all\n * events and attributes needed to be managed by a CdkAccordion parent.\n */\nclass CdkAccordionItem {\n    /**\n     * @param {?} accordion\n     * @param {?} _changeDetectorRef\n     * @param {?} _expansionDispatcher\n     */\n    constructor(accordion, _changeDetectorRef, _expansionDispatcher) {\n        this.accordion = accordion;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._expansionDispatcher = _expansionDispatcher;\n        /**\n         * Subscription to openAll/closeAll events.\n         */\n        this._openCloseAllSubscription = Subscription.EMPTY;\n        /**\n         * Event emitted every time the AccordionItem is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted every time the AccordionItem is opened.\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event emitted when the AccordionItem is destroyed.\n         */\n        this.destroyed = new EventEmitter();\n        /**\n         * Emits whenever the expanded state of the accordion changes.\n         * Primarily used to facilitate two-way binding.\n         * \\@docs-private\n         */\n        this.expandedChange = new EventEmitter();\n        /**\n         * The unique AccordionItem id.\n         */\n        this.id = `cdk-accordion-child-${nextId$1++}`;\n        this._expanded = false;\n        this._disabled = false;\n        /**\n         * Unregister function for _expansionDispatcher.\n         */\n        this._removeUniqueSelectionListener = (/**\n         * @return {?}\n         */\n        () => { });\n        this._removeUniqueSelectionListener =\n            _expansionDispatcher.listen((/**\n             * @param {?} id\n             * @param {?} accordionId\n             * @return {?}\n             */\n            (id, accordionId) => {\n                if (this.accordion && !this.accordion.multi &&\n                    this.accordion.id === accordionId && this.id !== id) {\n                    this.expanded = false;\n                }\n            }));\n        // When an accordion item is hosted in an accordion, subscribe to open/close events.\n        if (this.accordion) {\n            this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();\n        }\n    }\n    /**\n     * Whether the AccordionItem is expanded.\n     * @return {?}\n     */\n    get expanded() { return this._expanded; }\n    /**\n     * @param {?} expanded\n     * @return {?}\n     */\n    set expanded(expanded) {\n        expanded = coerceBooleanProperty(expanded);\n        // Only emit events and update the internal value if the value changes.\n        if (this._expanded !== expanded) {\n            this._expanded = expanded;\n            this.expandedChange.emit(expanded);\n            if (expanded) {\n                this.opened.emit();\n                /**\n                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,\n                 * the name value is the id of the accordion.\n                 * @type {?}\n                 */\n                const accordionId = this.accordion ? this.accordion.id : this.id;\n                this._expansionDispatcher.notify(this.id, accordionId);\n            }\n            else {\n                this.closed.emit();\n            }\n            // Ensures that the animation will run when the value is set outside of an `@Input`.\n            // This includes cases like the open, close and toggle methods.\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Whether the AccordionItem is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    set disabled(disabled) { this._disabled = coerceBooleanProperty(disabled); }\n    /**\n     * Emits an event for the accordion item being destroyed.\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.opened.complete();\n        this.closed.complete();\n        this.destroyed.emit();\n        this.destroyed.complete();\n        this._removeUniqueSelectionListener();\n        this._openCloseAllSubscription.unsubscribe();\n    }\n    /**\n     * Toggles the expanded state of the accordion item.\n     * @return {?}\n     */\n    toggle() {\n        if (!this.disabled) {\n            this.expanded = !this.expanded;\n        }\n    }\n    /**\n     * Sets the expanded state of the accordion item to false.\n     * @return {?}\n     */\n    close() {\n        if (!this.disabled) {\n            this.expanded = false;\n        }\n    }\n    /**\n     * Sets the expanded state of the accordion item to true.\n     * @return {?}\n     */\n    open() {\n        if (!this.disabled) {\n            this.expanded = true;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _subscribeToOpenCloseAllActions() {\n        return this.accordion._openCloseAllActions.subscribe((/**\n         * @param {?} expanded\n         * @return {?}\n         */\n        expanded => {\n            // Only change expanded state if item is enabled\n            if (!this.disabled) {\n                this.expanded = expanded;\n            }\n        }));\n    }\n}\nCdkAccordionItem.decorators = [\n    { type: Directive, args: [{\n                selector: 'cdk-accordion-item, [cdkAccordionItem]',\n                exportAs: 'cdkAccordionItem',\n                providers: [\n                    // Provide CdkAccordion as undefined to prevent nested accordion items from registering\n                    // to the same accordion.\n                    { provide: CdkAccordion, useValue: Éµ0 },\n                ],\n            },] }\n];\n/** @nocollapse */\nCdkAccordionItem.ctorParameters = () => [\n    { type: CdkAccordion, decorators: [{ type: Optional }, { type: SkipSelf }] },\n    { type: ChangeDetectorRef },\n    { type: UniqueSelectionDispatcher }\n];\nCdkAccordionItem.propDecorators = {\n    closed: [{ type: Output }],\n    opened: [{ type: Output }],\n    destroyed: [{ type: Output }],\n    expandedChange: [{ type: Output }],\n    expanded: [{ type: Input }],\n    disabled: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    CdkAccordionItem.ngAcceptInputType_expanded;\n    /** @type {?} */\n    CdkAccordionItem.ngAcceptInputType_disabled;\n    /**\n     * Subscription to openAll/closeAll events.\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._openCloseAllSubscription;\n    /**\n     * Event emitted every time the AccordionItem is closed.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.closed;\n    /**\n     * Event emitted every time the AccordionItem is opened.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.opened;\n    /**\n     * Event emitted when the AccordionItem is destroyed.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.destroyed;\n    /**\n     * Emits whenever the expanded state of the accordion changes.\n     * Primarily used to facilitate two-way binding.\n     * \\@docs-private\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.expandedChange;\n    /**\n     * The unique AccordionItem id.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._expanded;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._disabled;\n    /**\n     * Unregister function for _expansionDispatcher.\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._removeUniqueSelectionListener;\n    /** @type {?} */\n    CdkAccordionItem.prototype.accordion;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CdkAccordionItem.prototype._expansionDispatcher;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass CdkAccordionModule {\n}\nCdkAccordionModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [CdkAccordion, CdkAccordionItem],\n                declarations: [CdkAccordion, CdkAccordionItem],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkAccordion, CdkAccordionItem, CdkAccordionModule };\n//# sourceMappingURL=accordion.js.map\n","<ng-content select=\"mat-expansion-panel-header\"></ng-content>\n<div class=\"mat-expansion-panel-content\"\n     role=\"region\"\n     [@bodyExpansion]=\"_getExpandedState()\"\n     (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\"\n     [attr.aria-labelledby]=\"_headerId\"\n     [id]=\"id\"\n     #body>\n  <div class=\"mat-expansion-panel-body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"_portal\"></ng-template>\n  </div>\n  <ng-content select=\"mat-action-row\"></ng-content>\n</div>\n","<span class=\"mat-content\">\n  <ng-content select=\"mat-panel-title\"></ng-content>\n  <ng-content select=\"mat-panel-description\"></ng-content>\n  <ng-content></ng-content>\n</span>\n<span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\"\n      class=\"mat-expansion-indicator\"></span>\n","import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from '@environments/environment';\r\nimport { Modifiers } from '@models';\r\nimport { Subject, Observable } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class MenuService {\r\n  public restaurantSelected = new Subject<number>();\r\n  public modifiers: Modifiers[] = [];\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  public getIcons(): Observable<any> {\r\n    return this.http.get<any>(environment.GET_ICONS);\r\n  }\r\n  public getTemplate(): Observable<any> {\r\n    return this.http.get<any>(environment.DOWNLOAD_TEMPLATE);\r\n  }\r\n  public duplicateMatrizMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_MATRIZ_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public getMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.MENUS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public duplicateMenu(menuId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_MENU.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.DELETE_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public createMenu(data: any, restaurantId: number): Observable<any> {\r\n    const url = environment.CREATE_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editMenu(data: any, menuId: number): Observable<any> {\r\n    const url = environment.EDIT_MENU.replace('{menuId}', menuId.toString());\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public orderMenu(restaurantId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n\r\n  public getCategory(menuId: number): Observable<any> {\r\n    const url = environment.GET_CATEGORY.replace('{menuId}', menuId.toString());\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createCategory(data: any, menuId: number): Observable<any> {\r\n    const url = environment.CREATE_CATEGORY.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editCategory(data: any, categoryId: number): Observable<any> {\r\n    const url = environment.EDIT_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public duplicateCategory(categoryId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteCategory(categoryId: number): Observable<any> {\r\n    const url = environment.DELETE_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public orderCategory(menuId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_CATEGORY.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n\r\n  public getDishes(categoryId: number): Observable<any> {\r\n    const url = environment.GET_DISHES.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createDishes(data: any, categoryId: number): Observable<any> {\r\n    const url = environment.CREATE_DISHE.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editDishes(data: any, dishId: number): Observable<any> {\r\n    const url = environment.EDIT_DISHE.replace('{dishId}', dishId.toString());\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public duplicateDishes(dishId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_DISHE.replace(\r\n      '{dishId}',\r\n      dishId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteDishes(dishId: number): Observable<any> {\r\n    const url = environment.DELETE_DISHE.replace('{dishId}', dishId.toString());\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public orderDishes(categoryId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_DISHES.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public updateDishStatus(dishId: number): Observable<any> {\r\n    const url = environment.UPDATE_DISH.replace('{dishId}', dishId.toString());\r\n    return this.http.put<any>(url, {});\r\n  }\r\n  public getModifier(restaurantId: number): Observable<any> {\r\n    const url = environment.GET_MODIFIERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createModifier(data: any, restaurantId: number): Observable<any> {\r\n    const url = environment.CREATE_MODIFIERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editModifier(data: any, modifierId: number): Observable<any> {\r\n    const url = environment.EDIT_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public deleteModifier(modifierId: number): Observable<any> {\r\n    const url = environment.EDIT_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n\r\n  public getRestaurant(): Observable<any> {\r\n    return this.restaurantSelected.asObservable();\r\n  }\r\n  public updateRestaurant(restaurant: any) {\r\n    this.restaurantSelected.next(restaurant);\r\n  }\r\n\r\n  public deleteModifierLocal(modifierId: number) {\r\n    const url = environment.DELETE_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.delete(url);\r\n  }\r\n\r\n  public uploadZip(zip: FormData, restaurantId: number) {\r\n    const url = environment.UPLOAD_TEMPLATE.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post(url, zip);\r\n  }\r\n}\r\n","import { Directive, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/toolbar.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatToolbar.\n/**\n * \\@docs-private\n */\nclass MatToolbarBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatToolbarBase.prototype._elementRef;\n}\n/** @type {?} */\nconst _MatToolbarMixinBase = mixinColor(MatToolbarBase);\nclass MatToolbarRow {\n}\nMatToolbarRow.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-toolbar-row',\n                exportAs: 'matToolbarRow',\n                host: { 'class': 'mat-toolbar-row' },\n            },] }\n];\nclass MatToolbar extends _MatToolbarMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _platform\n     * @param {?=} document\n     */\n    constructor(elementRef, _platform, document) {\n        super(elementRef);\n        this._platform = _platform;\n        // TODO: make the document a required param when doing breaking changes.\n        this._document = document;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!isDevMode() || !this._platform.isBrowser) {\n            return;\n        }\n        this._checkToolbarMixedModes();\n        this._toolbarRows.changes.subscribe((/**\n         * @return {?}\n         */\n        () => this._checkToolbarMixedModes()));\n    }\n    /**\n     * Throws an exception when developers are attempting to combine the different toolbar row modes.\n     * @private\n     * @return {?}\n     */\n    _checkToolbarMixedModes() {\n        if (!this._toolbarRows.length) {\n            return;\n        }\n        // Check if there are any other DOM nodes that can display content but aren't inside of\n        // a <mat-toolbar-row> element.\n        /** @type {?} */\n        const isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes)\n            .filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => !(node.classList && node.classList.contains('mat-toolbar-row'))))\n            .filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)))\n            .some((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => !!(node.textContent && node.textContent.trim())));\n        if (isCombinedUsage) {\n            throwToolbarMixedModesError();\n        }\n    }\n}\nMatToolbar.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-toolbar',\n                exportAs: 'matToolbar',\n                template: \"<ng-content></ng-content>\\n<ng-content select=\\\"mat-toolbar-row\\\"></ng-content>\\n\",\n                inputs: ['color'],\n                host: {\n                    'class': 'mat-toolbar',\n                    '[class.mat-toolbar-multiple-rows]': '_toolbarRows.length > 0',\n                    '[class.mat-toolbar-single-row]': '_toolbarRows.length === 0',\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                styles: [\".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatToolbar.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nMatToolbar.propDecorators = {\n    _toolbarRows: [{ type: ContentChildren, args: [MatToolbarRow, { descendants: true },] }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatToolbar.prototype._document;\n    /**\n     * Reference to all toolbar row elements that have been projected.\n     * @type {?}\n     */\n    MatToolbar.prototype._toolbarRows;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatToolbar.prototype._platform;\n}\n/**\n * Throws an exception when attempting to combine the different toolbar row modes.\n * \\@docs-private\n * @return {?}\n */\nfunction throwToolbarMixedModesError() {\n    throw Error('MatToolbar: Attempting to combine different toolbar modes. ' +\n        'Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content ' +\n        'inside of a `<mat-toolbar>` for a single row.');\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/toolbar-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatToolbarModule {\n}\nMatToolbarModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [MatCommonModule],\n                exports: [MatToolbar, MatToolbarRow, MatCommonModule],\n                declarations: [MatToolbar, MatToolbarRow],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatToolbar, MatToolbarModule, MatToolbarRow, throwToolbarMixedModesError };\n//# sourceMappingURL=toolbar.js.map\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period = 0, scheduler = async) {\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(subscriber => {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, counter, period } = state;\n    subscriber.next(counter);\n    this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n//# sourceMappingURL=interval.js.map","import { Injectable, NgZone, Inject, ÉµÉµdefineInjectable, ÉµÉµinject, InjectionToken, Directive, ElementRef, Optional, Input, TemplateRef, EventEmitter, isDevMode, SkipSelf, ViewContainerRef, ChangeDetectorRef, ContentChildren, ContentChild, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { normalizePassiveListenerOptions, _supportsShadowDom } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { Subject, Subscription, interval, animationFrameScheduler, Observable, merge } from 'rxjs';\nimport { startWith, takeUntil, map, take, tap, switchMap } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-styling.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extended CSSStyleDeclaration that includes a couple of drag-related\n * properties that aren't in the built-in TS typings.\n * @record\n */\nfunction DragCSSStyleDeclaration() { }\nif (false) {\n    /** @type {?} */\n    DragCSSStyleDeclaration.prototype.webkitUserDrag;\n    /** @type {?} */\n    DragCSSStyleDeclaration.prototype.MozUserSelect;\n}\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = (/** @type {?} */ (source[key]));\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/transition-duration.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    const computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    const property = transitionedProperties.find((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => prop === 'transform' || prop === 'all'));\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    const propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map((/**\n     * @param {?} part\n     * @return {?}\n     */\n    part => part.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Object that can be used to configure the behavior of DragRef.\n * @record\n */\nfunction DragRefConfig() { }\nif (false) {\n    /**\n     * Minimum amount of pixels that the user should\n     * drag, before the CDK initiates a drag sequence.\n     * @type {?}\n     */\n    DragRefConfig.prototype.dragStartThreshold;\n    /**\n     * Amount the pixels the user should drag before the CDK\n     * considers them to have changed the drag direction.\n     * @type {?}\n     */\n    DragRefConfig.prototype.pointerDirectionChangeThreshold;\n}\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Internal compile-time-only representation of a `DragRef`.\n * Used to avoid circular import issues between the `DragRef` and the `DropListRef`.\n * \\@docs-private\n * @record\n */\nfunction DragRefInternal() { }\n/**\n * Template that can be used to create a drag helper element (e.g. a preview or a placeholder).\n * @record\n * @template T\n */\nfunction DragHelperTemplate() { }\nif (false) {\n    /** @type {?} */\n    DragHelperTemplate.prototype.template;\n    /** @type {?} */\n    DragHelperTemplate.prototype.viewContainer;\n    /** @type {?} */\n    DragHelperTemplate.prototype.context;\n}\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * @template T\n */\nclass DragRef {\n    /**\n     * @param {?} element\n     * @param {?} _config\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being scrolled.\n         */\n        this._scrollSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being resized.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new Subject();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new Subject();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new Subject();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents.asObservable();\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                /** @type {?} */\n                const targetHandle = this._handles.find((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => {\n                    /** @type {?} */\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                }));\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        });\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Prevent the default action as early as possible in order to block\n            // native actions like dragging the selected text or images with the mouse.\n            event.preventDefault();\n            if (!this._hasStartedDragging) {\n                /** @type {?} */\n                const pointerPosition = this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                /** @type {?} */\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                /** @type {?} */\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    /** @type {?} */\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!this._dropContainer || !this._dropContainer.isDragging()) {\n                        this._hasStartedDragging = true;\n                        this._ngZone.run((/**\n                         * @return {?}\n                         */\n                        () => this._startDragSequence(event)));\n                    }\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(event);\n            this._hasMoved = true;\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta\n                    });\n                }));\n            }\n        });\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this._endDragSequence(event);\n        });\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        /** @type {?} */\n        const newValue = coerceBooleanProperty(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    withHandles(handles) {\n        (/** @type {?} */ (this))._handles = handles.map((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => coerceElement(handle)));\n        (/** @type {?} */ (this))._handles.forEach((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => toggleNativeDragInteractions(handle, false)));\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    withPreviewTemplate(template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    withPlaceholderTemplate(template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    withRootElement(rootElement) {\n        /** @type {?} */\n        const element = coerceElement(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    withBoundaryElement(boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        (/** @type {?} */ (this))._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            (/** @type {?} */ (this))._resizeSubscription = (/** @type {?} */ (this))._viewportRuler\n                .change(10)\n                .subscribe((/**\n             * @return {?}\n             */\n            () => (/** @type {?} */ (this))._containInsideBoundaryOnResize()));\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeNode(this._rootElement);\n        }\n        removeNode(this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._resizeSubscription.unsubscribe();\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._anchor = (/** @type {?} */ (null));\n    }\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    disableHandle(handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    enableHandle(handle) {\n        this._disabledHandles.delete(handle);\n    }\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        /** @type {?} */\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} value New position to be set.\n     * @return {THIS}\n     */\n    setFreeDragPosition(value) {\n        (/** @type {?} */ (this))._activeTransform = { x: 0, y: 0 };\n        (/** @type {?} */ (this))._passiveTransform.x = value.x;\n        (/** @type {?} */ (this))._passiveTransform.y = value.y;\n        if (!(/** @type {?} */ (this))._dropContainer) {\n            (/** @type {?} */ (this))._applyRootElementTransform(value.x, value.y);\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Updates the item's sort order based on the last-known pointer position.\n     * @return {?}\n     */\n    _sortFromLastPointerPosition() {\n        /** @type {?} */\n        const position = this._pointerPositionAtLastDirectionChange;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(position);\n        }\n    }\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPreview() {\n        if (this._preview) {\n            removeNode(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeNode(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @private\n     * @param {?} event Browser event object that ended the sequence.\n     * @return {?}\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then((/**\n             * @return {?}\n             */\n            () => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            }));\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(this._getPointerPositionOnPage(event))\n                });\n            }));\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _startDragSequence(event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        if (this._dropContainer) {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const parent = (/** @type {?} */ (element.parentNode));\n            /** @type {?} */\n            const preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            /** @type {?} */\n            const anchor = this._anchor = this._anchor || this._document.createComment('');\n            // Insert an anchor node so that we can restore the element's position in the DOM.\n            parent.insertBefore(anchor, element);\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild(parent.replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document).appendChild(preview);\n            this._dropContainer.start();\n        }\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        const isDragging = this.isDragging();\n        /** @type {?} */\n        const isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        const isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        const rootElement = this._rootElement;\n        /** @type {?} */\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry.scroll.pipe(startWith(null)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        }));\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        const pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        (/** @type {?} */ (this._anchor.parentNode)).replaceChild(this._rootElement, this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const container = (/** @type {?} */ (this._dropContainer));\n            /** @type {?} */\n            const currentIndex = container.getItemIndex(this);\n            /** @type {?} */\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            /** @type {?} */\n            const distance = this._getDragDistance(this._getPointerPositionOnPage(event));\n            /** @type {?} */\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialContainer.getItemIndex(this),\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance\n            });\n            container.drop(this, currentIndex, this._initialContainer, isPointerOverContainer, distance);\n            this._dropContainer = this._initialContainer;\n        }));\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    _updateActiveDropContainer({ x, y }) {\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: (/** @type {?} */ (this._dropContainer)) });\n                (/** @type {?} */ (this._dropContainer)).exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = (/** @type {?} */ (newContainer));\n                this._dropContainer.enter(this, x, y);\n                this.entered.next({\n                    item: this,\n                    container: (/** @type {?} */ (newContainer)),\n                    currentIndex: (/** @type {?} */ (newContainer)).getItemIndex(this)\n                });\n            }));\n        }\n        (/** @type {?} */ (this._dropContainer))._startScrollingIfNecessary(x, y);\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    _createPreviewElement() {\n        /** @type {?} */\n        const previewConfig = this._previewTemplate;\n        /** @type {?} */\n        const previewClass = this.previewClass;\n        /** @type {?} */\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        let preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            const viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = `${elementRect.width}px`;\n            preview.style.height = `${elementRect.height}px`;\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            // We have to reset the margin, because it can throw off positioning relative to the viewport.\n            margin: '0',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        if (previewClass) {\n            if (Array.isArray(previewClass)) {\n                previewClass.forEach((/**\n                 * @param {?} className\n                 * @return {?}\n                 */\n                className => preview.classList.add(className)));\n            }\n            else {\n                preview.classList.add(previewClass);\n            }\n        }\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            resolve => {\n                /** @type {?} */\n                const handler = (/** @type {?} */ (((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }))));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                const timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            }));\n        }));\n    }\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    _createPlaceholderElement() {\n        /** @type {?} */\n        const placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        const x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        const y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getPointerPositionOnPage(event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        const point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    }\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getConstrainedPointerPosition(event) {\n        /** @type {?} */\n        const point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        const constrainedPoint = this.constrainPosition ? this.constrainPosition(point, this) : point;\n        /** @type {?} */\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            constrainedPoint.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            constrainedPoint.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            /** @type {?} */\n            const boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            const previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            const minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            const minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            constrainedPoint.x = clamp(constrainedPoint.x, minX, maxX);\n            constrainedPoint.y = clamp(constrainedPoint.y, minY, maxY);\n        }\n        return constrainedPoint;\n    }\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        /** @type {?} */\n        const delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @private\n     * @param {?} x New transform value along the X axis.\n     * @param {?} y New transform value along the Y axis.\n     * @return {?}\n     */\n    _applyRootElementTransform(x, y) {\n        /** @type {?} */\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @private\n     * @param {?} currentPosition Current position of the user's pointer.\n     * @return {?}\n     */\n    _getDragDistance(currentPosition) {\n        /** @type {?} */\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /**\n     * Cleans up any cached element dimensions that we don't need after dragging has stopped.\n     * @private\n     * @return {?}\n     */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     * @private\n     * @return {?}\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        /** @type {?} */\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        // It's possible that the element got hidden away after dragging (e.g. by switching to a\n        // different tab). Don't do anything in this case so we don't clear the user's position.\n        if ((boundaryRect.width === 0 && boundaryRect.height === 0) ||\n            (elementRect.width === 0 && elementRect.height === 0)) {\n            return;\n        }\n        /** @type {?} */\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        /** @type {?} */\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        /** @type {?} */\n        const topOverflow = boundaryRect.top - elementRect.top;\n        /** @type {?} */\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n    /**\n     * Gets the drag start delay, based on the event type.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getDragStartDelay(event) {\n        /** @type {?} */\n        const value = this.dragStartDelay;\n        if (typeof value === 'number') {\n            return value;\n        }\n        else if (isTouchEvent(event)) {\n            return value.touch;\n        }\n        return value ? value.mouse : 0;\n    }\n}\nif (false) {\n    /**\n     * Element displayed next to the user's pointer while the element is dragged.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._preview;\n    /**\n     * Reference to the view of the preview element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewRef;\n    /**\n     * Reference to the view of the placeholder element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholderRef;\n    /**\n     * Element that is rendered instead of the draggable item while it is being sorted.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholder;\n    /**\n     * Coordinates within the element at which the user picked up the element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pickupPositionInElement;\n    /**\n     * Coordinates on the page at which the user picked up the element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pickupPositionOnPage;\n    /**\n     * Anchor node used to save the place in the DOM where the element was\n     * picked up so that it can be restored at the end of the drag sequence.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._anchor;\n    /**\n     * CSS `transform` applied to the element when it isn't being dragged. We need a\n     * passive transform in order for the dragged element to retain its new position\n     * after the user has stopped dragging and because we need to know the relative\n     * position in case they start dragging again. This corresponds to `element.style.transform`.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._passiveTransform;\n    /**\n     * CSS `transform` that is applied to the element while it's being dragged.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._activeTransform;\n    /**\n     * Inline `transform` value that the element had before the first dragging sequence.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._initialTransform;\n    /**\n     * Whether the dragging sequence has been started. Doesn't\n     * necessarily mean that the element has been moved.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._hasStartedDragging;\n    /**\n     * Whether the element has moved since the user started dragging it.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._hasMoved;\n    /**\n     * Drop container in which the DragRef resided when dragging began.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._initialContainer;\n    /**\n     * Cached scroll position on the page when the element was picked up.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._scrollPosition;\n    /**\n     * Emits when the item is being moved.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._moveEvents;\n    /**\n     * Keeps track of the direction in which the user is dragging along each axis.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerDirectionDelta;\n    /**\n     * Pointer position at which the last change in the delta occurred.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerPositionAtLastDirectionChange;\n    /**\n     * Root DOM node of the drag instance. This is the element that will\n     * be moved around as the user is dragging.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._rootElement;\n    /**\n     * Inline style value of `-webkit-tap-highlight-color` at the time the\n     * dragging was started. Used to restore the value once we're done dragging.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._rootElementTapHighlight;\n    /**\n     * Subscription to pointer movement events.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerMoveSubscription;\n    /**\n     * Subscription to the event that is dispatched when the user lifts their pointer.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerUpSubscription;\n    /**\n     * Subscription to the viewport being scrolled.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._scrollSubscription;\n    /**\n     * Subscription to the viewport being resized.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._resizeSubscription;\n    /**\n     * Time at which the last touch event occurred. Used to avoid firing the same\n     * events multiple times on touch devices where the browser will fire a fake\n     * mouse event for each touch event, after a certain time.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._lastTouchEventTime;\n    /**\n     * Time at which the last dragging sequence was started.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dragStartTime;\n    /**\n     * Cached reference to the boundary element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._boundaryElement;\n    /**\n     * Whether the native dragging interactions have been enabled on the root element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._nativeInteractionsEnabled;\n    /**\n     * Cached dimensions of the preview element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewRect;\n    /**\n     * Cached dimensions of the boundary element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._boundaryRect;\n    /**\n     * Element that will be used as a template to create the draggable item's preview.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewTemplate;\n    /**\n     * Template for placeholder element rendered to show where a draggable would be dropped.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholderTemplate;\n    /**\n     * Elements that can be used to drag the draggable item.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._handles;\n    /**\n     * Registered handles that are currently disabled.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._disabledHandles;\n    /**\n     * Droppable container that the draggable is a part of.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dropContainer;\n    /**\n     * Layout direction of the item.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._direction;\n    /**\n     * Axis along which dragging is locked.\n     * @type {?}\n     */\n    DragRef.prototype.lockAxis;\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     * @type {?}\n     */\n    DragRef.prototype.dragStartDelay;\n    /**\n     * Class to be added to the preview element.\n     * @type {?}\n     */\n    DragRef.prototype.previewClass;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._disabled;\n    /**\n     * Emits as the drag sequence is being prepared.\n     * @type {?}\n     */\n    DragRef.prototype.beforeStarted;\n    /**\n     * Emits when the user starts dragging the item.\n     * @type {?}\n     */\n    DragRef.prototype.started;\n    /**\n     * Emits when the user has released a drag item, before any animations have started.\n     * @type {?}\n     */\n    DragRef.prototype.released;\n    /**\n     * Emits when the user stops dragging an item in the container.\n     * @type {?}\n     */\n    DragRef.prototype.ended;\n    /**\n     * Emits when the user has moved the item into a new container.\n     * @type {?}\n     */\n    DragRef.prototype.entered;\n    /**\n     * Emits when the user removes the item its container by dragging it into another container.\n     * @type {?}\n     */\n    DragRef.prototype.exited;\n    /**\n     * Emits when the user drops the item inside a container.\n     * @type {?}\n     */\n    DragRef.prototype.dropped;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     * @type {?}\n     */\n    DragRef.prototype.moved;\n    /**\n     * Arbitrary data that can be attached to the drag item.\n     * @type {?}\n     */\n    DragRef.prototype.data;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page and should return a point describing where the item should\n     * be rendered.\n     * @type {?}\n     */\n    DragRef.prototype.constrainPosition;\n    /**\n     * Handler for the `mousedown`/`touchstart` events.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerDown;\n    /**\n     * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerMove;\n    /**\n     * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerUp;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._config;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._viewportRuler;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dragDropRegistry;\n}\n/**\n * Point on the page or within an element.\n * @record\n */\nfunction Point() { }\nif (false) {\n    /** @type {?} */\n    Point.prototype.x;\n    /** @type {?} */\n    Point.prototype.y;\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    const clone = (/** @type {?} */ (node.cloneNode(true)));\n    /** @type {?} */\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    /** @type {?} */\n    const descendantCanvases = node.querySelectorAll('canvas');\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    // `cloneNode` won't transfer the content of `canvas` elements so we have to do it ourselves.\n    // We match up the cloned canvas to their sources using their index in the DOM.\n    if (descendantCanvases.length) {\n        /** @type {?} */\n        const cloneCanvases = clone.querySelectorAll('canvas');\n        for (let i = 0; i < descendantCanvases.length; i++) {\n            /** @type {?} */\n            const correspondingCloneContext = cloneCanvases[i].getContext('2d');\n            if (correspondingCloneContext) {\n                correspondingCloneContext.drawImage(descendantCanvases[i], 0, 0);\n            }\n        }\n    }\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove a node from the DOM and to do all the necessary null checks.\n * @param {?} node Node to be removed.\n * @return {?}\n */\nfunction removeNode(node) {\n    if (node && node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the element into which the drag preview should be inserted.\n * @param {?} documentRef\n * @return {?}\n */\nfunction getPreviewInsertionPoint(documentRef) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n * @param {?} viewRef\n * @param {?} _document\n * @return {?}\n */\nfunction getRootNode(viewRef, _document) {\n    /** @type {?} */\n    const rootNode = viewRef.rootNodes[0];\n    if (rootNode.nodeType !== _document.ELEMENT_NODE) {\n        /** @type {?} */\n        const wrapper = _document.createElement('div');\n        wrapper.appendChild(rootNode);\n        return wrapper;\n    }\n    return (/** @type {?} */ (rootNode));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    const from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    const target = array[from];\n    /** @type {?} */\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drop-list-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst AUTO_SCROLL_STEP = 2;\n/**\n * Entry in the position cache for draggable items.\n * \\@docs-private\n * @record\n */\nfunction CachedItemPosition() { }\nif (false) {\n    /**\n     * Instance of the drag item.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.drag;\n    /**\n     * Dimensions of the item.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.clientRect;\n    /**\n     * Amount by which the item has been moved since dragging started.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.offset;\n}\n/**\n * Object holding the scroll position of something.\n * @record\n */\nfunction ScrollPosition() { }\nif (false) {\n    /** @type {?} */\n    ScrollPosition.prototype.top;\n    /** @type {?} */\n    ScrollPosition.prototype.left;\n}\n/** @enum {number} */\nconst AutoScrollVerticalDirection = {\n    NONE: 0, UP: 1, DOWN: 2,\n};\n/** @enum {number} */\nconst AutoScrollHorizontalDirection = {\n    NONE: 0, LEFT: 1, RIGHT: 2,\n};\n/**\n * Internal compile-time-only representation of a `DropListRef`.\n * Used to avoid circular import issues between the `DropListRef` and the `DragRef`.\n * \\@docs-private\n * @record\n */\nfunction DropListRefInternal() { }\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * @template T\n */\nclass DropListRef {\n    /**\n     * @param {?} element\n     * @param {?} _dragDropRegistry\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     */\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Whether sorting items within the list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new Subject();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the container's scroll position.\n         */\n        this._scrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the scroll position of the viewport.\n         */\n        this._viewportScrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        /**\n         * Subscription to the window being scrolled.\n         */\n        this._viewportScrollSubscription = Subscription.EMPTY;\n        /**\n         * Vertical direction in which the list is currently scrolling.\n         */\n        this._verticalScrollDirection = 0 /* NONE */;\n        /**\n         * Horizontal direction in which the list is currently scrolling.\n         */\n        this._horizontalScrollDirection = 0 /* NONE */;\n        /**\n         * Used to signal to the current auto-scroll sequence when to stop.\n         */\n        this._stopScrollTimers = new Subject();\n        /**\n         * Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly.\n         */\n        this._cachedShadowRoot = null;\n        /**\n         * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n         */\n        this._handleScroll = (/**\n         * @return {?}\n         */\n        () => {\n            if (!this.isDragging()) {\n                return;\n            }\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            this._updateAfterScroll(this._scrollPosition, element.scrollTop, element.scrollLeft);\n        });\n        /**\n         * Starts the interval that'll auto-scroll the element.\n         */\n        this._startScrollInterval = (/**\n         * @return {?}\n         */\n        () => {\n            this._stopScrolling();\n            interval(0, animationFrameScheduler)\n                .pipe(takeUntil(this._stopScrollTimers))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const node = this._scrollNode;\n                if (this._verticalScrollDirection === 1 /* UP */) {\n                    incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._verticalScrollDirection === 2 /* DOWN */) {\n                    incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n                }\n                if (this._horizontalScrollDirection === 1 /* LEFT */) {\n                    incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._horizontalScrollDirection === 2 /* RIGHT */) {\n                    incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n                }\n            }));\n        });\n        this.element = coerceElement(element);\n        this._document = _document;\n        _dragDropRegistry.registerDropContainer(this);\n    }\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._removeListeners();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = (/** @type {?} */ (null));\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._isDragging;\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._cacheItems();\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._startReceiving(this)));\n        this._removeListeners();\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => element.addEventListener('scroll', this._handleScroll)));\n        this._listenToScrollEvents();\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        /** @type {?} */\n        let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n        if (newIndex === -1) {\n            // We use the coordinates of where the item entered the drop\n            // zone to figure out at which index it should be inserted.\n            newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        }\n        /** @type {?} */\n        const activeDraggables = this._activeDraggables;\n        /** @type {?} */\n        const currentIndex = activeDraggables.indexOf(item);\n        /** @type {?} */\n        const placeholder = item.getPlaceholderElement();\n        /** @type {?} */\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            const element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            coerceElement(this.element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param {?} distance Distance the user has dragged since the start of the dragging sequence.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer, distance) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    withItems(items) {\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item._withDropContainer((/** @type {?} */ (this)))));\n        if ((/** @type {?} */ (this)).isDragging()) {\n            (/** @type {?} */ (this))._cacheItems();\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    connectedTo(connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    withOrientation(orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        const siblings = this._itemPositions;\n        /** @type {?} */\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentIndex = findIndex(siblings, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n        /** @type {?} */\n        const siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        const delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((/**\n         * @param {?} sibling\n         * @param {?} index\n         * @return {?}\n         */\n        (sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            const isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        }));\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param {?} pointerX User's pointer position along the x axis.\n     * @param {?} pointerY User's pointer position along the y axis.\n     * @return {?}\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        /** @type {?} */\n        let scrollNode;\n        /** @type {?} */\n        let verticalScrollDirection = 0 /* NONE */;\n        /** @type {?} */\n        let horizontalScrollDirection = 0 /* NONE */;\n        // Check whether we should start scrolling the container.\n        if (this._isPointerNearDropContainer(pointerX, pointerY)) {\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            [verticalScrollDirection, horizontalScrollDirection] =\n                getElementScrollDirections(element, this._clientRect, pointerX, pointerY);\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                scrollNode = element;\n            }\n        }\n        // Otherwise check if we can start scrolling the viewport.\n        if (!verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            /** @type {?} */\n            const clientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n            horizontalScrollDirection !== this._horizontalScrollDirection ||\n            scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                this._ngZone.runOutsideAngular(this._startScrollInterval);\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /**\n     * Stops any currently-running auto-scroll sequences.\n     * @return {?}\n     */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    _cacheOwnPosition() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this._clientRect = getMutableClientRect(element);\n        this._scrollPosition = { top: element.scrollTop, left: element.scrollLeft };\n    }\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    _cacheItemPositions() {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map((/**\n         * @param {?} drag\n         * @return {?}\n         */\n        drag => {\n            /** @type {?} */\n            const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            return { drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure) };\n        })).sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        }));\n    }\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    _reset() {\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item.getRootElement().style.transform = ''));\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._stopReceiving(this)));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._stopScrolling();\n        this._removeListeners();\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            const start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    _isPointerNearDropContainer(pointerX, pointerY) {\n        const { top, right, bottom, left, width, height } = this._clientRect;\n        /** @type {?} */\n        const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, (/**\n         * @param {?} __0\n         * @param {?} _\n         * @param {?} array\n         * @return {?}\n         */\n        ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        }));\n    }\n    /**\n     * Caches the current items in the list and their positions.\n     * @private\n     * @return {?}\n     */\n    _cacheItems() {\n        this._activeDraggables = this._draggables.slice();\n        this._cacheItemPositions();\n        this._cacheOwnPosition();\n    }\n    /**\n     * Updates the internal state of the container after a scroll event has happened.\n     * @private\n     * @param {?} scrollPosition Object that is keeping track of the scroll position.\n     * @param {?} newTop New top scroll position.\n     * @param {?} newLeft New left scroll position.\n     * @param {?=} extraClientRect Extra `ClientRect` object that should be updated, in addition to the\n     *  ones of the drag items. Useful when the viewport has been scrolled and we also need to update\n     *  the `ClientRect` of the list.\n     * @return {?}\n     */\n    _updateAfterScroll(scrollPosition, newTop, newLeft, extraClientRect) {\n        /** @type {?} */\n        const topDifference = scrollPosition.top - newTop;\n        /** @type {?} */\n        const leftDifference = scrollPosition.left - newLeft;\n        if (extraClientRect) {\n            adjustClientRect(extraClientRect, topDifference, leftDifference);\n        }\n        // Since we know the amount that the user has scrolled we can shift all of the client rectangles\n        // ourselves. This is cheaper than re-measuring everything and we can avoid inconsistent\n        // behavior where we might be measuring the element before its position has changed.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        }));\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        }));\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n    }\n    /**\n     * Removes the event listeners associated with this drop list.\n     * @private\n     * @return {?}\n     */\n    _removeListeners() {\n        coerceElement(this.element).removeEventListener('scroll', this._handleScroll);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._canReceive(item, x, y)));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _canReceive(item, x, y) {\n        if (!isInsideClientRect(this._clientRect, x, y) || !this.enterPredicate(item, this)) {\n            return false;\n        }\n        /** @type {?} */\n        const elementFromPoint = (/** @type {?} */ (this._getShadowRoot().elementFromPoint(x, y)));\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        /** @type {?} */\n        const nativeElement = coerceElement(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    _startReceiving(sibling) {\n        /** @type {?} */\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     * @private\n     * @return {?}\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n        this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (this.isDragging()) {\n                /** @type {?} */\n                const newPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n                this._updateAfterScroll(this._viewportScrollPosition, newPosition.top, newPosition.left, this._clientRect);\n            }\n            else if (this.isReceiving()) {\n                this._cacheOwnPosition();\n            }\n        }));\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     * @private\n     * @return {?}\n     */\n    _getShadowRoot() {\n        if (!this._cachedShadowRoot) {\n            this._cachedShadowRoot = getShadowRoot(coerceElement(this.element)) || this._document;\n        }\n        return this._cachedShadowRoot;\n    }\n}\nif (false) {\n    /**\n     * Element that the drop list is attached to.\n     * @type {?}\n     */\n    DropListRef.prototype.element;\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.disabled;\n    /**\n     * Whether sorting items within the list is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.sortingDisabled;\n    /**\n     * Locks the position of the draggable elements inside the container along the specified axis.\n     * @type {?}\n     */\n    DropListRef.prototype.lockAxis;\n    /**\n     * Whether auto-scrolling the view when the user\n     * moves their pointer close to the edges is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.autoScrollDisabled;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     * @type {?}\n     */\n    DropListRef.prototype.enterPredicate;\n    /**\n     * Emits right before dragging has started.\n     * @type {?}\n     */\n    DropListRef.prototype.beforeStarted;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     * @type {?}\n     */\n    DropListRef.prototype.entered;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     * @type {?}\n     */\n    DropListRef.prototype.exited;\n    /**\n     * Emits when the user drops an item inside the container.\n     * @type {?}\n     */\n    DropListRef.prototype.dropped;\n    /**\n     * Emits as the user is swapping items while actively dragging.\n     * @type {?}\n     */\n    DropListRef.prototype.sorted;\n    /**\n     * Arbitrary data that can be attached to the drop list.\n     * @type {?}\n     */\n    DropListRef.prototype.data;\n    /**\n     * Whether an item in the list is being dragged.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._isDragging;\n    /**\n     * Cache of the dimensions of all the items inside the container.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._itemPositions;\n    /**\n     * Keeps track of the container's scroll position.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._scrollPosition;\n    /**\n     * Keeps track of the scroll position of the viewport.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportScrollPosition;\n    /**\n     * Cached `ClientRect` of the drop list.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._clientRect;\n    /**\n     * Draggable items that are currently active inside the container. Includes the items\n     * from `_draggables`, as well as any items that have been dragged in, but haven't\n     * been dropped yet.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._activeDraggables;\n    /**\n     * Keeps track of the item that was last swapped with the dragged item, as\n     * well as what direction the pointer was moving in when the swap occured.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._previousSwap;\n    /**\n     * Draggable items in the container.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._draggables;\n    /**\n     * Drop lists that are connected to the current one.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._siblings;\n    /**\n     * Direction in which the list is oriented.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._orientation;\n    /**\n     * Connected siblings that currently have a dragged item.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._activeSiblings;\n    /**\n     * Layout direction of the drop list.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._direction;\n    /**\n     * Subscription to the window being scrolled.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportScrollSubscription;\n    /**\n     * Vertical direction in which the list is currently scrolling.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._verticalScrollDirection;\n    /**\n     * Horizontal direction in which the list is currently scrolling.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._horizontalScrollDirection;\n    /**\n     * Node that is being auto-scrolled.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._scrollNode;\n    /**\n     * Used to signal to the current auto-scroll sequence when to stop.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._stopScrollTimers;\n    /**\n     * Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._cachedShadowRoot;\n    /**\n     * Reference to the document.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._document;\n    /**\n     * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._handleScroll;\n    /**\n     * Starts the interval that'll auto-scroll the element.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._startScrollInterval;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._dragDropRegistry;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportRuler;\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Gets a mutable version of an element's bounding `ClientRect`.\n * @param {?} element\n * @return {?}\n */\nfunction getMutableClientRect(element) {\n    /** @type {?} */\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height\n    };\n}\n/**\n * Increments the vertical scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementVerticalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(0, amount);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollTop += amount;\n    }\n}\n/**\n * Increments the horizontal scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementHorizontalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(amount, 0);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollLeft += amount;\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    /** @type {?} */\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* DOWN */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @return {?}\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    /** @type {?} */\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* RIGHT */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param {?} element Element for which we should calculate the scroll direction.\n * @param {?} clientRect Bounding client rectangle of the element.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    /** @type {?} */\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    /** @type {?} */\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    /** @type {?} */\n    let verticalScrollDirection = 0 /* NONE */;\n    /** @type {?} */\n    let horizontalScrollDirection = 0 /* NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        /** @type {?} */\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        /** @type {?} */\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n/**\n * Gets the shadow root of an element, if any.\n * @param {?} element\n * @return {?}\n */\nfunction getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        /** @type {?} */\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        if (rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop-registry.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _document\n     */\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         */\n        this.scroll = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        });\n        this._document = _document;\n    }\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            this._dropInstances.add(drop);\n        }\n    }\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            }));\n        }\n    }\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.has(drag)) {\n            return;\n        }\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            const isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            const moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            const upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerMove.next((/** @type {?} */ (e)))),\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerUp.next((/** @type {?} */ (e)))),\n                options: true\n            })\n                .set('scroll', {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.scroll.next(e)),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._globalListeners.forEach((/**\n                 * @param {?} config\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                }));\n            }));\n        }\n    }\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    stopDragging(drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    }\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    isDragging(drag) {\n        return this._activeDragInstances.has(drag);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dragInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDragItem(instance)));\n        this._dropInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDropContainer(instance)));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((/**\n         * @param {?} config\n         * @param {?} name\n         * @return {?}\n         */\n        (config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        }));\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nDragDropRegistry.ctorParameters = () => [\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ DragDropRegistry.Éµprov = ÉµÉµdefineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(ÉµÉµinject(NgZone), ÉµÉµinject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._document;\n    /**\n     * Registered drop container instances.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._dropInstances;\n    /**\n     * Registered drag item instances.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._dragInstances;\n    /**\n     * Drag item instances that are currently being dragged.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._activeDragInstances;\n    /**\n     * Keeps track of the event listeners that we've bound to the `document`.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._globalListeners;\n    /**\n     * Emits the `touchmove` or `mousemove` events that are dispatched\n     * while the user is dragging a drag item instance.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.pointerMove;\n    /**\n     * Emits the `touchend` or `mouseup` events that are dispatched\n     * while the user is dragging a drag item instance.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.pointerUp;\n    /**\n     * Emits when the viewport has been scrolled while the user is dragging an item.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.scroll;\n    /**\n     * Event listener that will prevent the default browser action while the user is dragging.\n     * \\@param event Event whose default action should be prevented.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._preventDefaultWhileDragging;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    /**\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n}\nDragDrop.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nDragDrop.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewportRuler },\n    { type: DragDropRegistry }\n];\n/** @nocollapse */ DragDrop.Éµprov = ÉµÉµdefineInjectable({ factory: function DragDrop_Factory() { return new DragDrop(ÉµÉµinject(DOCUMENT), ÉµÉµinject(NgZone), ÉµÉµinject(ViewportRuler), ÉµÉµinject(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._viewportRuler;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._dragDropRegistry;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-events.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Event emitted when the user starts dragging a draggable.\n * @record\n * @template T\n */\nfunction CdkDragStart() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragStart.prototype.source;\n}\n/**\n * Event emitted when the user releases an item, before any animations have started.\n * @record\n * @template T\n */\nfunction CdkDragRelease() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragRelease.prototype.source;\n}\n/**\n * Event emitted when the user stops dragging a draggable.\n * @record\n * @template T\n */\nfunction CdkDragEnd() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragEnd.prototype.source;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragEnd.prototype.distance;\n}\n/**\n * Event emitted when the user moves an item into a new drop container.\n * @record\n * @template T, I\n */\nfunction CdkDragEnter() { }\nif (false) {\n    /**\n     * Container into which the user has moved the item.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.container;\n    /**\n     * Item that was moved into the container.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.item;\n    /**\n     * Index at which the item has entered the container.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.currentIndex;\n}\n/**\n * Event emitted when the user removes an item from a\n * drop container by moving it into another one.\n * @record\n * @template T, I\n */\nfunction CdkDragExit() { }\nif (false) {\n    /**\n     * Container from which the user has a removed an item.\n     * @type {?}\n     */\n    CdkDragExit.prototype.container;\n    /**\n     * Item that was removed from the container.\n     * @type {?}\n     */\n    CdkDragExit.prototype.item;\n}\n/**\n * Event emitted when the user drops a draggable item inside a drop container.\n * @record\n * @template T, O\n */\nfunction CdkDragDrop() { }\nif (false) {\n    /**\n     * Index of the item when it was picked up.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.previousIndex;\n    /**\n     * Current index of the item.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.currentIndex;\n    /**\n     * Item that is being dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.item;\n    /**\n     * Container in which the item was dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.container;\n    /**\n     * Container from which the item was picked up. Can be the same as the `container`.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.previousContainer;\n    /**\n     * Whether the user's pointer was over the container when the item was dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.isPointerOverContainer;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.distance;\n}\n/**\n * Event emitted as the user is dragging a draggable item.\n * @record\n * @template T\n */\nfunction CdkDragMove() { }\nif (false) {\n    /**\n     * Item that is being dragged.\n     * @type {?}\n     */\n    CdkDragMove.prototype.source;\n    /**\n     * Position of the user's pointer on the page.\n     * @type {?}\n     */\n    CdkDragMove.prototype.pointerPosition;\n    /**\n     * Native event that is causing the dragging.\n     * @type {?}\n     */\n    CdkDragMove.prototype.event;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragMove.prototype.distance;\n    /**\n     * Indicates the direction in which the user is dragging the element along each axis.\n     * `1` means that the position is increasing (e.g. the user is moving to the right or downwards),\n     * whereas `-1` means that it's decreasing (they're moving to the left or upwards). `0` means\n     * that the position hasn't changed.\n     * @type {?}\n     */\n    CdkDragMove.prototype.delta;\n}\n/**\n * Event emitted when the user swaps the position of two drag items.\n * @record\n * @template T, I\n */\nfunction CdkDragSortEvent() { }\nif (false) {\n    /**\n     * Index from which the item was sorted previously.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.previousIndex;\n    /**\n     * Index that the item is currently in.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.currentIndex;\n    /**\n     * Container that the item belongs to.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.container;\n    /**\n     * Item that is being sorted.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.item;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-parent.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-handle.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nclass CdkDragHandle {\n    /**\n     * @param {?} element\n     * @param {?=} parentDrag\n     */\n    constructor(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    /**\n     * Whether starting to drag through this handle is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._stateChanges.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDragHandle]',\n                host: {\n                    'class': 'cdk-drag-handle'\n                }\n            },] }\n];\n/** @nocollapse */\nCdkDragHandle.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_PARENT,] }, { type: Optional }] }\n];\nCdkDragHandle.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDragHandleDisabled',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDragHandle.ngAcceptInputType_disabled;\n    /**\n     * Closest parent draggable instance.\n     * @type {?}\n     */\n    CdkDragHandle.prototype._parentDrag;\n    /**\n     * Emits when the state of the handle has changed.\n     * @type {?}\n     */\n    CdkDragHandle.prototype._stateChanges;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDragHandle.prototype._disabled;\n    /** @type {?} */\n    CdkDragHandle.prototype.element;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-placeholder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nclass CdkDragPlaceholder {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPlaceholder]'\n            },] }\n];\n/** @nocollapse */\nCdkDragPlaceholder.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPlaceholder.propDecorators = {\n    data: [{ type: Input }]\n};\nif (false) {\n    /**\n     * Context data to be added to the placeholder template instance.\n     * @type {?}\n     */\n    CdkDragPlaceholder.prototype.data;\n    /** @type {?} */\n    CdkDragPlaceholder.prototype.templateRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-preview.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nclass CdkDragPreview {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPreview.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPreview]'\n            },] }\n];\n/** @nocollapse */\nCdkDragPreview.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPreview.propDecorators = {\n    data: [{ type: Input }]\n};\nif (false) {\n    /**\n     * Context data to be added to the preview template instance.\n     * @type {?}\n     */\n    CdkDragPreview.prototype.data;\n    /** @type {?} */\n    CdkDragPreview.prototype.templateRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nconst CDK_DROP_LIST = new InjectionToken('CDK_DROP_LIST');\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nclass CdkDrag {\n    /**\n     * @param {?} element\n     * @param {?} dropContainer\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} config\n     * @param {?} _dir\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     */\n    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new Subject();\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._dragRef.moved.pipe(map((/**\n             * @param {?} movedEvent\n             * @return {?}\n             */\n            movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance\n            })))).subscribe(observer);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n            });\n        }));\n        this._dragRef = dragDrop.createDrag(element, config);\n        this._dragRef.data = this;\n        // Note that usually the container is assigned when the drop list is picks up the item, but in\n        // some cases (mainly transplanted views with OnPush, see #18341) we may end up in a situation\n        // where there are no items on the first change detection pass, but the items get picked up as\n        // soon as the user triggers another pass by dragging. This is a problem, because the item would\n        // have to switch from standalone mode to drag mode in the middle of the dragging sequence which\n        // is too late since the two modes save different kinds of information. We work around it by\n        // assigning the drop container both from here and the list.\n        if (dropContainer) {\n            this._dragRef._withDropContainer(dropContainer._dropListRef);\n        }\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(take(1), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._updateRootElement();\n            // Listen for any newly-added handles.\n            this._handles.changes.pipe(startWith(this._handles), \n            // Sync the new handles with the DragRef.\n            tap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                /** @type {?} */\n                const childHandleElements = handles\n                    .filter((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle._parentDrag === this))\n                    .map((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle.element));\n                this._dragRef.withHandles(childHandleElements);\n            })), \n            // Listen if the state of any of the handles changes.\n            switchMap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                return (/** @type {?} */ (merge(...handles.map((/**\n                 * @param {?} item\n                 * @return {?}\n                 */\n                item => {\n                    return item._stateChanges.pipe(startWith(item));\n                })))));\n            })), takeUntil(this._destroyed)).subscribe((/**\n             * @param {?} handleInstance\n             * @return {?}\n             */\n            handleInstance => {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                const dragRef = this._dragRef;\n                /** @type {?} */\n                const handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            }));\n            if (this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        /** @type {?} */\n        const rootSelectorChange = changes['rootElementSelector'];\n        /** @type {?} */\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    }\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    _updateRootElement() {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        /** @type {?} */\n        const rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(`cdkDrag must be attached to an element node. ` +\n                `Currently attached to \"${rootElement.nodeName}\".`);\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /**\n     * Gets the boundary element, based on the `boundaryElement` value.\n     * @private\n     * @return {?}\n     */\n    _getBoundaryElement() {\n        /** @type {?} */\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return getClosestMatchingAncestor(this.element.nativeElement, boundary);\n        }\n        /** @type {?} */\n        const element = coerceElement(boundary);\n        if (isDevMode() && !element.contains(this.element.nativeElement)) {\n            throw Error('Draggable element is not inside of the node passed into cdkDragBoundary.');\n        }\n        return element;\n    }\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                const dir = this._dir;\n                /** @type {?} */\n                const dragStartDelay = this.dragStartDelay;\n                /** @type {?} */\n                const placeholder = this._placeholderTemplate ? {\n                    template: this._placeholderTemplate.templateRef,\n                    context: this._placeholderTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                const preview = this._previewTemplate ? {\n                    template: this._previewTemplate.templateRef,\n                    context: this._previewTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay = (typeof dragStartDelay === 'object' && dragStartDelay) ?\n                    dragStartDelay : coerceNumberProperty(dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref.previewClass = this.previewClass;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        }));\n    }\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.started.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.started.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.released.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.released.emit({ source: this });\n        }));\n        ref.ended.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.ended.emit({ source: this, distance: event.distance });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: event.container.data,\n                item: this,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: this,\n                distance: event.distance\n            });\n        }));\n    }\n}\nCdkDrag.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDrag]',\n                exportAs: 'cdkDrag',\n                host: {\n                    'class': 'cdk-drag',\n                    '[class.cdk-drag-disabled]': 'disabled',\n                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                },\n                providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n            },] }\n];\n/** @nocollapse */\nCdkDrag.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: DragDrop },\n    { type: ChangeDetectorRef }\n];\nCdkDrag.propDecorators = {\n    _handles: [{ type: ContentChildren, args: [CdkDragHandle, { descendants: true },] }],\n    _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview,] }],\n    _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder,] }],\n    data: [{ type: Input, args: ['cdkDragData',] }],\n    lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n    rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n    boundaryElement: [{ type: Input, args: ['cdkDragBoundary',] }],\n    dragStartDelay: [{ type: Input, args: ['cdkDragStartDelay',] }],\n    freeDragPosition: [{ type: Input, args: ['cdkDragFreeDragPosition',] }],\n    disabled: [{ type: Input, args: ['cdkDragDisabled',] }],\n    constrainPosition: [{ type: Input, args: ['cdkDragConstrainPosition',] }],\n    previewClass: [{ type: Input, args: ['cdkDragPreviewClass',] }],\n    started: [{ type: Output, args: ['cdkDragStarted',] }],\n    released: [{ type: Output, args: ['cdkDragReleased',] }],\n    ended: [{ type: Output, args: ['cdkDragEnded',] }],\n    entered: [{ type: Output, args: ['cdkDragEntered',] }],\n    exited: [{ type: Output, args: ['cdkDragExited',] }],\n    dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n    moved: [{ type: Output, args: ['cdkDragMoved',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDrag.ngAcceptInputType_disabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._destroyed;\n    /**\n     * Reference to the underlying drag instance.\n     * @type {?}\n     */\n    CdkDrag.prototype._dragRef;\n    /**\n     * Elements that can be used to drag the draggable item.\n     * @type {?}\n     */\n    CdkDrag.prototype._handles;\n    /**\n     * Element that will be used as a template to create the draggable item's preview.\n     * @type {?}\n     */\n    CdkDrag.prototype._previewTemplate;\n    /**\n     * Template for placeholder element rendered to show where a draggable would be dropped.\n     * @type {?}\n     */\n    CdkDrag.prototype._placeholderTemplate;\n    /**\n     * Arbitrary data to attach to this drag instance.\n     * @type {?}\n     */\n    CdkDrag.prototype.data;\n    /**\n     * Locks the position of the dragged element along the specified axis.\n     * @type {?}\n     */\n    CdkDrag.prototype.lockAxis;\n    /**\n     * Selector that will be used to determine the root draggable element, starting from\n     * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful\n     * when trying to enable dragging on an element that you might not have access to.\n     * @type {?}\n     */\n    CdkDrag.prototype.rootElementSelector;\n    /**\n     * Node or selector that will be used to determine the element to which the draggable's\n     * position will be constrained. If a string is passed in, it'll be used as a selector that\n     * will be matched starting from the element's parent and going up the DOM until a match\n     * has been found.\n     * @type {?}\n     */\n    CdkDrag.prototype.boundaryElement;\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     * @type {?}\n     */\n    CdkDrag.prototype.dragStartDelay;\n    /**\n     * Sets the position of a `CdkDrag` that is outside of a drop container.\n     * Can be used to restore the element's position for a returning user.\n     * @type {?}\n     */\n    CdkDrag.prototype.freeDragPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._disabled;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page and should return a point describing where the item should\n     * be rendered.\n     * @type {?}\n     */\n    CdkDrag.prototype.constrainPosition;\n    /**\n     * Class to be added to the preview element.\n     * @type {?}\n     */\n    CdkDrag.prototype.previewClass;\n    /**\n     * Emits when the user starts dragging the item.\n     * @type {?}\n     */\n    CdkDrag.prototype.started;\n    /**\n     * Emits when the user has released a drag item, before any animations have started.\n     * @type {?}\n     */\n    CdkDrag.prototype.released;\n    /**\n     * Emits when the user stops dragging an item in the container.\n     * @type {?}\n     */\n    CdkDrag.prototype.ended;\n    /**\n     * Emits when the user has moved the item into a new container.\n     * @type {?}\n     */\n    CdkDrag.prototype.entered;\n    /**\n     * Emits when the user removes the item its container by dragging it into another container.\n     * @type {?}\n     */\n    CdkDrag.prototype.exited;\n    /**\n     * Emits when the user drops the item inside a container.\n     * @type {?}\n     */\n    CdkDrag.prototype.dropped;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     * @type {?}\n     */\n    CdkDrag.prototype.moved;\n    /**\n     * Element that the draggable is attached to.\n     * @type {?}\n     */\n    CdkDrag.prototype.element;\n    /**\n     * Droppable container that the draggable is a part of.\n     * @type {?}\n     */\n    CdkDrag.prototype.dropContainer;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._changeDetectorRef;\n}\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    let currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drop-list-group.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nclass CdkDropListGroup {\n    constructor() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /**\n     * Whether starting a dragging sequence from inside this group is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropListGroup]',\n                exportAs: 'cdkDropListGroup',\n            },] }\n];\nCdkDropListGroup.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDropListGroupDisabled',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDropListGroup.ngAcceptInputType_disabled;\n    /**\n     * Drop lists registered inside the group.\n     * @type {?}\n     */\n    CdkDropListGroup.prototype._items;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropListGroup.prototype._disabled;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drop-list.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nlet _uniqueIdCounter = 0;\n/**\n * Internal compile-time-only representation of a `CdkDropList`.\n * Used to avoid circular import issues between the `CdkDropList` and the `CdkDrag`.\n * \\@docs-private\n * @record\n */\nfunction CdkDropListInternal() { }\nconst Éµ0 = undefined;\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nclass CdkDropList {\n    /**\n     * @param {?} element\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     * @param {?=} _dir\n     * @param {?=} _group\n     */\n    constructor(element, dragDrop, _changeDetectorRef, _dir, _group) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter++}`;\n        this._disabled = false;\n        /**\n         * Whether sorting within this drop list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new EventEmitter();\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = (/**\n         * @param {?} drag\n         * @param {?} drop\n         * @return {?}\n         */\n        (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        });\n        this._setupInputSyncSubscription(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        // Usually we sync the directive and ref state right before dragging starts, in order to have\n        // a single point of failure and to avoid having to use setters for everything. `disabled` is\n        // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n        // the user in a disabled state, so we also need to sync it as it's being set.\n        this._dropListRef.disabled = this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._draggables.changes\n            .pipe(startWith(this._draggables), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._dropListRef.withItems(items.reduce((/**\n             * @param {?} filteredItems\n             * @param {?} drag\n             * @return {?}\n             */\n            (filteredItems, drag) => {\n                if (drag.dropContainer === this) {\n                    filteredItems.push(drag._dragRef);\n                }\n                return filteredItems;\n            }), (/** @type {?} */ ([]))));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Starts dragging an item.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @return {?}\n     */\n    start() {\n        this._dropListRef.start();\n    }\n    /**\n     * Drops an item into this container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     *\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, previousContainer._dropListRef, isPointerOverContainer, { x: 0, y: 0 });\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._dropListRef.exit(item._dragRef);\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    }\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _setupInputSyncSubscription(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe((/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => ref.withDirection(value)));\n        }\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const siblings = coerceArray(this.connectedTo).map((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find((/**\n                     * @param {?} list\n                     * @return {?}\n                     */\n                    list => list.id === drop)))) : drop;\n            }));\n            if (this._group) {\n                this._group._items.forEach((/**\n                 * @param {?} drop\n                 * @return {?}\n                 */\n                drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                }));\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = coerceBooleanProperty(this.sortingDisabled);\n            ref.autoScrollDisabled = coerceBooleanProperty(this.autoScrollDisabled);\n            ref\n                .connectedTo(siblings.filter((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => drop && drop !== this)).map((/**\n             * @param {?} list\n             * @return {?}\n             */\n            list => list._dropListRef)))\n                .withOrientation(this.orientation);\n        }));\n    }\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data\n            });\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.sorted.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                distance: event.distance\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        }));\n    }\n}\n/**\n * Keeps track of the drop lists that are currently on the page.\n */\nCdkDropList._dropLists = [];\nCdkDropList.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropList], cdk-drop-list',\n                exportAs: 'cdkDropList',\n                providers: [\n                    // Prevent child drop lists from picking up the same group as their parent.\n                    { provide: CdkDropListGroup, useValue: Éµ0 },\n                    { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n                ],\n                host: {\n                    'class': 'cdk-drop-list',\n                    '[id]': 'id',\n                    '[class.cdk-drop-list-disabled]': 'disabled',\n                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                }\n            },] }\n];\n/** @nocollapse */\nCdkDropList.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragDrop },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\nCdkDropList.propDecorators = {\n    _draggables: [{ type: ContentChildren, args: [CdkDrag, { descendants: true },] }],\n    connectedTo: [{ type: Input, args: ['cdkDropListConnectedTo',] }],\n    data: [{ type: Input, args: ['cdkDropListData',] }],\n    orientation: [{ type: Input, args: ['cdkDropListOrientation',] }],\n    id: [{ type: Input }],\n    lockAxis: [{ type: Input, args: ['cdkDropListLockAxis',] }],\n    disabled: [{ type: Input, args: ['cdkDropListDisabled',] }],\n    sortingDisabled: [{ type: Input, args: ['cdkDropListSortingDisabled',] }],\n    enterPredicate: [{ type: Input, args: ['cdkDropListEnterPredicate',] }],\n    autoScrollDisabled: [{ type: Input, args: ['cdkDropListAutoScrollDisabled',] }],\n    dropped: [{ type: Output, args: ['cdkDropListDropped',] }],\n    entered: [{ type: Output, args: ['cdkDropListEntered',] }],\n    exited: [{ type: Output, args: ['cdkDropListExited',] }],\n    sorted: [{ type: Output, args: ['cdkDropListSorted',] }]\n};\nif (false) {\n    /**\n     * Keeps track of the drop lists that are currently on the page.\n     * @type {?}\n     * @private\n     */\n    CdkDropList._dropLists;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_disabled;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_sortingDisabled;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_autoScrollDisabled;\n    /**\n     * Emits when the list has been destroyed.\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._destroyed;\n    /**\n     * Reference to the underlying drop list instance.\n     * @type {?}\n     */\n    CdkDropList.prototype._dropListRef;\n    /**\n     * Draggable items in the container.\n     * @type {?}\n     */\n    CdkDropList.prototype._draggables;\n    /**\n     * Other draggable containers that this container is connected to and into which the\n     * container's items can be transferred. Can either be references to other drop containers,\n     * or their unique IDs.\n     * @type {?}\n     */\n    CdkDropList.prototype.connectedTo;\n    /**\n     * Arbitrary data to attach to this container.\n     * @type {?}\n     */\n    CdkDropList.prototype.data;\n    /**\n     * Direction in which the list is oriented.\n     * @type {?}\n     */\n    CdkDropList.prototype.orientation;\n    /**\n     * Unique ID for the drop zone. Can be used as a reference\n     * in the `connectedTo` of another `CdkDropList`.\n     * @type {?}\n     */\n    CdkDropList.prototype.id;\n    /**\n     * Locks the position of the draggable elements inside the container along the specified axis.\n     * @type {?}\n     */\n    CdkDropList.prototype.lockAxis;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._disabled;\n    /**\n     * Whether sorting within this drop list is disabled.\n     * @type {?}\n     */\n    CdkDropList.prototype.sortingDisabled;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     * @type {?}\n     */\n    CdkDropList.prototype.enterPredicate;\n    /**\n     * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n     * @type {?}\n     */\n    CdkDropList.prototype.autoScrollDisabled;\n    /**\n     * Emits when the user drops an item inside the container.\n     * @type {?}\n     */\n    CdkDropList.prototype.dropped;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     * @type {?}\n     */\n    CdkDropList.prototype.entered;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     * @type {?}\n     */\n    CdkDropList.prototype.exited;\n    /**\n     * Emits as the user is swapping items while actively dragging.\n     * @type {?}\n     */\n    CdkDropList.prototype.sorted;\n    /**\n     * Element that the drop list is attached to.\n     * @type {?}\n     */\n    CdkDropList.prototype.element;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._group;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragDropModule {\n}\nDragDropModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                exports: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                providers: [\n                    DragDrop,\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_DRAG_CONFIG, CDK_DRAG_CONFIG_FACTORY, CDK_DROP_LIST, CdkDrag, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropList, CdkDropListGroup, DragDrop, DragDropModule, DragDropRegistry, DragRef, DropListRef, copyArrayItem, moveItemInArray, transferArrayItem, CDK_DRAG_PARENT as Éµangular_material_src_cdk_drag_drop_drag_drop_b };\n//# sourceMappingURL=drag-drop.js.map\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { SectionHeaderComponent } from './section-header.component';\r\nimport { MatSelectModule } from '@angular/material/select';\r\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\r\nimport { MatDatepickerModule } from '@angular/material/datepicker';\r\nimport { MatMomentDateModule } from '@angular/material-moment-adapter';\r\nimport { MatFormFieldModule } from '@angular/material/form-field';\r\nimport { MatInputModule } from '@angular/material/input';\r\nimport { MatIconModule } from '@angular/material/icon';\r\nimport { RouterModule } from '@angular/router';\r\n\r\n@NgModule({\r\n  declarations: [SectionHeaderComponent],\r\n  imports: [\r\n    CommonModule,\r\n    MatSelectModule,\r\n    FormsModule,\r\n    ReactiveFormsModule,\r\n    MatDatepickerModule,\r\n    MatMomentDateModule,\r\n    MatFormFieldModule,\r\n    MatInputModule,\r\n    MatIconModule,\r\n    RouterModule,\r\n  ],\r\n  exports: [SectionHeaderComponent, MatInputModule, MatFormFieldModule],\r\n})\r\nexport class SectionHeaderModule {}\r\n","import { CdkAccordionItem, CdkAccordion, CdkAccordionModule } from '@angular/cdk/accordion';\nimport { TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { InjectionToken, Directive, TemplateRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, SkipSelf, Inject, ChangeDetectorRef, ViewContainerRef, Input, Output, ContentChild, ViewChild, Host, ElementRef, QueryList, ContentChildren, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';\nimport { ENTER, hasModifierKey, SPACE, HOME, END } from '@angular/cdk/keycodes';\nimport { distinctUntilChanged, startWith, filter, take } from 'rxjs/operators';\nimport { Subject, Subscription, EMPTY, merge } from 'rxjs';\nimport { trigger, state, style, transition, animate, group, query, animateChild } from '@angular/animations';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/accordion-base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Base interface for a `MatAccordion`.\n * \\@docs-private\n * @record\n */\nfunction MatAccordionBase() { }\nif (false) {\n    /**\n     * Whether the expansion indicator should be hidden.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.hideToggle;\n    /**\n     * Display mode used for all expansion panels in the accordion.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.displayMode;\n    /**\n     * The position of the expansion indicator.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.togglePosition;\n    /**\n     * Handles keyboard events coming in from the panel headers.\n     * @type {?}\n     */\n    MatAccordionBase.prototype._handleHeaderKeydown;\n    /**\n     * Handles focus events on the panel headers.\n     * @type {?}\n     */\n    MatAccordionBase.prototype._handleHeaderFocus;\n}\n/**\n * Token used to provide a `MatAccordion` to `MatExpansionPanel`.\n * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.\n * @type {?}\n */\nconst MAT_ACCORDION = new InjectionToken('MAT_ACCORDION');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-animations.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Time and timing curve for expansion panel animations.\n * @type {?}\n */\nconst EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';\n/**\n * Animations used by the Material expansion panel.\n *\n * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()\n * causes the animation state of moved components to become `void` upon exit, and not update again\n * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state\n * of the panel is `expanded` or `collapsed` but the animation state is `void`.\n *\n * To correctly handle animating to the next state, we animate between `void` and `collapsed` which\n * are defined to have the same styles. Since angular animates from the current styles to the\n * destination state's style definition, in situations where we are moving from `void`'s styles to\n * `collapsed` this acts a noop since no style values change.\n *\n * In the case where angular's animation state is out of sync with the expansion panel's state, the\n * expansion panel being `expanded` and angular animations being `void`, the animation from the\n * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will\n * occur as expected.\n *\n * Angular Bug: https://github.com/angular/angular/issues/18847\n *\n * \\@docs-private\n * @type {?}\n */\nconst matExpansionAnimations = {\n    /**\n     * Animation that rotates the indicator arrow.\n     */\n    indicatorRotate: trigger('indicatorRotate', [\n        state('collapsed, void', style({ transform: 'rotate(0deg)' })),\n        state('expanded', style({ transform: 'rotate(180deg)' })),\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ]),\n    /**\n     * Animation that expands and collapses the panel header height.\n     */\n    expansionHeaderHeight: trigger('expansionHeight', [\n        state('collapsed, void', style({\n            height: '{{collapsedHeight}}',\n        }), {\n            params: { collapsedHeight: '48px' },\n        }),\n        state('expanded', style({\n            height: '{{expandedHeight}}'\n        }), {\n            params: { expandedHeight: '64px' }\n        }),\n        transition('expanded <=> collapsed, void => collapsed', group([\n            query('@indicatorRotate', animateChild(), { optional: true }),\n            animate(EXPANSION_PANEL_ANIMATION_TIMING),\n        ])),\n    ]),\n    /**\n     * Animation that expands and collapses the panel content.\n     */\n    bodyExpansion: trigger('bodyExpansion', [\n        state('collapsed, void', style({ height: '0px', visibility: 'hidden' })),\n        state('expanded', style({ height: '*', visibility: 'visible' })),\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel-content.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Expansion panel content that will be rendered lazily\n * after the panel is opened for the first time.\n */\nclass MatExpansionPanelContent {\n    /**\n     * @param {?} _template\n     */\n    constructor(_template) {\n        this._template = _template;\n    }\n}\nMatExpansionPanelContent.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[matExpansionPanelContent]'\n            },] }\n];\n/** @nocollapse */\nMatExpansionPanelContent.ctorParameters = () => [\n    { type: TemplateRef }\n];\nif (false) {\n    /** @type {?} */\n    MatExpansionPanelContent.prototype._template;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter for generating unique element ids.\n * @type {?}\n */\nlet uniqueId = 0;\n/**\n * Object that can be used to override the default options\n * for all of the expansion panels in a module.\n * @record\n */\nfunction MatExpansionPanelDefaultOptions() { }\nif (false) {\n    /**\n     * Height of the header while the panel is expanded.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.expandedHeight;\n    /**\n     * Height of the header while the panel is collapsed.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.collapsedHeight;\n    /**\n     * Whether the toggle indicator should be hidden.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.hideToggle;\n}\n/**\n * Injection token that can be used to configure the defalt\n * options for the expansion panel component.\n * @type {?}\n */\nconst MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new InjectionToken('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');\nconst Éµ0 = undefined;\n/**\n * `<mat-expansion-panel>`\n *\n * This component can be used as a single element to show expandable content, or as one of\n * multiple children of an element with the MatAccordion directive attached.\n */\nclass MatExpansionPanel extends CdkAccordionItem {\n    /**\n     * @param {?} accordion\n     * @param {?} _changeDetectorRef\n     * @param {?} _uniqueSelectionDispatcher\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     * @param {?} _animationMode\n     * @param {?=} defaultOptions\n     */\n    constructor(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {\n        super(accordion, _changeDetectorRef, _uniqueSelectionDispatcher);\n        this._viewContainerRef = _viewContainerRef;\n        this._animationMode = _animationMode;\n        this._hideToggle = false;\n        /**\n         * An event emitted after the body's expansion animation happens.\n         */\n        this.afterExpand = new EventEmitter();\n        /**\n         * An event emitted after the body's collapse animation happens.\n         */\n        this.afterCollapse = new EventEmitter();\n        /**\n         * Stream that emits for changes in `\\@Input` properties.\n         */\n        this._inputChanges = new Subject();\n        /**\n         * ID for the associated header element. Used for a11y labelling.\n         */\n        this._headerId = `mat-expansion-panel-header-${uniqueId++}`;\n        /**\n         * Stream of body animation done events.\n         */\n        this._bodyAnimationDone = new Subject();\n        this.accordion = accordion;\n        this._document = _document;\n        // We need a Subject with distinctUntilChanged, because the `done` event\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n        this._bodyAnimationDone.pipe(distinctUntilChanged((/**\n         * @param {?} x\n         * @param {?} y\n         * @return {?}\n         */\n        (x, y) => {\n            return x.fromState === y.fromState && x.toState === y.toState;\n        }))).subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            if (event.fromState !== 'void') {\n                if (event.toState === 'expanded') {\n                    this.afterExpand.emit();\n                }\n                else if (event.toState === 'collapsed') {\n                    this.afterCollapse.emit();\n                }\n            }\n        }));\n        if (defaultOptions) {\n            this.hideToggle = defaultOptions.hideToggle;\n        }\n    }\n    /**\n     * Whether the toggle indicator should be hidden.\n     * @return {?}\n     */\n    get hideToggle() {\n        return this._hideToggle || (this.accordion && this.accordion.hideToggle);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hideToggle(value) {\n        this._hideToggle = coerceBooleanProperty(value);\n    }\n    /**\n     * The position of the expansion indicator.\n     * @return {?}\n     */\n    get togglePosition() {\n        return this._togglePosition || (this.accordion && this.accordion.togglePosition);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set togglePosition(value) {\n        this._togglePosition = value;\n    }\n    /**\n     * Determines whether the expansion panel should have spacing between it and its siblings.\n     * @return {?}\n     */\n    _hasSpacing() {\n        if (this.accordion) {\n            return this.expanded && this.accordion.displayMode === 'default';\n        }\n        return false;\n    }\n    /**\n     * Gets the expanded state string.\n     * @return {?}\n     */\n    _getExpandedState() {\n        return this.expanded ? 'expanded' : 'collapsed';\n    }\n    /**\n     * Toggles the expanded state of the expansion panel.\n     * @return {?}\n     */\n    toggle() {\n        this.expanded = !this.expanded;\n    }\n    /**\n     * Sets the expanded state of the expansion panel to false.\n     * @return {?}\n     */\n    close() {\n        this.expanded = false;\n    }\n    /**\n     * Sets the expanded state of the expansion panel to true.\n     * @return {?}\n     */\n    open() {\n        this.expanded = true;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        if (this._lazyContent) {\n            // Render the content as soon as the panel becomes open.\n            this.opened.pipe(startWith((/** @type {?} */ (null))), filter((/**\n             * @return {?}\n             */\n            () => this.expanded && !this._portal)), take(1)).subscribe((/**\n             * @return {?}\n             */\n            () => {\n                this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);\n            }));\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this._inputChanges.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._bodyAnimationDone.complete();\n        this._inputChanges.complete();\n    }\n    /**\n     * Checks whether the expansion panel's content contains the currently-focused element.\n     * @return {?}\n     */\n    _containsFocus() {\n        if (this._body) {\n            /** @type {?} */\n            const focusedElement = this._document.activeElement;\n            /** @type {?} */\n            const bodyElement = this._body.nativeElement;\n            return focusedElement === bodyElement || bodyElement.contains(focusedElement);\n        }\n        return false;\n    }\n}\nMatExpansionPanel.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-expansion-panel',\n                exportAs: 'matExpansionPanel',\n                template: \"<ng-content select=\\\"mat-expansion-panel-header\\\"></ng-content>\\n<div class=\\\"mat-expansion-panel-content\\\"\\n     role=\\\"region\\\"\\n     [@bodyExpansion]=\\\"_getExpandedState()\\\"\\n     (@bodyExpansion.done)=\\\"_bodyAnimationDone.next($event)\\\"\\n     [attr.aria-labelledby]=\\\"_headerId\\\"\\n     [id]=\\\"id\\\"\\n     #body>\\n  <div class=\\\"mat-expansion-panel-body\\\">\\n    <ng-content></ng-content>\\n    <ng-template [cdkPortalOutlet]=\\\"_portal\\\"></ng-template>\\n  </div>\\n  <ng-content select=\\\"mat-action-row\\\"></ng-content>\\n</div>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                inputs: ['disabled', 'expanded'],\n                outputs: ['opened', 'closed', 'expandedChange'],\n                animations: [matExpansionAnimations.bodyExpansion],\n                providers: [\n                    // Provide MatAccordion as undefined to prevent nested expansion panels from registering\n                    // to the same accordion.\n                    { provide: MAT_ACCORDION, useValue: Éµ0 },\n                ],\n                host: {\n                    'class': 'mat-expansion-panel',\n                    '[class.mat-expanded]': 'expanded',\n                    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                    '[class.mat-expansion-panel-spacing]': '_hasSpacing()',\n                },\n                styles: [\".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatExpansionPanel.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [MAT_ACCORDION,] }] },\n    { type: ChangeDetectorRef },\n    { type: UniqueSelectionDispatcher },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\n];\nMatExpansionPanel.propDecorators = {\n    hideToggle: [{ type: Input }],\n    togglePosition: [{ type: Input }],\n    afterExpand: [{ type: Output }],\n    afterCollapse: [{ type: Output }],\n    _lazyContent: [{ type: ContentChild, args: [MatExpansionPanelContent,] }],\n    _body: [{ type: ViewChild, args: ['body',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_hideToggle;\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_expanded;\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_disabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._hideToggle;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._togglePosition;\n    /**\n     * An event emitted after the body's expansion animation happens.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.afterExpand;\n    /**\n     * An event emitted after the body's collapse animation happens.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.afterCollapse;\n    /**\n     * Stream that emits for changes in `\\@Input` properties.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._inputChanges;\n    /**\n     * Optionally defined accordion the expansion panel belongs to.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.accordion;\n    /**\n     * Content that will be rendered lazily.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._lazyContent;\n    /**\n     * Element containing the panel's user-provided content.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._body;\n    /**\n     * Portal holding the user's content.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._portal;\n    /**\n     * ID for the associated header element. Used for a11y labelling.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._headerId;\n    /**\n     * Stream of body animation done events.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._bodyAnimationDone;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._viewContainerRef;\n    /** @type {?} */\n    MatExpansionPanel.prototype._animationMode;\n}\nclass MatExpansionPanelActionRow {\n}\nMatExpansionPanelActionRow.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-action-row',\n                host: {\n                    class: 'mat-action-row'\n                }\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel-header.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * `<mat-expansion-panel-header>`\n *\n * This component corresponds to the header element of an `<mat-expansion-panel>`.\n */\nclass MatExpansionPanelHeader {\n    /**\n     * @param {?} panel\n     * @param {?} _element\n     * @param {?} _focusMonitor\n     * @param {?} _changeDetectorRef\n     * @param {?=} defaultOptions\n     */\n    constructor(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {\n        this.panel = panel;\n        this._element = _element;\n        this._focusMonitor = _focusMonitor;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._parentChangeSubscription = Subscription.EMPTY;\n        /**\n         * Whether Angular animations in the panel header should be disabled.\n         */\n        this._animationsDisabled = true;\n        /** @type {?} */\n        const accordionHideToggleChange = panel.accordion ?\n            panel.accordion._stateChanges.pipe(filter((/**\n             * @param {?} changes\n             * @return {?}\n             */\n            changes => !!(changes['hideToggle'] || changes['togglePosition'])))) :\n            EMPTY;\n        // Since the toggle state depends on an @Input on the panel, we\n        // need to subscribe and trigger change detection manually.\n        this._parentChangeSubscription =\n            merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter((/**\n             * @param {?} changes\n             * @return {?}\n             */\n            changes => {\n                return !!(changes['hideToggle'] ||\n                    changes['disabled'] ||\n                    changes['togglePosition']);\n            }))))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => this._changeDetectorRef.markForCheck()));\n        // Avoids focus being lost if the panel contained the focused element and was closed.\n        panel.closed\n            .pipe(filter((/**\n         * @return {?}\n         */\n        () => panel._containsFocus())))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => _focusMonitor.focusVia(_element, 'program')));\n        _focusMonitor.monitor(_element).subscribe((/**\n         * @param {?} origin\n         * @return {?}\n         */\n        origin => {\n            if (origin && panel.accordion) {\n                panel.accordion._handleHeaderFocus(this);\n            }\n        }));\n        if (defaultOptions) {\n            this.expandedHeight = defaultOptions.expandedHeight;\n            this.collapsedHeight = defaultOptions.collapsedHeight;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _animationStarted() {\n        // Currently the `expansionHeight` animation has a `void => collapsed` transition which is\n        // there to work around a bug in Angular (see #13088), however this introduces a different\n        // issue. The new transition will cause the header to animate in on init (see #16067), if the\n        // consumer has set a header height that is different from the default one. We work around it\n        // by disabling animations on the header and re-enabling them after the first animation has run.\n        // Note that Angular dispatches animation events even if animations are disabled. Ideally this\n        // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait\n        // for https://github.com/angular/angular/issues/18847 to be resolved.\n        this._animationsDisabled = false;\n    }\n    /**\n     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() {\n        return this.panel.disabled;\n    }\n    /**\n     * Toggles the expanded state of the panel.\n     * @return {?}\n     */\n    _toggle() {\n        if (!this.disabled) {\n            this.panel.toggle();\n        }\n    }\n    /**\n     * Gets whether the panel is expanded.\n     * @return {?}\n     */\n    _isExpanded() {\n        return this.panel.expanded;\n    }\n    /**\n     * Gets the expanded state string of the panel.\n     * @return {?}\n     */\n    _getExpandedState() {\n        return this.panel._getExpandedState();\n    }\n    /**\n     * Gets the panel id.\n     * @return {?}\n     */\n    _getPanelId() {\n        return this.panel.id;\n    }\n    /**\n     * Gets the toggle position for the header.\n     * @return {?}\n     */\n    _getTogglePosition() {\n        return this.panel.togglePosition;\n    }\n    /**\n     * Gets whether the expand indicator should be shown.\n     * @return {?}\n     */\n    _showToggle() {\n        return !this.panel.hideToggle && !this.panel.disabled;\n    }\n    /**\n     * Handle keydown event calling to toggle() if appropriate.\n     * @param {?} event\n     * @return {?}\n     */\n    _keydown(event) {\n        switch (event.keyCode) {\n            // Toggle for space and enter keys.\n            case SPACE:\n            case ENTER:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this._toggle();\n                }\n                break;\n            default:\n                if (this.panel.accordion) {\n                    this.panel.accordion._handleHeaderKeydown(event);\n                }\n                return;\n        }\n    }\n    /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @param {?=} origin Origin of the action that triggered the focus.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        this._focusMonitor.focusVia(this._element, origin, options);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._parentChangeSubscription.unsubscribe();\n        this._focusMonitor.stopMonitoring(this._element);\n    }\n}\nMatExpansionPanelHeader.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-expansion-panel-header',\n                template: \"<span class=\\\"mat-content\\\">\\n  <ng-content select=\\\"mat-panel-title\\\"></ng-content>\\n  <ng-content select=\\\"mat-panel-description\\\"></ng-content>\\n  <ng-content></ng-content>\\n</span>\\n<span [@indicatorRotate]=\\\"_getExpandedState()\\\" *ngIf=\\\"_showToggle()\\\"\\n      class=\\\"mat-expansion-indicator\\\"></span>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                animations: [\n                    matExpansionAnimations.indicatorRotate,\n                    matExpansionAnimations.expansionHeaderHeight\n                ],\n                host: {\n                    'class': 'mat-expansion-panel-header',\n                    'role': 'button',\n                    '[attr.id]': 'panel._headerId',\n                    '[attr.tabindex]': 'disabled ? -1 : 0',\n                    '[attr.aria-controls]': '_getPanelId()',\n                    '[attr.aria-expanded]': '_isExpanded()',\n                    '[attr.aria-disabled]': 'panel.disabled',\n                    '[class.mat-expanded]': '_isExpanded()',\n                    '[class.mat-expansion-toggle-indicator-after]': `_getTogglePosition() === 'after'`,\n                    '[class.mat-expansion-toggle-indicator-before]': `_getTogglePosition() === 'before'`,\n                    '(click)': '_toggle()',\n                    '(keydown)': '_keydown($event)',\n                    '[@.disabled]': '_animationsDisabled',\n                    '(@expansionHeight.start)': '_animationStarted()',\n                    '[@expansionHeight]': `{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }`,\n                },\n                styles: [\".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:\\\"\\\";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatExpansionPanelHeader.ctorParameters = () => [\n    { type: MatExpansionPanel, decorators: [{ type: Host }] },\n    { type: ElementRef },\n    { type: FocusMonitor },\n    { type: ChangeDetectorRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\n];\nMatExpansionPanelHeader.propDecorators = {\n    expandedHeight: [{ type: Input }],\n    collapsedHeight: [{ type: Input }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._parentChangeSubscription;\n    /**\n     * Whether Angular animations in the panel header should be disabled.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype._animationsDisabled;\n    /**\n     * Height of the header while the panel is expanded.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype.expandedHeight;\n    /**\n     * Height of the header while the panel is collapsed.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype.collapsedHeight;\n    /** @type {?} */\n    MatExpansionPanelHeader.prototype.panel;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._element;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._focusMonitor;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._changeDetectorRef;\n}\n/**\n * `<mat-panel-description>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nclass MatExpansionPanelDescription {\n}\nMatExpansionPanelDescription.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-panel-description',\n                host: {\n                    class: 'mat-expansion-panel-header-description'\n                }\n            },] }\n];\n/**\n * `<mat-panel-title>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nclass MatExpansionPanelTitle {\n}\nMatExpansionPanelTitle.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-panel-title',\n                host: {\n                    class: 'mat-expansion-panel-header-title'\n                }\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/accordion.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive for a Material Design Accordion.\n */\nclass MatAccordion extends CdkAccordion {\n    constructor() {\n        super(...arguments);\n        /**\n         * Headers belonging to this accordion.\n         */\n        this._ownHeaders = new QueryList();\n        this._hideToggle = false;\n        /**\n         * Display mode used for all expansion panels in the accordion. Currently two display\n         * modes exist:\n         *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n         *     panel at a different elevation from the rest of the accordion.\n         *  flat - no spacing is placed around expanded panels, showing all panels at the same\n         *     elevation.\n         */\n        this.displayMode = 'default';\n        /**\n         * The position of the expansion indicator.\n         */\n        this.togglePosition = 'after';\n    }\n    /**\n     * Whether the expansion indicator should be hidden.\n     * @return {?}\n     */\n    get hideToggle() { return this._hideToggle; }\n    /**\n     * @param {?} show\n     * @return {?}\n     */\n    set hideToggle(show) { this._hideToggle = coerceBooleanProperty(show); }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._headers.changes\n            .pipe(startWith(this._headers))\n            .subscribe((/**\n         * @param {?} headers\n         * @return {?}\n         */\n        (headers) => {\n            this._ownHeaders.reset(headers.filter((/**\n             * @param {?} header\n             * @return {?}\n             */\n            header => header.panel.accordion === this)));\n            this._ownHeaders.notifyOnChanges();\n        }));\n        this._keyManager = new FocusKeyManager(this._ownHeaders).withWrap();\n    }\n    /**\n     * Handles keyboard events coming in from the panel headers.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleHeaderKeydown(event) {\n        const { keyCode } = event;\n        /** @type {?} */\n        const manager = this._keyManager;\n        if (keyCode === HOME) {\n            if (!hasModifierKey(event)) {\n                manager.setFirstItemActive();\n                event.preventDefault();\n            }\n        }\n        else if (keyCode === END) {\n            if (!hasModifierKey(event)) {\n                manager.setLastItemActive();\n                event.preventDefault();\n            }\n        }\n        else {\n            this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * @param {?} header\n     * @return {?}\n     */\n    _handleHeaderFocus(header) {\n        this._keyManager.updateActiveItem(header);\n    }\n}\nMatAccordion.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-accordion',\n                exportAs: 'matAccordion',\n                inputs: ['multi'],\n                providers: [{\n                        provide: MAT_ACCORDION,\n                        useExisting: MatAccordion\n                    }],\n                host: {\n                    class: 'mat-accordion',\n                    // Class binding which is only used by the test harness as there is no other\n                    // way for the harness to detect if multiple panel support is enabled.\n                    '[class.mat-accordion-multi]': 'this.multi',\n                }\n            },] }\n];\nMatAccordion.propDecorators = {\n    _headers: [{ type: ContentChildren, args: [MatExpansionPanelHeader, { descendants: true },] }],\n    hideToggle: [{ type: Input }],\n    displayMode: [{ type: Input }],\n    togglePosition: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    MatAccordion.ngAcceptInputType_hideToggle;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._keyManager;\n    /**\n     * Headers belonging to this accordion.\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._ownHeaders;\n    /**\n     * All headers inside the accordion. Includes headers inside nested accordions.\n     * @type {?}\n     */\n    MatAccordion.prototype._headers;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._hideToggle;\n    /**\n     * Display mode used for all expansion panels in the accordion. Currently two display\n     * modes exist:\n     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n     *     panel at a different elevation from the rest of the accordion.\n     *  flat - no spacing is placed around expanded panels, showing all panels at the same\n     *     elevation.\n     * @type {?}\n     */\n    MatAccordion.prototype.displayMode;\n    /**\n     * The position of the expansion indicator.\n     * @type {?}\n     */\n    MatAccordion.prototype.togglePosition;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatExpansionModule {\n}\nMatExpansionModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule, CdkAccordionModule, PortalModule],\n                exports: [\n                    MatAccordion,\n                    MatExpansionPanel,\n                    MatExpansionPanelActionRow,\n                    MatExpansionPanelHeader,\n                    MatExpansionPanelTitle,\n                    MatExpansionPanelDescription,\n                    MatExpansionPanelContent,\n                ],\n                declarations: [\n                    MatAccordion,\n                    MatExpansionPanel,\n                    MatExpansionPanelActionRow,\n                    MatExpansionPanelHeader,\n                    MatExpansionPanelTitle,\n                    MatExpansionPanelDescription,\n                    MatExpansionPanelContent,\n                ],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { EXPANSION_PANEL_ANIMATION_TIMING, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatAccordion, MatExpansionModule, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelContent, MatExpansionPanelDescription, MatExpansionPanelHeader, MatExpansionPanelTitle, matExpansionAnimations };\n//# sourceMappingURL=expansion.js.map\n","import { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UP_ARROW, DOWN_ARROW, END, hasModifierKey, HOME, RIGHT_ARROW, LEFT_ARROW, ESCAPE } from '@angular/cdk/keycodes';\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, ChangeDetectorRef, InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Optional, Input, HostListener, QueryList, EventEmitter, NgZone, ContentChildren, ViewChild, ContentChild, Output, Self, NgModule } from '@angular/core';\nimport { Subject, Subscription, merge, of, asapScheduler } from 'rxjs';\nimport { startWith, switchMap, take, filter, takeUntil, delay } from 'rxjs/operators';\nimport { trigger, state, style, transition, group, query, animate } from '@angular/animations';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { mixinDisableRipple, mixinDisabled, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-animations.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * \\@docs-private\n * @type {?}\n */\nconst matMenuAnimations = {\n    /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n    transformMenu: trigger('transformMenu', [\n        state('void', style({\n            opacity: 0,\n            transform: 'scale(0.8)'\n        })),\n        transition('void => enter', group([\n            query('.mat-menu-content, .mat-mdc-menu-content', animate('100ms linear', style({\n                opacity: 1\n            }))),\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\n        ])),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\n    ]),\n    /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n    fadeInItems: trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        state('showing', style({ opacity: 1 })),\n        transition('void => *', [\n            style({ opacity: 0 }),\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nconst transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-content.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nclass MatMenuContent {\n    /**\n     * @param {?} _template\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     * @param {?=} _changeDetectorRef\n     */\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n        this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * Emits when the menu content has been attached.\n         */\n        this._attached = new Subject();\n    }\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    attach(context = {}) {\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n        }\n        /** @type {?} */\n        const element = this._template.elementRef.nativeElement;\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        (/** @type {?} */ (element.parentNode)).insertBefore(this._outlet.outletElement, element);\n        // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\n        // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\n        // by Angular. This causes the `@ContentChildren` for menu items within the menu to\n        // not be updated by Angular. By explicitly marking for check here, we tell Angular that\n        // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\n        // @breaking-change 9.0.0 Make change detector ref required\n        if (this._changeDetectorRef) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    detach() {\n        if (this._portal.isAttached) {\n            this._portal.detach();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._outlet) {\n            this._outlet.dispose();\n        }\n    }\n}\nMatMenuContent.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[matMenuContent]'\n            },] }\n];\n/** @nocollapse */\nMatMenuContent.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ComponentFactoryResolver },\n    { type: ApplicationRef },\n    { type: Injector },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: ChangeDetectorRef }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._portal;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._outlet;\n    /**\n     * Emits when the menu content has been attached.\n     * @type {?}\n     */\n    MatMenuContent.prototype._attached;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._template;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._componentFactoryResolver;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._appRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._injector;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._changeDetectorRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-errors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-panel.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n/**\n * Interface for a custom menu panel that can be used with `matMenuTriggerFor`.\n * \\@docs-private\n * @record\n * @template T\n */\nfunction MatMenuPanel() { }\nif (false) {\n    /** @type {?} */\n    MatMenuPanel.prototype.xPosition;\n    /** @type {?} */\n    MatMenuPanel.prototype.yPosition;\n    /** @type {?} */\n    MatMenuPanel.prototype.overlapTrigger;\n    /** @type {?} */\n    MatMenuPanel.prototype.templateRef;\n    /** @type {?} */\n    MatMenuPanel.prototype.close;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.parentMenu;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.direction;\n    /** @type {?} */\n    MatMenuPanel.prototype.focusFirstItem;\n    /** @type {?} */\n    MatMenuPanel.prototype.resetActiveItem;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.setPositionClasses;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.lazyContent;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.backdropClass;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.hasBackdrop;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.panelId;\n    /**\n     * @deprecated To be removed.\n     * \\@breaking-change 8.0.0\n     * @type {?|undefined}\n     */\n    MatMenuPanel.prototype.addItem;\n    /**\n     * @deprecated To be removed.\n     * \\@breaking-change 8.0.0\n     * @type {?|undefined}\n     */\n    MatMenuPanel.prototype.removeItem;\n    /**\n     * @param {?} depth\n     * @return {?}\n     */\n    MatMenuPanel.prototype.setElevation = function (depth) { };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-item.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatMenuItem.\n/**\n * \\@docs-private\n */\nclass MatMenuItemBase {\n}\n/** @type {?} */\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nclass MatMenuItem extends _MatMenuItemMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?=} document\n     * @param {?=} _focusMonitor\n     * @param {?=} _parentMenu\n     */\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\n        super();\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._parentMenu = _parentMenu;\n        /**\n         * ARIA role for the menu item.\n         */\n        this.role = 'menuitem';\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        this._hovered = new Subject();\n        /**\n         * Stream that emits when the menu item is focused.\n         */\n        this._focused = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(this._elementRef, false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(this);\n        }\n        this._document = document;\n    }\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n        }\n        else {\n            this._getHostElement().focus(options);\n        }\n        this._focused.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n        this._focused.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n    _checkDisabled(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n    _handleMouseEnter() {\n        this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    getLabel() {\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        /** @type {?} */\n        const textNodeType = this._document ? this._document.TEXT_NODE : 3;\n        /** @type {?} */\n        let output = '';\n        if (element.childNodes) {\n            /** @type {?} */\n            const length = element.childNodes.length;\n            // Go through all the top-level text nodes and extract their text.\n            // We skip anything that's not a text node to prevent the text from\n            // being thrown off by something like an icon.\n            for (let i = 0; i < length; i++) {\n                if (element.childNodes[i].nodeType === textNodeType) {\n                    output += element.childNodes[i].textContent;\n                }\n            }\n        }\n        return output.trim();\n    }\n}\nMatMenuItem.decorators = [\n    { type: Component, args: [{\n                selector: '[mat-menu-item]',\n                exportAs: 'matMenuItem',\n                inputs: ['disabled', 'disableRipple'],\n                host: {\n                    '[attr.role]': 'role',\n                    '[class.mat-menu-item]': 'true',\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n                    '[attr.tabindex]': '_getTabIndex()',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.disabled]': 'disabled || null',\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                template: \"<ng-content></ng-content>\\n<div class=\\\"mat-menu-ripple\\\" matRipple\\n     [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n     [matRippleTrigger]=\\\"_getHostElement()\\\">\\n</div>\\n\"\n            }] }\n];\n/** @nocollapse */\nMatMenuItem.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: FocusMonitor },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\n];\nMatMenuItem.propDecorators = {\n    role: [{ type: Input }],\n    _checkDisabled: [{ type: HostListener, args: ['click', ['$event'],] }],\n    _handleMouseEnter: [{ type: HostListener, args: ['mouseenter',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatMenuItem.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatMenuItem.ngAcceptInputType_disableRipple;\n    /**\n     * ARIA role for the menu item.\n     * @type {?}\n     */\n    MatMenuItem.prototype.role;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._document;\n    /**\n     * Stream that emits when the menu item is hovered.\n     * @type {?}\n     */\n    MatMenuItem.prototype._hovered;\n    /**\n     * Stream that emits when the menu item is focused.\n     * @type {?}\n     */\n    MatMenuItem.prototype._focused;\n    /**\n     * Whether the menu item is highlighted.\n     * @type {?}\n     */\n    MatMenuItem.prototype._highlighted;\n    /**\n     * Whether the menu item acts as a trigger for a sub-menu.\n     * @type {?}\n     */\n    MatMenuItem.prototype._triggersSubmenu;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._focusMonitor;\n    /** @type {?} */\n    MatMenuItem.prototype._parentMenu;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default `mat-menu` options that can be overridden.\n * @record\n */\nfunction MatMenuDefaultOptions() { }\nif (false) {\n    /**\n     * The x-axis position of the menu.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.xPosition;\n    /**\n     * The y-axis position of the menu.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.yPosition;\n    /**\n     * Whether the menu should overlap the menu trigger.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.overlapTrigger;\n    /**\n     * Class to be applied to the menu's backdrop.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.backdropClass;\n    /**\n     * Whether the menu has a backdrop.\n     * @type {?|undefined}\n     */\n    MatMenuDefaultOptions.prototype.hasBackdrop;\n}\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n * @type {?}\n */\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: false,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_BASE_ELEVATION = 4;\n/** @type {?} */\nlet menuPanelUid = 0;\n/**\n * Base class with all of the `MatMenu` functionality.\n */\n// tslint:disable-next-line:class-name\nclass _MatMenuBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} _defaultOptions\n     */\n    constructor(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Only the direct descendant menu items.\n         */\n        this._directDescendantItems = new QueryList();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.close = this.closed;\n        this.panelId = `mat-menu-panel-${menuPanelUid++}`;\n    }\n    /**\n     * Position of the menu in the X axis.\n     * @return {?}\n     */\n    get xPosition() { return this._xPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set xPosition(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMatMenuInvalidPositionX();\n        }\n        this._xPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n    get yPosition() { return this._yPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set yPosition(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMatMenuInvalidPositionY();\n        }\n        this._yPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n    get overlapTrigger() { return this._overlapTrigger; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set overlapTrigger(value) {\n        this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n    get hasBackdrop() { return this._hasBackdrop; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hasBackdrop(value) {\n        this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n    set panelClass(classes) {\n        /** @type {?} */\n        const previousPanelClass = this._previousPanelClass;\n        if (previousPanelClass && previousPanelClass.length) {\n            previousPanelClass.split(' ').forEach((/**\n             * @param {?} className\n             * @return {?}\n             */\n            (className) => {\n                this._classList[className] = false;\n            }));\n        }\n        this._previousPanelClass = classes;\n        if (classes && classes.length) {\n            classes.split(' ').forEach((/**\n             * @param {?} className\n             * @return {?}\n             */\n            (className) => {\n                this._classList[className] = true;\n            }));\n            this._elementRef.nativeElement.className = '';\n        }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get classList() { return this.panelClass; }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    set classList(classes) { this.panelClass = classes; }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._updateDirectDescendants();\n        this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead();\n        this._tabSubscription = this._keyManager.tabOut.subscribe((/**\n         * @return {?}\n         */\n        () => this.closed.emit('tab')));\n        // If a user manually (programatically) focuses a menu item, we need to reflect that focus\n        // change back to the key manager. Note that we don't need to unsubscribe here because _focused\n        // is internal and we know that it gets completed on destroy.\n        this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap((/**\n         * @param {?} items\n         * @return {?}\n         */\n        items => merge(...items.map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => item._focused)))))).subscribe((/**\n         * @param {?} focusedItem\n         * @return {?}\n         */\n        focusedItem => this._keyManager.updateActiveItem(focusedItem)));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._directDescendantItems.destroy();\n        this._tabSubscription.unsubscribe();\n        this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    _hovered() {\n        // Coerce the `changes` property because Angular types it as `Observable<any>`\n        /** @type {?} */\n        const itemChanges = (/** @type {?} */ (this._directDescendantItems.changes));\n        return (/** @type {?} */ (itemChanges.pipe(startWith(this._directDescendantItems), switchMap((/**\n         * @param {?} items\n         * @return {?}\n         */\n        items => merge(...items.map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => item._hovered))))))));\n    }\n    /*\n       * Registers a menu item with the menu.\n       * @docs-private\n       * @deprecated No longer being used. To be removed.\n       * @breaking-change 9.0.0\n       */\n    /**\n     * @param {?} _item\n     * @return {?}\n     */\n    addItem(_item) { }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 9.0.0\n     * @param {?} _item\n     * @return {?}\n     */\n    removeItem(_item) { }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        /** @type {?} */\n        const manager = this._keyManager;\n        switch (keyCode) {\n            case ESCAPE:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this.closed.emit('keydown');\n                }\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case HOME:\n            case END:\n                if (!hasModifierKey(event)) {\n                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n                    event.preventDefault();\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    manager.setFocusOrigin('keyboard');\n                }\n                manager.onKeydown(event);\n        }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    focusFirstItem(origin = 'program') {\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n        if (this.lazyContent) {\n            this._ngZone.onStable.asObservable()\n                .pipe(take(1))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => this._focusFirstItem(origin)));\n        }\n        else {\n            this._focusFirstItem(origin);\n        }\n    }\n    /**\n     * Actual implementation that focuses the first item. Needs to be separated\n     * out so we don't repeat the same logic in the public `focusFirstItem` method.\n     * @private\n     * @param {?} origin\n     * @return {?}\n     */\n    _focusFirstItem(origin) {\n        /** @type {?} */\n        const manager = this._keyManager;\n        manager.setFocusOrigin(origin).setFirstItemActive();\n        // If there's no active item at this point, it means that all the items are disabled.\n        // Move focus to the menu panel so keyboard events like Escape still work. Also this will\n        // give _some_ feedback to screen readers.\n        if (!manager.activeItem && this._directDescendantItems.length) {\n            /** @type {?} */\n            let element = this._directDescendantItems.first._getHostElement().parentElement;\n            // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't\n            // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either\n            // because the panel is inside an `ng-template`. We work around it by starting from one of\n            // the items and walking up the DOM.\n            while (element) {\n                if (element.getAttribute('role') === 'menu') {\n                    element.focus();\n                    break;\n                }\n                else {\n                    element = element.parentElement;\n                }\n            }\n        }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    resetActiveItem() {\n        this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    setElevation(depth) {\n        // The elevation starts at the base and increases by one for each level.\n        // Capped at 24 because that's the maximum elevation defined in the Material design spec.\n        /** @type {?} */\n        const elevation = Math.min(MAT_MENU_BASE_ELEVATION + depth, 24);\n        /** @type {?} */\n        const newElevation = `mat-elevation-z${elevation}`;\n        /** @type {?} */\n        const customElevation = Object.keys(this._classList).find((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => c.startsWith('mat-elevation-z')));\n        if (!customElevation || customElevation === this._previousElevation) {\n            if (this._previousElevation) {\n                this._classList[this._previousElevation] = false;\n            }\n            this._classList[newElevation] = true;\n            this._previousElevation = newElevation;\n        }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n        /** @type {?} */\n        const classes = this._classList;\n        classes['mat-menu-before'] = posX === 'before';\n        classes['mat-menu-after'] = posX === 'after';\n        classes['mat-menu-above'] = posY === 'above';\n        classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    _startAnimation() {\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\n        this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    _resetAnimation() {\n        // @breaking-change 8.0.0 Combine with _startAnimation.\n        this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationDone(event) {\n        this._animationDone.next(event);\n        this._isAnimating = false;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationStart(event) {\n        this._isAnimating = true;\n        // Scroll the content element to the top as soon as the animation starts. This is necessary,\n        // because we move focus to the first item while it's still being animated, which can throw\n        // the browser off when it determines the scroll position. Alternatively we can move focus\n        // when the animation is done, however moving focus asynchronously will interrupt screen\n        // readers which are in the process of reading out the menu already. We take the `element`\n        // from the `event` since we can't use a `ViewChild` to access the pane.\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n            event.element.scrollTop = 0;\n        }\n    }\n    /**\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\n     * items that are part of child menus, and using a custom way of registering items is unreliable\n     * when it comes to maintaining the item order.\n     * @private\n     * @return {?}\n     */\n    _updateDirectDescendants() {\n        this._allItems.changes\n            .pipe(startWith(this._allItems))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._directDescendantItems.reset(items.filter((/**\n             * @param {?} item\n             * @return {?}\n             */\n            item => item._parentMenu === this)));\n            this._directDescendantItems.notifyOnChanges();\n        }));\n    }\n}\n_MatMenuBase.decorators = [\n    { type: Directive }\n];\n/** @nocollapse */\n_MatMenuBase.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n];\n_MatMenuBase.propDecorators = {\n    _allItems: [{ type: ContentChildren, args: [MatMenuItem, { descendants: true },] }],\n    backdropClass: [{ type: Input }],\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\n    ariaDescribedby: [{ type: Input, args: ['aria-describedby',] }],\n    xPosition: [{ type: Input }],\n    yPosition: [{ type: Input }],\n    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],\n    items: [{ type: ContentChildren, args: [MatMenuItem, { descendants: false },] }],\n    lazyContent: [{ type: ContentChild, args: [MatMenuContent,] }],\n    overlapTrigger: [{ type: Input }],\n    hasBackdrop: [{ type: Input }],\n    panelClass: [{ type: Input, args: ['class',] }],\n    classList: [{ type: Input }],\n    closed: [{ type: Output }],\n    close: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    _MatMenuBase.ngAcceptInputType_overlapTrigger;\n    /** @type {?} */\n    _MatMenuBase.ngAcceptInputType_hasBackdrop;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._keyManager;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._xPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._yPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._previousElevation;\n    /**\n     * All items inside the menu. Includes items nested inside another menu.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._allItems;\n    /**\n     * Only the direct descendant menu items.\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._directDescendantItems;\n    /**\n     * Subscription to tab events on the menu panel\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._tabSubscription;\n    /**\n     * Config object to be passed into the menu's ngClass\n     * @type {?}\n     */\n    _MatMenuBase.prototype._classList;\n    /**\n     * Current state of the panel animation.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._panelAnimationState;\n    /**\n     * Emits whenever an animation on the menu completes.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._animationDone;\n    /**\n     * Whether the menu is animating.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._isAnimating;\n    /**\n     * Parent menu of the current menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.parentMenu;\n    /**\n     * Layout direction of the menu.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.direction;\n    /**\n     * Class to be added to the backdrop element.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.backdropClass;\n    /**\n     * aria-label for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaLabel;\n    /**\n     * aria-labelledby for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaLabelledby;\n    /**\n     * aria-describedby for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaDescribedby;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    _MatMenuBase.prototype.templateRef;\n    /**\n     * List of the items inside of a menu.\n     * @deprecated\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    _MatMenuBase.prototype.items;\n    /**\n     * Menu content that will be rendered lazily.\n     * \\@docs-private\n     * @type {?}\n     */\n    _MatMenuBase.prototype.lazyContent;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._overlapTrigger;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._hasBackdrop;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._previousPanelClass;\n    /**\n     * Event emitted when the menu is closed.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.closed;\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    _MatMenuBase.prototype.close;\n    /** @type {?} */\n    _MatMenuBase.prototype.panelId;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._defaultOptions;\n}\n/**\n * \\@docs-private We show the \"_MatMenu\" class as \"MatMenu\" in the docs.\n */\nclass MatMenu extends _MatMenuBase {\n}\nMatMenu.decorators = [\n    { type: Directive }\n];\n// Note on the weird inheritance setup: we need three classes, because the MDC-based menu has to\n// extend `MatMenu`, however keeping a reference to it will cause the inlined template and styles\n// to be retained as well. The MDC menu also has to provide itself as a `MatMenu` in order for\n// queries and DI to work correctly, while still not referencing the actual menu class.\n// Class responsibility is split up as follows:\n// * _MatMenuBase - provides all the functionality without any of the Angular metadata.\n// * MatMenu - keeps the same name symbol name as the current menu and\n// is used as a provider for DI and query purposes.\n// * _MatMenu - the actual menu component implementation with the Angular metadata that should\n// be tree shaken away for MDC.\n/**\n * \\@docs-public MatMenu\n */\n// tslint:disable-next-line:class-name\nclass _MatMenu extends MatMenu {\n    /**\n     * @param {?} elementRef\n     * @param {?} ngZone\n     * @param {?} defaultOptions\n     */\n    constructor(elementRef, ngZone, defaultOptions) {\n        super(elementRef, ngZone, defaultOptions);\n    }\n}\n_MatMenu.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-menu',\n                template: \"<ng-template>\\n  <div\\n    class=\\\"mat-menu-panel\\\"\\n    [id]=\\\"panelId\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    (keydown)=\\\"_handleKeydown($event)\\\"\\n    (click)=\\\"closed.emit('click')\\\"\\n    [@transformMenu]=\\\"_panelAnimationState\\\"\\n    (@transformMenu.start)=\\\"_onAnimationStart($event)\\\"\\n    (@transformMenu.done)=\\\"_onAnimationDone($event)\\\"\\n    tabindex=\\\"-1\\\"\\n    role=\\\"menu\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"ariaLabelledby || null\\\"\\n    [attr.aria-describedby]=\\\"ariaDescribedby || null\\\">\\n    <div class=\\\"mat-menu-content\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\",\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matMenu',\n                animations: [\n                    matMenuAnimations.transformMenu,\n                    matMenuAnimations.fadeInItems\n                ],\n                providers: [\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu },\n                    { provide: MatMenu, useExisting: _MatMenu }\n                ],\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:\\\"\\\";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"]\n            }] }\n];\n/** @nocollapse */\n_MatMenu.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n * @type {?}\n */\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return (/**\n     * @return {?}\n     */\n    () => overlay.scrollStrategies.reposition());\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n * @type {?}\n */\nconst MENU_PANEL_TOP_PADDING = 8;\n/**\n * Options for binding a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n// TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nclass MatMenuTrigger {\n    /**\n     * @param {?} _overlay\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} scrollStrategy\n     * @param {?} _parentMenu\n     * @param {?} _menuItemInstance\n     * @param {?} _dir\n     * @param {?=} _focusMonitor\n     */\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closingActionsSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        this._menuCloseSubscription = Subscription.EMPTY;\n        /**\n         * Handles touch start events on the trigger.\n         * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n         */\n        this._handleTouchStart = (/**\n         * @return {?}\n         */\n        () => this._openedBy = 'touch');\n        // Tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the menu is opened via the keyboard\n        this._openedBy = null;\n        /**\n         * Whether focus should be restored when the menu is closed.\n         * Note that disabling this option can have accessibility implications\n         * and it's up to you to manage focus, if you decide to turn it off.\n         */\n        this.restoreFocus = true;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuClose = this.menuClosed;\n        _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n        this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * @deprecated\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get _deprecatedMatMenuTriggerFor() { return this.menu; }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set _deprecatedMatMenuTriggerFor(v) {\n        this.menu = v;\n    }\n    /**\n     * References the menu instance that the trigger is associated with.\n     * @return {?}\n     */\n    get menu() { return this._menu; }\n    /**\n     * @param {?} menu\n     * @return {?}\n     */\n    set menu(menu) {\n        if (menu === this._menu) {\n            return;\n        }\n        this._menu = menu;\n        this._menuCloseSubscription.unsubscribe();\n        if (menu) {\n            this._menuCloseSubscription = menu.close.asObservable().subscribe((/**\n             * @param {?} reason\n             * @return {?}\n             */\n            reason => {\n                this._destroyMenu();\n                // If a click closed the menu, we should close the entire chain of nested menus.\n                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\n                    this._parentMenu.closed.emit(reason);\n                }\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._checkMenu();\n        this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        this._menuCloseSubscription.unsubscribe();\n        this._closingActionsSubscription.unsubscribe();\n        this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n    get menuOpen() {\n        return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    triggersSubmenu() {\n        return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    toggleMenu() {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    openMenu() {\n        if (this._menuOpen) {\n            return;\n        }\n        this._checkMenu();\n        /** @type {?} */\n        const overlayRef = this._createOverlay();\n        /** @type {?} */\n        const overlayConfig = overlayRef.getConfig();\n        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));\n        overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :\n            this.menu.hasBackdrop;\n        overlayRef.attach(this._getPortal());\n        if (this.menu.lazyContent) {\n            this.menu.lazyContent.attach(this.menuData);\n        }\n        this._closingActionsSubscription = this._menuClosingActions().subscribe((/**\n         * @return {?}\n         */\n        () => this.closeMenu()));\n        this._initMenu();\n        if (this.menu instanceof MatMenu) {\n            this.menu._startAnimation();\n        }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    closeMenu() {\n        this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._element, origin, options);\n        }\n        else {\n            this._element.nativeElement.focus(options);\n        }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @private\n     * @return {?}\n     */\n    _destroyMenu() {\n        if (!this._overlayRef || !this.menuOpen) {\n            return;\n        }\n        /** @type {?} */\n        const menu = this.menu;\n        this._closingActionsSubscription.unsubscribe();\n        this._overlayRef.detach();\n        if (menu instanceof MatMenu) {\n            menu._resetAnimation();\n            if (menu.lazyContent) {\n                // Wait for the exit animation to finish before detaching the content.\n                menu._animationDone\n                    .pipe(filter((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                event => event.toState === 'void')), take(1), \n                // Interrupt if the content got re-attached.\n                takeUntil(menu.lazyContent._attached))\n                    .subscribe({\n                    next: (/**\n                     * @return {?}\n                     */\n                    () => (/** @type {?} */ (menu.lazyContent)).detach()),\n                    // No matter whether the content got re-attached, reset the menu.\n                    complete: (/**\n                     * @return {?}\n                     */\n                    () => this._setIsMenuOpen(false))\n                });\n            }\n            else {\n                this._setIsMenuOpen(false);\n            }\n        }\n        else {\n            this._setIsMenuOpen(false);\n            if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        }\n        this._restoreFocus();\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    _initMenu() {\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n        this.menu.direction = this.dir;\n        this._setMenuElevation();\n        this._setIsMenuOpen(true);\n        this.menu.focusFirstItem(this._openedBy || 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @private\n     * @return {?}\n     */\n    _setMenuElevation() {\n        if (this.menu.setElevation) {\n            /** @type {?} */\n            let depth = 0;\n            /** @type {?} */\n            let parentMenu = this.menu.parentMenu;\n            while (parentMenu) {\n                depth++;\n                parentMenu = parentMenu.parentMenu;\n            }\n            this.menu.setElevation(depth);\n        }\n    }\n    /**\n     * Restores focus to the element that was focused before the menu was open.\n     * @private\n     * @return {?}\n     */\n    _restoreFocus() {\n        // We should reset focus if the user is navigating using a keyboard or\n        // if we have a top-level trigger which might cause focus to be lost\n        // when clicking on the backdrop.\n        if (this.restoreFocus) {\n            if (!this._openedBy) {\n                // Note that the focus style will show up both for `program` and\n                // `keyboard` so we don't have to specify which one it is.\n                this.focus();\n            }\n            else if (!this.triggersSubmenu()) {\n                this.focus(this._openedBy);\n            }\n        }\n        this._openedBy = null;\n    }\n    // set state rather than toggle to support triggers sharing a menu\n    /**\n     * @private\n     * @param {?} isOpen\n     * @return {?}\n     */\n    _setIsMenuOpen(isOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n            this._menuItemInstance._highlighted = isOpen;\n        }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @private\n     * @return {?}\n     */\n    _checkMenu() {\n        if (!this.menu) {\n            throwMatMenuMissingError();\n        }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @private\n     * @return {?}\n     */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            /** @type {?} */\n            const config = this._getOverlayConfig();\n            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));\n            this._overlayRef = this._overlay.create(config);\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\n            this._overlayRef.keydownEvents().subscribe();\n        }\n        return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @private\n     * @return {?} OverlayConfig\n     */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withLockedPosition()\n                .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir\n        });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @private\n     * @param {?} position\n     * @return {?}\n     */\n    _subscribeToPositions(position) {\n        if (this.menu.setPositionClasses) {\n            position.positionChanges.subscribe((/**\n             * @param {?} change\n             * @return {?}\n             */\n            change => {\n                /** @type {?} */\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                /** @type {?} */\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n                (/** @type {?} */ (this.menu.setPositionClasses))(posX, posY);\n            }));\n        }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @private\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    _setPosition(positionStrategy) {\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        /** @type {?} */\n        let offsetY = 0;\n        if (this.triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n        }\n        else if (!this.menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX, originY, overlayX, overlayY, offsetY },\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ]);\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @private\n     * @return {?}\n     */\n    _menuClosingActions() {\n        /** @type {?} */\n        const backdrop = (/** @type {?} */ (this._overlayRef)).backdropClick();\n        /** @type {?} */\n        const detachments = (/** @type {?} */ (this._overlayRef)).detachments();\n        /** @type {?} */\n        const parentClose = this._parentMenu ? this._parentMenu.closed : of();\n        /** @type {?} */\n        const hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter((/**\n         * @param {?} active\n         * @return {?}\n         */\n        active => active !== this._menuItemInstance)), filter((/**\n         * @return {?}\n         */\n        () => this._menuOpen))) : of();\n        return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleMousedown(event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            // Since right or middle button clicks won't trigger the `click` event,\n            // we shouldn't consider the menu as opened by mouse in those cases.\n            this._openedBy = event.button === 0 ? 'mouse' : null;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this.openMenu();\n        }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @private\n     * @return {?}\n     */\n    _handleHover() {\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (!this.triggersSubmenu()) {\n            return;\n        }\n        this._hoverSubscription = this._parentMenu._hovered()\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n            // with different data and triggers), we have to delay it by a tick to ensure that\n            // it won't be closed immediately after it is opened.\n            .pipe(filter((/**\n         * @param {?} active\n         * @return {?}\n         */\n        active => active === this._menuItemInstance && !active.disabled)), delay(0, asapScheduler))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._openedBy = 'mouse';\n            // If the same menu is used between multiple triggers, it might still be animating\n            // while the new trigger tries to re-open it. Wait for the animation to finish\n            // before doing so. Also interrupt if the user moves to another item.\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\n                // We need the `delay(0)` here in order to avoid\n                // 'changed after checked' errors in some cases. See #12194.\n                this.menu._animationDone\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))\n                    .subscribe((/**\n                 * @return {?}\n                 */\n                () => this.openMenu()));\n            }\n            else {\n                this.openMenu();\n            }\n        }));\n    }\n    /**\n     * Gets the portal that should be attached to the overlay.\n     * @private\n     * @return {?}\n     */\n    _getPortal() {\n        // Note that we can avoid this check by keeping the portal on the menu panel.\n        // While it would be cleaner, we'd have to introduce another required method on\n        // `MatMenuPanel`, making it harder to consume.\n        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n        }\n        return this._portal;\n    }\n}\nMatMenuTrigger.decorators = [\n    { type: Directive, args: [{\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\n                host: {\n                    'class': 'mat-menu-trigger',\n                    'aria-haspopup': 'true',\n                    '[attr.aria-expanded]': 'menuOpen || null',\n                    '[attr.aria-controls]': 'menuOpen ? menu.panelId : null',\n                    '(mousedown)': '_handleMousedown($event)',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(click)': '_handleClick($event)',\n                },\n                exportAs: 'matMenuTrigger'\n            },] }\n];\n/** @nocollapse */\nMatMenuTrigger.ctorParameters = () => [\n    { type: Overlay },\n    { type: ElementRef },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\n    { type: MatMenu, decorators: [{ type: Optional }] },\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: FocusMonitor }\n];\nMatMenuTrigger.propDecorators = {\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\n    restoreFocus: [{ type: Input, args: ['matMenuTriggerRestoreFocus',] }],\n    menuOpened: [{ type: Output }],\n    onMenuOpen: [{ type: Output }],\n    menuClosed: [{ type: Output }],\n    onMenuClose: [{ type: Output }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._portal;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._overlayRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuOpen;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._closingActionsSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._hoverSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuCloseSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._scrollStrategy;\n    /**\n     * Handles touch start events on the trigger.\n     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._handleTouchStart;\n    /** @type {?} */\n    MatMenuTrigger.prototype._openedBy;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menu;\n    /**\n     * Data to be passed along to any lazily-rendered content.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuData;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.restoreFocus;\n    /**\n     * Event emitted when the associated menu is opened.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuOpened;\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.onMenuOpen;\n    /**\n     * Event emitted when the associated menu is closed.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuClosed;\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.onMenuClose;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._overlay;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._element;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._parentMenu;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuItemInstance;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._focusMonitor;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used by both the current `MatMenuModule` and the MDC `MatMenuModule`\n * to declare the menu-related directives.\n */\n// tslint:disable-next-line:class-name\nclass _MatMenuDirectivesModule {\n}\n_MatMenuDirectivesModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [MatMenuTrigger, MatMenuContent, MatCommonModule],\n                declarations: [\n                    MatMenuTrigger,\n                    MatMenuContent,\n                ],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            },] }\n];\nclass MatMenuModule {\n}\nMatMenuModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    CommonModule,\n                    MatCommonModule,\n                    MatRippleModule,\n                    OverlayModule,\n                    _MatMenuDirectivesModule,\n                ],\n                exports: [_MatMenu, MatMenuItem, _MatMenuDirectivesModule],\n                declarations: [_MatMenu, MatMenuItem],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-positions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger, _MatMenu, _MatMenuBase, _MatMenuDirectivesModule, fadeInItems, matMenuAnimations, transformMenu, MAT_MENU_DEFAULT_OPTIONS_FACTORY as Éµangular_material_src_material_menu_menu_a, MAT_MENU_SCROLL_STRATEGY_FACTORY as Éµangular_material_src_material_menu_menu_b, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as Éµangular_material_src_material_menu_menu_c };\n//# sourceMappingURL=menu.js.map\n","<div class=\"dashboard-header\">\r\n  <div class=\"left-options\">\r\n    <div class=\"section-name-action\">\r\n      <p class=\"title\">\r\n        <b>{{ sectionName }}</b>\r\n      </p>\r\n      <div class=\"inl action\" *ngIf=\"actionName\" (click)=\"emitActionClicked()\">\r\n        <img src=\"assets/images/icons/icon-add.svg\" />\r\n        <p class=\"clr-yellow\">{{ actionName }}</p>\r\n      </div>\r\n    </div>\r\n    <form class=\"grey-select\" [formGroup]=\"form\">\r\n      <mat-select\r\n        formControlName=\"month\"\r\n        *ngIf=\"isMonthsSelectorVisible\"\r\n        (selectionChange)=\"monthChanged.emit($event.value)\"\r\n      >\r\n        <mat-option *ngFor=\"let month of months\" [value]=\"month.value\">{{\r\n          month.name\r\n        }}</mat-option>\r\n      </mat-select>\r\n      <!-- Month/year calendar -->\r\n      <mat-form-field\r\n        appearance=\"fill\"\r\n        *ngIf=\"hasTheMonthYearCalendarToBeVisible\"\r\n        class=\"month-year-picker\"\r\n      >\r\n        <input\r\n          matInput\r\n          [matDatepicker]=\"dp\"\r\n          [max]=\"monthYearMaxDate\"\r\n          formControlName=\"monthYear\"\r\n          readonly\r\n        />\r\n        <mat-datepicker-toggle matSuffix [for]=\"dp\">\r\n          <mat-icon matDatepickerToggleIcon>arrow_drop_down</mat-icon>\r\n        </mat-datepicker-toggle>\r\n        <mat-datepicker #picker></mat-datepicker>\r\n        <mat-datepicker\r\n          #dp\r\n          (monthSelected)=\"chosenMonthHandler($event, dp)\"\r\n          (yearSelected)=\"chosenYearHandler($event)\"\r\n          startView=\"multi-year\"\r\n          panelClass=\"example-month-picker\"\r\n        >\r\n        </mat-datepicker>\r\n      </mat-form-field>\r\n      <!-- End of the month/year calendar -->\r\n    </form>\r\n  </div>\r\n  <div class=\"profile relative\">\r\n    <div class=\"backImg user relative\" (click)=\"openMenu = !openMenu\"></div>\r\n    <ul class=\"menu\" [class.open]=\"openMenu\">\r\n      <li>\r\n        <a routerLink=\"/admin/profile\">\r\n          <p>Perfil</p>\r\n        </a>\r\n      </li>\r\n      <li (click)=\"logout(); openMenu = false\">\r\n        <p>Cerrar sesiÃ³n</p>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n"]}