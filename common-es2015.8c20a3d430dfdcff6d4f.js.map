{"version":3,"sources":["webpack:///src/app/shared/guards/index.ts","webpack:///src/app/shared/pipes/user-role/user-role.pipe.ts","webpack:///src/app/shared/components/pagination/pagination.component.html","webpack:///src/app/shared/pipes/login-error-code/login-error-code.pipe.ts","webpack:///src/app/shared/pipes/user-role/user-role.module.ts","webpack:///src/app/shared/services/payment.service.ts","webpack:///src/app/shared/components/pagination/pagination.component.ts","webpack:///src/app/shared/guards/franchise-and-restaurant-validity.guard.ts","webpack:///src/app/shared/components/pagination/pagination.module.ts","webpack:///src/app/shared/services/users.service.ts","webpack:///node_modules/@angular/material/fesm2015/slide-toggle.js","webpack:///src/app/shared/guards/claims.guard.ts"],"names":["UserRolePipe","role","spanishRole","LoginErrorCodePipe","errorCode","spanishError","UserRoleModule","PaymentService","http","this","get","STRIPE_OAUTH_STATUS","STRIPE_LINK","PaginationComponent","totalPages","currentPage","actualPage","resetPagination","page","next","changePage","FranchiseAndRestaurantValidityGuard","franchiseService","restaurantService","router","franchiseId","parseInt","JSON","parse","localStorage","getItem","restaurantId","isNaN","idsDetectedAsInvalid","franchises","getFranchisesAsPromise","length","franchiseIndex","isIdContainedByAnyOfTheFranchises","restaurants","getRestaurantsAsPromise","map","restaurant","restaurantIndex","isIdContainedByAnyOfTheRestaurants","setFranchise","setRestaurant","id","i","clear","signOut","finally","navigate","PaginationModule","UsersService","url","RESTAURANT_USERS","replace","toString","staff","post","userId","user","USERS_ID","put","manager","FRANCHISES_MANAGERS","delete","USERS_PROFILE","userData","MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS","providedIn","factory","disableToggleValue","nextUniqueId","MatSlideToggleChange","source","checked","MatSlideToggleBase","_elementRef","_MatSlideToggleMixinBase","MatSlideToggle","elementRef","_focusMonitor","_changeDetectorRef","tabIndex","_ngZone","defaults","_animationMode","_dir","super","_onChange","_","_onTouched","_uniqueId","_required","_checked","name","labelPosition","ariaLabel","ariaLabelledby","change","toggleChange","dragChange","value","c","markForCheck","monitor","subscribe","focusOrigin","Promise","resolve","then","stopMonitoring","event","stopPropagation","emit","_inputElement","nativeElement","_emitChangeEvent","fn","isDisabled","disabled","options","focusVia","detectChanges","_MatSlideToggleRequiredValidatorModule","MatSlideToggleModule","ClaimsGuard","route","state","currentUser","getIdTokenResult","idTokenResult","hasUserStaffPrivileges","claims","admin","split"],"mappings":"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","file":"x","sourcesContent":["export * from './franchise-and-restaurant-validity.guard';\r\nexport * from './claims.guard';\r\n","import { Pipe, PipeTransform } from '@angular/core';\r\n@Pipe({\r\n  name: 'userRole',\r\n})\r\nexport class UserRolePipe implements PipeTransform {\r\n  constructor() {}\r\n  transform(role: string): string {\r\n    let spanishRole = '';\r\n    switch (role) {\r\n      case 'staff':\r\n        spanishRole = 'Staff';\r\n        break;\r\n      case 'manager':\r\n        spanishRole = 'Gerente';\r\n        break;\r\n      case 'admin':\r\n        spanishRole = 'Administrador';\r\n        break;\r\n      default:\r\n        spanishRole = 'No se ha podido identificar el rol';\r\n    }\r\n    return spanishRole;\r\n  }\r\n}\r\n","<ul>\r\n  <li class=\"icon\" (click)=\"changePage(actualPage - 1)\">&#8249;</li>\r\n  <li *ngIf=\"actualPage > 1\" (click)=\"firstPage()\">1</li>\r\n  <li *ngIf=\"actualPage - 1 - 1 > 1\" class=\"points\">...</li>\r\n  <li *ngIf=\"actualPage > 2\" (click)=\"changePage(actualPage - 1)\">\r\n    {{ actualPage - 1 }}\r\n  </li>\r\n  <li *ngIf=\"actualPage\" class=\"active\" (click)=\"changePage(actualPage)\">\r\n    {{ actualPage }}\r\n  </li>\r\n  <li *ngIf=\"actualPage + 1 < totalPages\" (click)=\"changePage(actualPage + 1)\">\r\n    {{ actualPage + 1 }}\r\n  </li>\r\n\r\n  <li *ngIf=\"actualPage + 1 - totalPages < -1\" class=\"points\">...</li>\r\n  <li *ngIf=\"actualPage < totalPages\" (click)=\"lastPage()\">\r\n    {{ totalPages }}\r\n  </li>\r\n  <li class=\"icon\" (click)=\"changePage(actualPage + 1)\">&#8250;</li>\r\n</ul>\r\n","import { Pipe, PipeTransform } from '@angular/core';\r\n@Pipe({\r\n  name: 'loginErrorCode',\r\n})\r\nexport class LoginErrorCodePipe implements PipeTransform {\r\n  constructor() {}\r\n  transform(errorCode: string): string {\r\n    let spanishError = '';\r\n    switch (errorCode) {\r\n      case 'auth/user-not-found':\r\n        spanishError = 'El usuario no se encuentra registrado';\r\n        break;\r\n      case 'auth/invalid-email':\r\n        spanishError = 'El correo ingresado es inválido';\r\n        break;\r\n      case 'auth/wrong-password':\r\n        spanishError = 'La contraseña ingresada es incorrecta';\r\n        break;\r\n      case 'auth/not-an-admin':\r\n        spanishError = 'La cuenta no cuenta con permisos de administrador';\r\n        break;\r\n      default:\r\n        spanishError = 'No se ha podido identificar el error';\r\n    }\r\n    return spanishError;\r\n  }\r\n}\r\n","import { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\nimport { UserRolePipe } from './user-role.pipe';\r\n@NgModule({\r\n  declarations: [UserRolePipe],\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  exports: [\r\n    UserRolePipe\r\n  ]\r\n})\r\nexport class UserRoleModule { }\r\n","import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from '@environments/environment';\r\nimport { Observable } from 'rxjs';\r\nimport { StripeStatus } from '@interfaces';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class PaymentService {\r\n  constructor(private http: HttpClient) {}\r\n\r\n  /**\r\n   * Function that gets the stripe status from the server.\r\n   */\r\n  public getStripeStatus(): Observable<StripeStatus> {\r\n    return this.http.get<StripeStatus>(environment.STRIPE_OAUTH_STATUS);\r\n  }\r\n\r\n  /**\r\n   * Function that gets a link to go for the stripe configuration.\r\n   */\r\n  public getStripeLink(): Observable<string> {\r\n    return this.http.get<string>(environment.STRIPE_LINK);\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  Input,\r\n  OnChanges,\r\n  Output,\r\n  EventEmitter,\r\n} from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-pagination',\r\n  templateUrl: './pagination.component.html',\r\n  styleUrls: ['./pagination.component.scss'],\r\n})\r\nexport class PaginationComponent implements OnChanges {\r\n  /**\r\n   * Total of pages to show.\r\n   */\r\n  @Input() public totalPages = 0;\r\n\r\n  /**\r\n   * Tells to the parent element that the selected page has benn changed,\r\n   */\r\n  @Output() public currentPage = new EventEmitter<number>();\r\n\r\n  /**\r\n   * actual selected page.\r\n   */\r\n  public actualPage = 1;\r\n\r\n  constructor() {\r\n    this.resetPagination();\r\n  }\r\n\r\n  ngOnChanges(): void {\r\n    this.resetPagination();\r\n  }\r\n\r\n  /**\r\n   * Set a new selected page.\r\n   * @param page Number of the new page.\r\n   */\r\n  public changePage(page: number): void {\r\n    if (page !== this.actualPage) {\r\n      if (page > 0 && page <= this.totalPages) {\r\n        this.currentPage.next(page);\r\n        this.actualPage = page;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the first page as selected.\r\n   */\r\n  public firstPage(): void {\r\n    this.changePage(1);\r\n  }\r\n\r\n  /**\r\n   * Set the last page as selected.\r\n   */\r\n  public lastPage(): void {\r\n    this.changePage(this.totalPages);\r\n  }\r\n\r\n  /**\r\n   * Set the default values of the global variables.\r\n   */\r\n  public resetPagination(): void {\r\n    this.actualPage = 1;\r\n    this.currentPage.next(this.actualPage);\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { CanActivate } from '@angular/router';\r\nimport { Router } from '@angular/router';\r\nimport { FranchiseService, RestaurantService } from '@services';\r\nimport {\r\n  ResponseFranchises,\r\n  Franchise,\r\n  ResponseRestaurant,\r\n  Restaurant\r\n} from '@models';\r\nimport * as firebase from 'firebase/app';\r\nimport { IRestaurant } from '@interfaces';\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class FranchiseAndRestaurantValidityGuard implements CanActivate {\r\n  constructor(\r\n    private franchiseService: FranchiseService,\r\n    private restaurantService: RestaurantService,\r\n    private router: Router\r\n  ) {}\r\n  async canActivate(): Promise<boolean> {\r\n    const franchiseId = parseInt(\r\n      JSON.parse(localStorage.getItem('franchiseId')),\r\n      10\r\n    );\r\n    const restaurantId = parseInt(\r\n      JSON.parse(localStorage.getItem('restaurantId')),\r\n      10\r\n    );\r\n    if (!isNaN(franchiseId) && !isNaN(restaurantId)) {\r\n      const franchisesResponse: ResponseFranchises = await this.franchiseService.getFranchisesAsPromise();\r\n      const franchises = franchisesResponse.franchises;\r\n      if (franchises.length > 0) {\r\n        const franchiseIndex = this.isIdContainedByAnyOfTheFranchises(\r\n          franchises,\r\n          franchiseId\r\n        );\r\n        if (franchiseIndex !== -1) {\r\n          const responseRestaurant: ResponseRestaurant = await this.restaurantService.getRestaurantsAsPromise(\r\n            franchiseId\r\n          );\r\n          const restaurants = responseRestaurant.restaurants.map(\r\n            (restaurant: IRestaurant) => {\r\n              return new Restaurant(restaurant);\r\n            }\r\n          );\r\n          if (restaurants.length > 0) {\r\n            const restaurantIndex = this.isIdContainedByAnyOfTheRestaurants(\r\n              restaurants,\r\n              restaurantId\r\n            );\r\n            if (restaurantIndex !== -1) {\r\n              this.franchiseService.setFranchise(franchises[franchiseIndex]);\r\n              this.restaurantService.setRestaurant(\r\n                restaurants[restaurantIndex]\r\n              );\r\n              return true;\r\n            } else {\r\n              this.idsDetectedAsInvalid();\r\n              return false;\r\n            }\r\n          } else {\r\n            this.idsDetectedAsInvalid();\r\n            return false;\r\n          }\r\n        } else {\r\n          this.idsDetectedAsInvalid();\r\n          return false;\r\n        }\r\n      } else {\r\n        this.idsDetectedAsInvalid();\r\n        return false;\r\n      }\r\n    } else {\r\n      this.idsDetectedAsInvalid();\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private isIdContainedByAnyOfTheFranchises(\r\n    franchises: Array<Franchise>,\r\n    id: number\r\n  ): number {\r\n    for (let i = 0; i < franchises.length; i++) {\r\n      if (franchises[i].id === id) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  private isIdContainedByAnyOfTheRestaurants(\r\n    restaurants: Array<Restaurant>,\r\n    id: number\r\n  ): number {\r\n    for (let i = 0; i < restaurants.length; i++) {\r\n      if (restaurants[i].id === id) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  private idsDetectedAsInvalid(): void {\r\n    localStorage.clear();\r\n    firebase\r\n      .auth()\r\n      .signOut()\r\n      .finally(() => {\r\n        this.router.navigate(['']);\r\n      });\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { PaginationComponent } from './pagination.component';\r\n\r\n@NgModule({\r\n  declarations: [PaginationComponent],\r\n  imports: [CommonModule],\r\n  exports: [PaginationComponent],\r\n})\r\nexport class PaginationModule {}\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { environment } from '@environments/environment';\r\nimport { User } from '@models';\r\nimport { IUser } from '@interfaces';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class UsersService {\r\n  constructor(public http: HttpClient) {}\r\n\r\n  /**\r\n   * Function that gets the users from the server.\r\n   * @param restaurantId the id of the restaurant to look for its users.\r\n   * @returns an observable with the array of users.\r\n   */\r\n  public getUsers(restaurantId: number): Observable<{ users: Array<User> }> {\r\n    const url = environment.RESTAURANT_USERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.get<{ users: Array<User> }>(url);\r\n  }\r\n\r\n  /**\r\n   * Function that creates a user with role of staff at the server .\r\n   * @param restaurantId the id of the restaurant to assign the user.\r\n   * @param staff the data of the user to create.\r\n   * @returns an empty Observable.\r\n   */\r\n  public createStaff(restaurantId: number, staff: FormData): Observable<void> {\r\n    const url = environment.RESTAURANT_USERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<void>(url, staff);\r\n  }\r\n\r\n  /**\r\n   * Function that edit the info of a user at the server.\r\n   * @param userId the id of the user to edit.\r\n   * @param user the data of the user to save at the server.\r\n   * @returns an empty Observable.\r\n   */\r\n  public updateStaff(userId: number, user: FormData): Observable<void> {\r\n    const url = environment.USERS_ID.replace('{userId}', userId.toString());\r\n    return this.http.put<void>(url, user);\r\n  }\r\n\r\n  /**\r\n   * Function that creates a user with role of manager at the server.\r\n   * @param franchiseId the id of the franchise to assign the user.\r\n   * @param manager the data of the user to create.\r\n   * @returns an empty Observable.\r\n   */\r\n  public createManager(\r\n    franchiseId: number,\r\n    manager: FormData\r\n  ): Observable<void> {\r\n    const url = environment.FRANCHISES_MANAGERS.replace(\r\n      '{franchiseId}',\r\n      franchiseId.toString()\r\n    );\r\n    return this.http.post<void>(url, manager);\r\n  }\r\n\r\n  /**\r\n   * Function that deletes a user at the server.\r\n   * @param userId the id of the user to be deleted.\r\n   * @returns an empty Observable.\r\n   */\r\n  public deleteUser(userId: number): Observable<void> {\r\n    const url = environment.USERS_ID.replace('{userId}', userId.toString());\r\n    return this.http.delete<void>(url);\r\n  }\r\n\r\n  /**\r\n   * Get the profile of the current user.\r\n   * @returns Observable with the user's prifile information.\r\n   */\r\n  public getUserDetails(): Observable<IUser> {\r\n    return this.http.get<IUser>(environment.USERS_PROFILE);\r\n  }\r\n\r\n  /**\r\n   * Update the user's profile information.\r\n   * @param userData FormData with the new profile's information.\r\n   * @returns Observable with the new profile's information.\r\n   */\r\n  public updateUserProfile(userData: FormData): Observable<IUser> {\r\n    return this.http.put<IUser>(environment.USERS_PROFILE, userData);\r\n  }\r\n}\r\n","import { ObserversModule } from '@angular/cdk/observers';\nimport { InjectionToken, forwardRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, Attribute, NgZone, Inject, Optional, ViewChild, Input, Output, Directive, NgModule } from '@angular/core';\nimport { mixinTabIndex, mixinColor, mixinDisableRipple, mixinDisabled, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator } from '@angular/forms';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/slide-toggle/slide-toggle-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default `mat-slide-toggle` options that can be overridden.\n * @record\n */\nfunction MatSlideToggleDefaultOptions() { }\nif (false) {\n    /**\n     * Whether toggle action triggers value changes in slide toggle.\n     * @type {?|undefined}\n     */\n    MatSlideToggleDefaultOptions.prototype.disableToggleValue;\n    /**\n     * Whether drag action triggers value changes in slide toggle.\n     * @deprecated No longer being used.\n     * \\@breaking-change 10.0.0\n     * @type {?|undefined}\n     */\n    MatSlideToggleDefaultOptions.prototype.disableDragValue;\n}\n/**\n * Injection token to be used to override the default options for `mat-slide-toggle`.\n * @type {?}\n */\nconst MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new InjectionToken('mat-slide-toggle-default-options', {\n    providedIn: 'root',\n    factory: (/**\n     * @return {?}\n     */\n    () => ({ disableToggleValue: false }))\n});\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/slide-toggle/slide-toggle.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Increasing integer for generating unique ids for slide-toggle components.\n/** @type {?} */\nlet nextUniqueId = 0;\n/**\n * \\@docs-private\n * @type {?}\n */\nconst MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef((/**\n     * @return {?}\n     */\n    () => MatSlideToggle)),\n    multi: true\n};\n/**\n * Change event object emitted by a MatSlideToggle.\n */\nclass MatSlideToggleChange {\n    /**\n     * @param {?} source\n     * @param {?} checked\n     */\n    constructor(source, checked) {\n        this.source = source;\n        this.checked = checked;\n    }\n}\nif (false) {\n    /**\n     * The source MatSlideToggle of the event.\n     * @type {?}\n     */\n    MatSlideToggleChange.prototype.source;\n    /**\n     * The new `checked` value of the MatSlideToggle.\n     * @type {?}\n     */\n    MatSlideToggleChange.prototype.checked;\n}\n// Boilerplate for applying mixins to MatSlideToggle.\n/**\n * \\@docs-private\n */\nclass MatSlideToggleBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatSlideToggleBase.prototype._elementRef;\n}\n/** @type {?} */\nconst _MatSlideToggleMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatSlideToggleBase)), 'accent'));\n/**\n * Represents a slidable \"switch\" toggle that can be moved between on and off.\n */\nclass MatSlideToggle extends _MatSlideToggleMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _focusMonitor\n     * @param {?} _changeDetectorRef\n     * @param {?} tabIndex\n     * @param {?} _ngZone\n     * @param {?} defaults\n     * @param {?=} _animationMode\n     * @param {?=} _dir\n     */\n    constructor(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, \n    /**\n     * @deprecated `_ngZone` and `_dir` parameters to be removed.\n     * @breaking-change 10.0.0\n     */\n    _ngZone, defaults, _animationMode, _dir) {\n        super(elementRef);\n        this._focusMonitor = _focusMonitor;\n        this._changeDetectorRef = _changeDetectorRef;\n        this.defaults = defaults;\n        this._animationMode = _animationMode;\n        this._onChange = (/**\n         * @param {?} _\n         * @return {?}\n         */\n        (_) => { });\n        this._onTouched = (/**\n         * @return {?}\n         */\n        () => { });\n        this._uniqueId = `mat-slide-toggle-${++nextUniqueId}`;\n        this._required = false;\n        this._checked = false;\n        /**\n         * Name value will be applied to the input element if present.\n         */\n        this.name = null;\n        /**\n         * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\n         */\n        this.id = this._uniqueId;\n        /**\n         * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.\n         */\n        this.labelPosition = 'after';\n        /**\n         * Used to set the aria-label attribute on the underlying input element.\n         */\n        this.ariaLabel = null;\n        /**\n         * Used to set the aria-labelledby attribute on the underlying input element.\n         */\n        this.ariaLabelledby = null;\n        /**\n         * An event will be dispatched each time the slide-toggle changes its value.\n         */\n        this.change = new EventEmitter();\n        /**\n         * An event will be dispatched each time the slide-toggle input is toggled.\n         * This event is always emitted when the user toggles the slide toggle, but this does not mean\n         * the slide toggle's value has changed.\n         */\n        this.toggleChange = new EventEmitter();\n        /**\n         * An event will be dispatched each time the slide-toggle is dragged.\n         * This event is always emitted when the user drags the slide toggle to make a change greater\n         * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n         * the user toggles the slide toggle to change its value.\n         * @deprecated No longer being used. To be removed.\n         * \\@breaking-change 10.0.0\n         */\n        this.dragChange = new EventEmitter();\n        this.tabIndex = parseInt(tabIndex) || 0;\n    }\n    /**\n     * Whether the slide-toggle is required.\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) { this._required = coerceBooleanProperty(value); }\n    /**\n     * Whether the slide-toggle element is checked or not.\n     * @return {?}\n     */\n    get checked() { return this._checked; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set checked(value) {\n        this._checked = coerceBooleanProperty(value);\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Returns the unique id for the visual hidden input.\n     * @return {?}\n     */\n    get inputId() { return `${this.id || this._uniqueId}-input`; }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._focusMonitor\n            .monitor(this._elementRef, true)\n            .subscribe((/**\n         * @param {?} focusOrigin\n         * @return {?}\n         */\n        focusOrigin => {\n            if (!focusOrigin) {\n                // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n                // Angular does not expect events to be raised during change detection, so any state\n                // change (such as a form control's 'ng-touched') will cause a changed-after-checked\n                // error. See https://github.com/angular/angular/issues/17793. To work around this,\n                // we defer telling the form control it has been touched until the next tick.\n                Promise.resolve().then((/**\n                 * @return {?}\n                 */\n                () => this._onTouched()));\n            }\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n    /**\n     * Method being called whenever the underlying input emits a change event.\n     * @param {?} event\n     * @return {?}\n     */\n    _onChangeEvent(event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the component's `change` output.\n        event.stopPropagation();\n        this.toggleChange.emit();\n        // When the slide toggle's config disables toggle change event by setting\n        // `disableToggleValue: true`, the slide toggle's value does not change, and the\n        // checked state of the underlying input needs to be changed back.\n        if (this.defaults.disableToggleValue) {\n            this._inputElement.nativeElement.checked = this.checked;\n            return;\n        }\n        // Sync the value from the underlying input element with the component instance.\n        this.checked = this._inputElement.nativeElement.checked;\n        // Emit our custom change event only if the underlying input emitted one. This ensures that\n        // there is no change event, when the checked state changes programmatically.\n        this._emitChangeEvent();\n    }\n    /**\n     * Method being called whenever the slide-toggle has been clicked.\n     * @param {?} event\n     * @return {?}\n     */\n    _onInputClick(event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `slide-toggle` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    }\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    writeValue(value) {\n        this.checked = !!value;\n    }\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    /**\n     * Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Focuses the slide-toggle.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);\n    }\n    /**\n     * Toggles the checked state of the slide-toggle.\n     * @return {?}\n     */\n    toggle() {\n        this.checked = !this.checked;\n        this._onChange(this.checked);\n    }\n    /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     * @private\n     * @return {?}\n     */\n    _emitChangeEvent() {\n        this._onChange(this.checked);\n        this.change.emit(new MatSlideToggleChange(this, this.checked));\n    }\n    /**\n     * Method being called whenever the label text changes.\n     * @return {?}\n     */\n    _onLabelTextChange() {\n        // Since the event of the `cdkObserveContent` directive runs outside of the zone, the\n        // slide-toggle component will be only marked for check, but no actual change detection runs\n        // automatically. Instead of going back into the zone in order to trigger a change detection\n        // which causes *all* components to be checked (if explicitly marked or not using OnPush),\n        // we only trigger an explicit change detection for the slide-toggle view and its children.\n        this._changeDetectorRef.detectChanges();\n    }\n}\nMatSlideToggle.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-slide-toggle',\n                exportAs: 'matSlideToggle',\n                host: {\n                    'class': 'mat-slide-toggle',\n                    '[id]': 'id',\n                    // Needs to be `-1` so it can still receive programmatic focus.\n                    '[attr.tabindex]': 'disabled ? null : -1',\n                    '[attr.aria-label]': 'null',\n                    '[attr.aria-labelledby]': 'null',\n                    '[class.mat-checked]': 'checked',\n                    '[class.mat-disabled]': 'disabled',\n                    '[class.mat-slide-toggle-label-before]': 'labelPosition == \"before\"',\n                    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                    '(focus)': '_inputElement.nativeElement.focus()',\n                },\n                template: \"<label [attr.for]=\\\"inputId\\\" class=\\\"mat-slide-toggle-label\\\" #label>\\n  <div #toggleBar class=\\\"mat-slide-toggle-bar\\\"\\n       [class.mat-slide-toggle-bar-no-side-margin]=\\\"!labelContent.textContent || !labelContent.textContent.trim()\\\">\\n\\n    <input #input class=\\\"mat-slide-toggle-input cdk-visually-hidden\\\" type=\\\"checkbox\\\"\\n           role=\\\"switch\\\"\\n           [id]=\\\"inputId\\\"\\n           [required]=\\\"required\\\"\\n           [tabIndex]=\\\"tabIndex\\\"\\n           [checked]=\\\"checked\\\"\\n           [disabled]=\\\"disabled\\\"\\n           [attr.name]=\\\"name\\\"\\n           [attr.aria-checked]=\\\"checked.toString()\\\"\\n           [attr.aria-label]=\\\"ariaLabel\\\"\\n           [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n           (change)=\\\"_onChangeEvent($event)\\\"\\n           (click)=\\\"_onInputClick($event)\\\">\\n\\n    <div class=\\\"mat-slide-toggle-thumb-container\\\" #thumbContainer>\\n      <div class=\\\"mat-slide-toggle-thumb\\\"></div>\\n      <div class=\\\"mat-slide-toggle-ripple\\\" mat-ripple\\n           [matRippleTrigger]=\\\"label\\\"\\n           [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n           [matRippleCentered]=\\\"true\\\"\\n           [matRippleRadius]=\\\"20\\\"\\n           [matRippleAnimation]=\\\"{enterDuration: 150}\\\">\\n\\n        <div class=\\\"mat-ripple-element mat-slide-toggle-persistent-ripple\\\"></div>\\n      </div>\\n    </div>\\n\\n  </div>\\n\\n  <span class=\\\"mat-slide-toggle-content\\\" #labelContent (cdkObserveContent)=\\\"_onLabelTextChange()\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\",\n                providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],\n                inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                styles: [\".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatSlideToggle.ctorParameters = () => [\n    { type: ElementRef },\n    { type: FocusMonitor },\n    { type: ChangeDetectorRef },\n    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] }\n];\nMatSlideToggle.propDecorators = {\n    _thumbEl: [{ type: ViewChild, args: ['thumbContainer',] }],\n    _thumbBarEl: [{ type: ViewChild, args: ['toggleBar',] }],\n    name: [{ type: Input }],\n    id: [{ type: Input }],\n    labelPosition: [{ type: Input }],\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\n    required: [{ type: Input }],\n    checked: [{ type: Input }],\n    change: [{ type: Output }],\n    toggleChange: [{ type: Output }],\n    dragChange: [{ type: Output }],\n    _inputElement: [{ type: ViewChild, args: ['input',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatSlideToggle.ngAcceptInputType_required;\n    /** @type {?} */\n    MatSlideToggle.ngAcceptInputType_checked;\n    /** @type {?} */\n    MatSlideToggle.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatSlideToggle.ngAcceptInputType_disableRipple;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._onChange;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._onTouched;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._uniqueId;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._required;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._checked;\n    /**\n     * Reference to the thumb HTMLElement.\n     * @type {?}\n     */\n    MatSlideToggle.prototype._thumbEl;\n    /**\n     * Reference to the thumb bar HTMLElement.\n     * @type {?}\n     */\n    MatSlideToggle.prototype._thumbBarEl;\n    /**\n     * Name value will be applied to the input element if present.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.name;\n    /**\n     * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.id;\n    /**\n     * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.labelPosition;\n    /**\n     * Used to set the aria-label attribute on the underlying input element.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.ariaLabel;\n    /**\n     * Used to set the aria-labelledby attribute on the underlying input element.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.ariaLabelledby;\n    /**\n     * An event will be dispatched each time the slide-toggle changes its value.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.change;\n    /**\n     * An event will be dispatched each time the slide-toggle input is toggled.\n     * This event is always emitted when the user toggles the slide toggle, but this does not mean\n     * the slide toggle's value has changed.\n     * @type {?}\n     */\n    MatSlideToggle.prototype.toggleChange;\n    /**\n     * An event will be dispatched each time the slide-toggle is dragged.\n     * This event is always emitted when the user drags the slide toggle to make a change greater\n     * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n     * the user toggles the slide toggle to change its value.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @type {?}\n     */\n    MatSlideToggle.prototype.dragChange;\n    /**\n     * Reference to the underlying input element.\n     * @type {?}\n     */\n    MatSlideToggle.prototype._inputElement;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._focusMonitor;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSlideToggle.prototype._changeDetectorRef;\n    /** @type {?} */\n    MatSlideToggle.prototype.defaults;\n    /** @type {?} */\n    MatSlideToggle.prototype._animationMode;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/slide-toggle/slide-toggle-required-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef((/**\n     * @return {?}\n     */\n    () => MatSlideToggleRequiredValidator)),\n    multi: true\n};\n/**\n * Validator for Material slide-toggle components with the required attribute in a\n * template-driven form. The default validator for required form controls asserts\n * that the control value is not undefined but that is not appropriate for a slide-toggle\n * where the value is always defined.\n *\n * Required slide-toggle form controls are valid when checked.\n */\nclass MatSlideToggleRequiredValidator extends CheckboxRequiredValidator {\n}\nMatSlideToggleRequiredValidator.decorators = [\n    { type: Directive, args: [{\n                selector: `mat-slide-toggle[required][formControlName],\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]`,\n                providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/slide-toggle/slide-toggle-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * This module is used by both original and MDC-based slide-toggle implementations.\n */\n// tslint:disable-next-line:class-name\nclass _MatSlideToggleRequiredValidatorModule {\n}\n_MatSlideToggleRequiredValidatorModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [MatSlideToggleRequiredValidator],\n                declarations: [MatSlideToggleRequiredValidator],\n            },] }\n];\nclass MatSlideToggleModule {\n}\nMatSlideToggleModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    _MatSlideToggleRequiredValidatorModule,\n                    MatRippleModule,\n                    MatCommonModule,\n                    ObserversModule,\n                ],\n                exports: [\n                    _MatSlideToggleRequiredValidatorModule,\n                    MatSlideToggle,\n                    MatCommonModule\n                ],\n                declarations: [MatSlideToggle],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/slide-toggle/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggle, MatSlideToggleChange, MatSlideToggleModule, MatSlideToggleRequiredValidator, _MatSlideToggleRequiredValidatorModule };\n//# sourceMappingURL=slide-toggle.js.map\n","import { Injectable } from '@angular/core';\r\nimport {\r\n  CanActivate,\r\n  ActivatedRouteSnapshot,\r\n  RouterStateSnapshot,\r\n  Router,\r\n} from '@angular/router';\r\nimport * as firebase from 'firebase/app';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class ClaimsGuard implements CanActivate {\r\n  constructor(private router: Router) {}\r\n\r\n  public canActivate(\r\n    route: ActivatedRouteSnapshot,\r\n    state: RouterStateSnapshot\r\n  ): Promise<boolean> {\r\n    return firebase\r\n      .auth()\r\n      .currentUser.getIdTokenResult()\r\n      .then(\r\n        (idTokenResult) => {\r\n          const hasUserAdminPrivileges = idTokenResult.claims.admin;\r\n          const hasUserStaffPrivileges = idTokenResult.claims.staff;\r\n          if (\r\n            hasUserAdminPrivileges ||\r\n            (hasUserStaffPrivileges && state.url.split('/')[1] === 'staff')\r\n          ) {\r\n            // If the user has admin privileges or staff and we are in the staff layout the route is correct.\r\n            return true;\r\n          } else if (hasUserStaffPrivileges) {\r\n            // If the user has staff privileges but it's on the incorrect route we send it to the staff layout.\r\n            this.router.navigate(['staff']);\r\n            return false;\r\n          } else {\r\n            this.idsDetectedAsInvalid();\r\n            return false;\r\n          }\r\n        },\r\n        () => {\r\n          this.idsDetectedAsInvalid();\r\n          return false;\r\n        }\r\n      );\r\n  }\r\n\r\n  /**\r\n   * If there is a trouble with the session it is tried to finish.\r\n   */\r\n  private idsDetectedAsInvalid(): void {\r\n    localStorage.clear();\r\n    firebase\r\n      .auth()\r\n      .signOut()\r\n      .finally(() => {\r\n        this.router.navigate(['']);\r\n      });\r\n  }\r\n}\r\n"]}