{"version":3,"sources":["webpack:///src/app/shared/components/section-header/section-header.component.ts","webpack:///node_modules/@angular/material/toolbar/index.d.ts.MatToolbar.html","webpack:///node_modules/@angular/cdk/fesm2015/accordion.js","webpack:///node_modules/@angular/material/expansion/index.d.ts.MatExpansionPanel.html","webpack:///node_modules/@angular/material/expansion/index.d.ts.MatExpansionPanelHeader.html","webpack:///src/app/shared/services/menu.service.ts","webpack:///node_modules/@angular/material/fesm2015/toolbar.js","webpack:///node_modules/rxjs/_esm2015/internal/observable/interval.js","webpack:///node_modules/@angular/cdk/fesm2015/drag-drop.js","webpack:///src/app/shared/components/section-header/section-header.module.ts","webpack:///node_modules/@angular/material/fesm2015/expansion.js","webpack:///node_modules/@angular/material/fesm2015/menu.js","webpack:///src/app/shared/components/section-header/section-header.component.html"],"names":["MONTH_YEAR_FORMAT","parse","dateInput","display","monthYearLabel","dateA11yLabel","monthYearA11yLabel","SectionHeaderComponent","router","fb","isMonthsSelectorVisible","hasTheMonthYearCalendarToBeVisible","actionClicked","monthChanged","monthYearChanged","openMenu","form","this","group","month","monthYear","months","name","value","monthYearMaxDate","setactualMonthAsSelected","actualMonth","get","setValue","emit","signOut","then","localStorage","clear","navigate","normalizedYear","yearAux","normalizedMonth","datepicker","ctrlValue","year","close","startOf","valueOf","nextId","CdkAccordion","_stateChanges","_openCloseAllActions","id","_multi","multi","c","_openCloseAll","changes","next","complete","expanded","nextId$1","CdkAccordionItem","accordion","_changeDetectorRef","_expansionDispatcher","_openCloseAllSubscription","EMPTY","closed","opened","destroyed","expandedChange","_expanded","_disabled","_removeUniqueSelectionListener","listen","accordionId","_subscribeToOpenCloseAllActions","notify","markForCheck","disabled","unsubscribe","subscribe","CdkAccordionModule","MenuService","http","restaurantSelected","modifiers","GET_ICONS","DOWNLOAD_TEMPLATE","restaurantId","url","DUPLICATE_MATRIZ_MENU","replace","toString","post","MENUS","menuId","DUPLICATE_MENU","DELETE_MENU","delete","data","CREATE_MENU","EDIT_MENU","put","ORDER_MENU","GET_CATEGORY","CREATE_CATEGORY","categoryId","EDIT_CATEGORY","DUPLICATE_CATEGORY","DELETE_CATEGORY","ORDER_CATEGORY","GET_DISHES","CREATE_DISHE","dishId","EDIT_DISHE","DUPLICATE_DISHE","DELETE_DISHE","ORDER_DISHES","UPDATE_DISH","GET_MODIFIERS","CREATE_MODIFIERS","modifierId","EDIT_MODIFIERS","asObservable","restaurant","DELETE_MODIFIERS","zip","UPLOAD_TEMPLATE","MatToolbarBase","_elementRef","_MatToolbarMixinBase","MatToolbar","elementRef","_platform","document","super","_document","isBrowser","_checkToolbarMixedModes","_toolbarRows","length","Array","from","nativeElement","childNodes","filter","node","classList","contains","nodeType","COMMENT_NODE","some","textContent","trim","Error","MatToolbarModule","dispatch","state","subscriber","counter","period","schedule","extendStyles","dest","source","key","hasOwnProperty","toggleNativeDragInteractions","element","enable","userSelect","style","touchAction","webkitUserDrag","webkitTapHighlightColor","msUserSelect","webkitUserSelect","MozUserSelect","parseCssTimeUnitsToMs","multiplier","toLowerCase","indexOf","parseFloat","parseCssPropertyValue","computedStyle","getPropertyValue","split","map","part","passiveEventListenerOptions","passive","activeEventListenerOptions","_config","_ngZone","_viewportRuler","_dragDropRegistry","_passiveTransform","x","y","_activeTransform","_moveEvents","Subject","_pointerMoveSubscription","Subscription","_pointerUpSubscription","_scrollSubscription","_resizeSubscription","_boundaryElement","_nativeInteractionsEnabled","_handles","_disabledHandles","Set","_direction","dragStartDelay","beforeStarted","started","released","ended","entered","exited","dropped","moved","_pointerDown","event","targetHandle","find","handle","target","has","_initializeDragSequence","_rootElement","_pointerMove","preventDefault","_hasStartedDragging","pointerPosition","_getPointerPositionOnPage","Math","abs","_pickupPositionOnPage","dragStartThreshold","Date","now","_dragStartTime","_getDragStartDelay","_endDragSequence","_dropContainer","isDragging","run","_startDragSequence","_previewRect","width","height","_preview","getBoundingClientRect","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","_updatePointerDirectionDelta","_updateActiveDropContainer","activeTransform","_applyRootElementTransform","SVGElement","setAttribute","observers","distance","_getDragDistance","delta","_pointerDirectionDelta","_pointerUp","withRootElement","registerDragItem","newValue","_toggleNativeDragInteractions","_placeholder","handles","forEach","template","_previewTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","addEventListener","_initialTransform","undefined","boundaryElement","change","_containInsideBoundaryOnResize","removeNode","_anchor","_destroyPreview","_destroyPlaceholder","removeDragItem","_removeSubscriptions","transform","add","direction","container","position","_pointerPositionAtLastDirectionChange","_previewRef","destroy","_placeholderRef","stopDragging","_rootElementTapHighlight","_stopScrolling","_animatePreviewToPlaceholder","_cleanupDragArtifacts","_cleanupCachedDimensions","isTouchEvent","_lastTouchEventTime","parent","preview","_createPreviewElement","placeholder","_createPlaceholderElement","anchor","createComment","insertBefore","body","appendChild","replaceChild","documentRef","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","start","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","draggable","type","_initialContainer","pointerMove","pointerUp","scroll","pipe","startWith","_scrollPosition","getViewportScrollPosition","_boundaryRect","_pickupPositionInElement","_getPointerPositionInElement","startDragging","currentIndex","getItemIndex","isPointerOverContainer","_isOverContainer","item","previousIndex","previousContainer","drop","newContainer","_getSiblingContainerFromPosition","exit","enter","_startScrollingIfNecessary","_sortItem","getTransform","previewConfig","previewClass","previewTemplate","viewRef","viewContainer","createEmbeddedView","context","getRootNode","elementRect","deepCloneNode","left","top","pointerEvents","margin","zIndex","isArray","className","Promise","resolve","placeholderRect","duration","getComputedStyle","transitionedProperties","property","prop","propertyIndex","rawDurations","rawDelays","runOutsideAngular","handler","propertyName","removeEventListener","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","handleElement","referenceRect","point","targetTouches","pageX","pageY","touches","changedTouches","constrainedPoint","constrainPosition","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewRect","minY","maxY","bottom","clamp","right","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","currentPosition","pickupPosition","leftOverflow","rightOverflow","topOverflow","bottomOverflow","setFreeDragPosition","touch","mouse","round","clone","cloneNode","descendantsWithId","querySelectorAll","descendantCanvases","removeAttribute","i","cloneCanvases","correspondingCloneContext","getContext","drawImage","min","max","parentNode","removeChild","rootNode","rootNodes","ELEMENT_NODE","wrapper","createElement","moveItemInArray","array","fromIndex","toIndex","clamp$1","to","sortingDisabled","autoScrollDisabled","enterPredicate","sorted","_isDragging","_itemPositions","_viewportScrollPosition","_previousSwap","drag","_siblings","_orientation","_activeSiblings","_viewportScrollSubscription","_verticalScrollDirection","_horizontalScrollDirection","_stopScrollTimers","_cachedShadowRoot","_handleScroll","_updateAfterScroll","scrollTop","scrollLeft","_startScrollInterval","scheduler","a","isNumeric","Observable","animationFrame","takeUntil","_scrollNode","incrementVerticalScroll","incrementHorizontalScroll","registerDropContainer","_removeListeners","removeDropContainer","_cacheItems","sibling","_startReceiving","_listenToScrollEvents","pointerX","pointerY","newIndex","_draggables","_getItemIndexFromPointerPosition","activeDraggables","_activeDraggables","getPlaceholderElement","newPositionReference","splice","getRootElement","push","_cacheItemPositions","_reset","items","_withDropContainer","connectedTo","slice","orientation","findIndex","reverse","currentItem","size","pointerDelta","_isPointerNearDropContainer","siblings","isHorizontal","siblingAtNewPosition","clientRect","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","index","isDraggedItem","offset","elementToOffset","adjustClientRect","scrollNode","verticalScrollDirection","horizontalScrollDirection","computedVertical","getVerticalScrollDirection","computedHorizontal","getHorizontalScrollDirection","scrollHeight","clientHeight","scrollWidth","clientWidth","_clientRect","getViewportSize","window","getMutableClientRect","elementToMeasure","sort","b","_stopReceiving","immediateSibling","end","xThreshold","yThreshold","_","floor","_cacheOwnPosition","scrollPosition","newTop","newLeft","extraClientRect","topDifference","leftDifference","_sortFromLastPointerPosition","isInsideClientRect","_canReceive","elementFromPoint","_getShadowRoot","activeSiblings","isReceiving","ShadowRoot","predicate","amount","scrollBy","activeCapturingEventOptions","capture","DragDropRegistry","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","Map","_preventDefaultWhileDragging","startsWith","upEvent","set","e","options","config","_clearGlobalListeners","instance","Éµprov","factory","token","providedIn","DEFAULT_CONFIG","DragDrop","CDK_DRAG_PARENT","CDK_DROP_LIST","CDK_DRAG_CONFIG","dropContainer","_viewContainerRef","_dir","dragDrop","_destroyed","observer","subscription","_dragRef","movedEvent","createDrag","_dropListRef","_syncInputs","_handleEvents","reset","getFreeDragPosition","onStable","take","_updateRootElement","tap","childHandleElements","_parentDrag","withHandles","switchMap","merge","handleInstance","dragRef","disableHandle","enableHandle","freeDragPosition","rootSelectorChange","positionChange","firstChange","dispose","rootElementSelector","getClosestMatchingAncestor","nodeName","boundary","ref","dir","templateRef","withBoundaryElement","_getBoundaryElement","withPlaceholderTemplate","withPreviewTemplate","withDirection","selector","currentElement","matches","msMatchesSelector","parentElement","_items","_uniqueIdCounter","CdkDropList","_group","createDropList","_setupInputSyncSubscription","_dropLists","withItems","reduce","filteredItems","list","withOrientation","DragDropModule","SectionHeaderModule","MAT_ACCORDION","uniqueId","MAT_EXPANSION_PANEL_DEFAULT_OPTIONS","MatExpansionPanel","_uniqueSelectionDispatcher","_animationMode","defaultOptions","_hideToggle","afterExpand","afterCollapse","_inputChanges","_headerId","_bodyAnimationDone","fromState","toState","hideToggle","_togglePosition","togglePosition","displayMode","_lazyContent","_portal","_template","ngOnDestroy","_body","focusedElement","activeElement","bodyElement","MatExpansionPanelHeader","panel","_element","_focusMonitor","_parentChangeSubscription","_animationsDisabled","accordionHideToggleChange","_containsFocus","focusVia","monitor","origin","_handleHeaderFocus","expandedHeight","collapsedHeight","toggle","_getExpandedState","keyCode","_toggle","_handleHeaderKeydown","stopMonitoring","MatExpansionPanelTitle","MatAccordion","arguments","_ownHeaders","show","_headers","headers","header","notifyOnChanges","_keyManager","withWrap","manager","setFirstItemActive","setLastItemActive","onKeydown","updateActiveItem","MatExpansionModule","MAT_MENU_PANEL","MatMenuItemBase","_MatMenuItemMixinBase","MatMenuItem","_parentMenu","role","_hovered","_focused","_highlighted","_triggersSubmenu","addItem","_getHostElement","focus","removeItem","textNodeType","TEXT_NODE","output","MAT_MENU_DEFAULT_OPTIONS","overlapTrigger","xPosition","yPosition","backdropClass","menuPanelUid","MatMenu","_defaultOptions","_xPosition","_yPosition","_directDescendantItems","_tabSubscription","_classList","_panelAnimationState","_animationDone","_overlapTrigger","_hasBackdrop","hasBackdrop","panelId","setPositionClasses","classes","previousPanelClass","_previousPanelClass","panelClass","_updateDirectDescendants","withTypeAhead","tabOut","focusedItem","_item","parentMenu","setFocusOrigin","lazyContent","_focusFirstItem","activeItem","first","getAttribute","setActiveItem","depth","newElevation","customElevation","Object","keys","_previousElevation","posX","posY","_isAnimating","activeItemIndex","_allItems","_MatMenu","ngZone","MAT_MENU_SCROLL_STRATEGY","MAT_MENU_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MatMenuTrigger","_overlay","scrollStrategy","_menuItemInstance","_overlayRef","_menuOpen","_closingActionsSubscription","_hoverSubscription","_menuCloseSubscription","_handleTouchStart","_openedBy","restoreFocus","menuOpened","onMenuOpen","menuClosed","onMenuClose","triggersSubmenu","_scrollStrategy","menu","v","_menu","reason","_destroyMenu","_checkMenu","_handleHover","closeMenu","overlayRef","_createOverlay","overlayConfig","getConfig","_setPosition","attach","_getPortal","menuData","_menuClosingActions","_initMenu","_startAnimation","menuOpen","detach","_resetAnimation","_attached","_setIsMenuOpen","_restoreFocus","_setMenuElevation","focusFirstItem","setElevation","isOpen","_getOverlayConfig","_subscribeToPositions","create","keydownEvents","positionStrategy","flexibleConnectedTo","withLockedPosition","withTransformOriginOn","positionChanges","connectionPair","overlayX","overlayY","originX","originFallbackX","overlayFallbackY","originY","originFallbackY","overlayFallbackX","offsetY","withPositions","backdrop","backdropClick","detachments","parentClose","hover","active","toggleMenu","_MatMenuDirectivesModule","MatMenuModule"],"mappings":"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","file":"x","sourcesContent":["import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';\r\nimport * as firebase from 'firebase/app';\r\nimport { Router } from '@angular/router';\r\nimport * as moment from 'moment';\r\nimport { FormBuilder } from '@angular/forms';\r\nimport {\r\n  MomentDateAdapter,\r\n  MAT_MOMENT_DATE_ADAPTER_OPTIONS,\r\n} from '@angular/material-moment-adapter';\r\nimport {\r\n  DateAdapter,\r\n  MAT_DATE_FORMATS,\r\n  MAT_DATE_LOCALE,\r\n} from '@angular/material/core';\r\nimport { MatDatepicker } from '@angular/material/datepicker';\r\n\r\n// Formats of the month/year calendar.\r\nexport const MONTH_YEAR_FORMAT = {\r\n  parse: {\r\n    dateInput: 'MM/YYYY',\r\n  },\r\n  display: {\r\n    dateInput: 'MMMM YYYY',\r\n    monthYearLabel: 'MMM YYYY',\r\n    dateA11yLabel: 'LL',\r\n    monthYearA11yLabel: 'MMMM YYYY',\r\n  },\r\n};\r\n\r\n@Component({\r\n  selector: 'app-section-header',\r\n  templateUrl: './section-header.component.html',\r\n  styleUrls: ['./section-header.component.scss'],\r\n  providers: [\r\n    {\r\n      provide: DateAdapter,\r\n      useClass: MomentDateAdapter,\r\n      deps: [MAT_DATE_LOCALE, MAT_MOMENT_DATE_ADAPTER_OPTIONS],\r\n    },\r\n\r\n    { provide: MAT_DATE_FORMATS, useValue: MONTH_YEAR_FORMAT },\r\n  ],\r\n})\r\nexport class SectionHeaderComponent implements OnInit {\r\n  @Input() sectionName: string;\r\n  @Input() actionName: string;\r\n  @Input() isMonthsSelectorVisible = false;\r\n\r\n  /**\r\n   * Indicates if the month/year calendar should be visible.\r\n   */\r\n  @Input() hasTheMonthYearCalendarToBeVisible = false;\r\n\r\n  @Output() actionClicked: EventEmitter<void> = new EventEmitter<void>();\r\n  @Output() monthChanged: EventEmitter<number> = new EventEmitter<number>();\r\n  @Output() monthYearChanged: EventEmitter<number> = new EventEmitter<number>();\r\n  public openMenu = false;\r\n\r\n  public form = this.fb.group({\r\n    month: [''],\r\n    monthYear: [moment()],\r\n  });\r\n\r\n  public yearAux: moment.Moment;\r\n\r\n  public months: Array<{ name: string; value: number }> = [\r\n    { name: 'Enero', value: 0 },\r\n    { name: 'Febrero', value: 1 },\r\n    { name: 'Marzo', value: 2 },\r\n    { name: 'Abril', value: 3 },\r\n    { name: 'Mayo', value: 4 },\r\n    { name: 'Junio', value: 5 },\r\n    { name: 'Julio', value: 6 },\r\n    { name: 'Agosto', value: 7 },\r\n    { name: 'Septiembre', value: 8 },\r\n    { name: 'Octubre', value: 9 },\r\n    { name: 'Noviembre', value: 10 },\r\n    { name: 'Diciembre', value: 11 },\r\n  ];\r\n\r\n  /**\r\n   * Max date to limit the month year calendar.\r\n   */\r\n  public monthYearMaxDate = moment();\r\n\r\n  constructor(private router: Router, private fb: FormBuilder) {}\r\n\r\n  ngOnInit(): void {\r\n    this.setactualMonthAsSelected();\r\n  }\r\n\r\n  private setactualMonthAsSelected(): void {\r\n    const actualMonth = moment().get('month');\r\n    this.form.get('month').setValue(actualMonth);\r\n  }\r\n\r\n  public emitActionClicked(): void {\r\n    this.actionClicked.emit();\r\n  }\r\n\r\n  public logout(): void {\r\n    firebase\r\n      .auth()\r\n      .signOut()\r\n      .then(() => {\r\n        localStorage.clear();\r\n        this.router.navigate(['/login']);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Function that stores the selected year at a global variable.\r\n   * @param normalizedYear Moment type date so store.\r\n   */\r\n  public chosenYearHandler(normalizedYear: moment.Moment): void {\r\n    this.yearAux = normalizedYear;\r\n  }\r\n\r\n  /**\r\n   * Function that takes the selected month and saved to emit the selected date.\r\n   * @param normalizedMonth Month to create the date to emit.\r\n   * @param datepicker Reference to the calendar to call its functions.\r\n   */\r\n  public chosenMonthHandler(\r\n    normalizedMonth: moment.Moment,\r\n    datepicker: MatDatepicker<moment.Moment>\r\n  ) {\r\n    const ctrlValue = this.form.get('monthYear').value;\r\n    ctrlValue.month(normalizedMonth.month());\r\n    ctrlValue.year(this.yearAux.year());\r\n    this.form.get('monthYear').setValue(ctrlValue);\r\n    datepicker.close();\r\n    this.monthYearChanged.emit(\r\n      this.form.get('monthYear').value.startOf('month').valueOf()\r\n    );\r\n  }\r\n}\r\n","<ng-content></ng-content>\n<ng-content select=\"mat-toolbar-row\"></ng-content>\n","import { Directive, Input, EventEmitter, Optional, SkipSelf, ChangeDetectorRef, Output, NgModule } from '@angular/core';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Subject, Subscription } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to generate unique ID for each accordion.\n * @type {?}\n */\nlet nextId = 0;\n/**\n * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.\n */\nclass CdkAccordion {\n    constructor() {\n        /**\n         * Emits when the state of the accordion changes\n         */\n        this._stateChanges = new Subject();\n        /**\n         * Stream that emits true/false when openAll/closeAll is triggered.\n         */\n        this._openCloseAllActions = new Subject();\n        /**\n         * A readonly id value to use for unique selection coordination.\n         */\n        this.id = `cdk-accordion-${nextId++}`;\n        this._multi = false;\n    }\n    /**\n     * Whether the accordion should allow multiple expanded accordion items simultaneously.\n     * @return {?}\n     */\n    get multi() { return this._multi; }\n    /**\n     * @param {?} multi\n     * @return {?}\n     */\n    set multi(multi) { this._multi = coerceBooleanProperty(multi); }\n    /**\n     * Opens all enabled accordion items in an accordion where multi is enabled.\n     * @return {?}\n     */\n    openAll() {\n        this._openCloseAll(true);\n    }\n    /**\n     * Closes all enabled accordion items in an accordion where multi is enabled.\n     * @return {?}\n     */\n    closeAll() {\n        this._openCloseAll(false);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this._stateChanges.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n    /**\n     * @private\n     * @param {?} expanded\n     * @return {?}\n     */\n    _openCloseAll(expanded) {\n        if (this.multi) {\n            this._openCloseAllActions.next(expanded);\n        }\n    }\n}\nCdkAccordion.decorators = [\n    { type: Directive, args: [{\n                selector: 'cdk-accordion, [cdkAccordion]',\n                exportAs: 'cdkAccordion',\n            },] }\n];\nCdkAccordion.propDecorators = {\n    multi: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    CdkAccordion.ngAcceptInputType_multi;\n    /**\n     * Emits when the state of the accordion changes\n     * @type {?}\n     */\n    CdkAccordion.prototype._stateChanges;\n    /**\n     * Stream that emits true/false when openAll/closeAll is triggered.\n     * @type {?}\n     */\n    CdkAccordion.prototype._openCloseAllActions;\n    /**\n     * A readonly id value to use for unique selection coordination.\n     * @type {?}\n     */\n    CdkAccordion.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordion.prototype._multi;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion-item.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to generate unique ID for each accordion item.\n * @type {?}\n */\nlet nextId$1 = 0;\nconst Éµ0 = undefined;\n/**\n * An basic directive expected to be extended and decorated as a component.  Sets up all\n * events and attributes needed to be managed by a CdkAccordion parent.\n */\nclass CdkAccordionItem {\n    /**\n     * @param {?} accordion\n     * @param {?} _changeDetectorRef\n     * @param {?} _expansionDispatcher\n     */\n    constructor(accordion, _changeDetectorRef, _expansionDispatcher) {\n        this.accordion = accordion;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._expansionDispatcher = _expansionDispatcher;\n        /**\n         * Subscription to openAll/closeAll events.\n         */\n        this._openCloseAllSubscription = Subscription.EMPTY;\n        /**\n         * Event emitted every time the AccordionItem is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted every time the AccordionItem is opened.\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event emitted when the AccordionItem is destroyed.\n         */\n        this.destroyed = new EventEmitter();\n        /**\n         * Emits whenever the expanded state of the accordion changes.\n         * Primarily used to facilitate two-way binding.\n         * \\@docs-private\n         */\n        this.expandedChange = new EventEmitter();\n        /**\n         * The unique AccordionItem id.\n         */\n        this.id = `cdk-accordion-child-${nextId$1++}`;\n        this._expanded = false;\n        this._disabled = false;\n        /**\n         * Unregister function for _expansionDispatcher.\n         */\n        this._removeUniqueSelectionListener = (/**\n         * @return {?}\n         */\n        () => { });\n        this._removeUniqueSelectionListener =\n            _expansionDispatcher.listen((/**\n             * @param {?} id\n             * @param {?} accordionId\n             * @return {?}\n             */\n            (id, accordionId) => {\n                if (this.accordion && !this.accordion.multi &&\n                    this.accordion.id === accordionId && this.id !== id) {\n                    this.expanded = false;\n                }\n            }));\n        // When an accordion item is hosted in an accordion, subscribe to open/close events.\n        if (this.accordion) {\n            this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();\n        }\n    }\n    /**\n     * Whether the AccordionItem is expanded.\n     * @return {?}\n     */\n    get expanded() { return this._expanded; }\n    /**\n     * @param {?} expanded\n     * @return {?}\n     */\n    set expanded(expanded) {\n        expanded = coerceBooleanProperty(expanded);\n        // Only emit events and update the internal value if the value changes.\n        if (this._expanded !== expanded) {\n            this._expanded = expanded;\n            this.expandedChange.emit(expanded);\n            if (expanded) {\n                this.opened.emit();\n                /**\n                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,\n                 * the name value is the id of the accordion.\n                 * @type {?}\n                 */\n                const accordionId = this.accordion ? this.accordion.id : this.id;\n                this._expansionDispatcher.notify(this.id, accordionId);\n            }\n            else {\n                this.closed.emit();\n            }\n            // Ensures that the animation will run when the value is set outside of an `@Input`.\n            // This includes cases like the open, close and toggle methods.\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Whether the AccordionItem is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    set disabled(disabled) { this._disabled = coerceBooleanProperty(disabled); }\n    /**\n     * Emits an event for the accordion item being destroyed.\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.opened.complete();\n        this.closed.complete();\n        this.destroyed.emit();\n        this.destroyed.complete();\n        this._removeUniqueSelectionListener();\n        this._openCloseAllSubscription.unsubscribe();\n    }\n    /**\n     * Toggles the expanded state of the accordion item.\n     * @return {?}\n     */\n    toggle() {\n        if (!this.disabled) {\n            this.expanded = !this.expanded;\n        }\n    }\n    /**\n     * Sets the expanded state of the accordion item to false.\n     * @return {?}\n     */\n    close() {\n        if (!this.disabled) {\n            this.expanded = false;\n        }\n    }\n    /**\n     * Sets the expanded state of the accordion item to true.\n     * @return {?}\n     */\n    open() {\n        if (!this.disabled) {\n            this.expanded = true;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _subscribeToOpenCloseAllActions() {\n        return this.accordion._openCloseAllActions.subscribe((/**\n         * @param {?} expanded\n         * @return {?}\n         */\n        expanded => {\n            // Only change expanded state if item is enabled\n            if (!this.disabled) {\n                this.expanded = expanded;\n            }\n        }));\n    }\n}\nCdkAccordionItem.decorators = [\n    { type: Directive, args: [{\n                selector: 'cdk-accordion-item, [cdkAccordionItem]',\n                exportAs: 'cdkAccordionItem',\n                providers: [\n                    // Provide CdkAccordion as undefined to prevent nested accordion items from registering\n                    // to the same accordion.\n                    { provide: CdkAccordion, useValue: Éµ0 },\n                ],\n            },] }\n];\n/** @nocollapse */\nCdkAccordionItem.ctorParameters = () => [\n    { type: CdkAccordion, decorators: [{ type: Optional }, { type: SkipSelf }] },\n    { type: ChangeDetectorRef },\n    { type: UniqueSelectionDispatcher }\n];\nCdkAccordionItem.propDecorators = {\n    closed: [{ type: Output }],\n    opened: [{ type: Output }],\n    destroyed: [{ type: Output }],\n    expandedChange: [{ type: Output }],\n    expanded: [{ type: Input }],\n    disabled: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    CdkAccordionItem.ngAcceptInputType_expanded;\n    /** @type {?} */\n    CdkAccordionItem.ngAcceptInputType_disabled;\n    /**\n     * Subscription to openAll/closeAll events.\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._openCloseAllSubscription;\n    /**\n     * Event emitted every time the AccordionItem is closed.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.closed;\n    /**\n     * Event emitted every time the AccordionItem is opened.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.opened;\n    /**\n     * Event emitted when the AccordionItem is destroyed.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.destroyed;\n    /**\n     * Emits whenever the expanded state of the accordion changes.\n     * Primarily used to facilitate two-way binding.\n     * \\@docs-private\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.expandedChange;\n    /**\n     * The unique AccordionItem id.\n     * @type {?}\n     */\n    CdkAccordionItem.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._expanded;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._disabled;\n    /**\n     * Unregister function for _expansionDispatcher.\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._removeUniqueSelectionListener;\n    /** @type {?} */\n    CdkAccordionItem.prototype.accordion;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkAccordionItem.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CdkAccordionItem.prototype._expansionDispatcher;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/accordion-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass CdkAccordionModule {\n}\nCdkAccordionModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [CdkAccordion, CdkAccordionItem],\n                declarations: [CdkAccordion, CdkAccordionItem],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/accordion/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkAccordion, CdkAccordionItem, CdkAccordionModule };\n//# sourceMappingURL=accordion.js.map\n","<ng-content select=\"mat-expansion-panel-header\"></ng-content>\n<div class=\"mat-expansion-panel-content\"\n     role=\"region\"\n     [@bodyExpansion]=\"_getExpandedState()\"\n     (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\"\n     [attr.aria-labelledby]=\"_headerId\"\n     [id]=\"id\"\n     #body>\n  <div class=\"mat-expansion-panel-body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"_portal\"></ng-template>\n  </div>\n  <ng-content select=\"mat-action-row\"></ng-content>\n</div>\n","<span class=\"mat-content\">\n  <ng-content select=\"mat-panel-title\"></ng-content>\n  <ng-content select=\"mat-panel-description\"></ng-content>\n  <ng-content></ng-content>\n</span>\n<span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\"\n      class=\"mat-expansion-indicator\"></span>\n","import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from '@environments/environment';\r\nimport { Modifiers } from '@models';\r\nimport { Subject, Observable } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class MenuService {\r\n  public restaurantSelected = new Subject<number>();\r\n  public modifiers: Modifiers[] = [];\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  public getIcons(): Observable<any> {\r\n    return this.http.get<any>(environment.GET_ICONS);\r\n  }\r\n  public getTemplate(): Observable<any> {\r\n    return this.http.get<any>(environment.DOWNLOAD_TEMPLATE);\r\n  }\r\n  public duplicateMatrizMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_MATRIZ_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public getMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.MENUS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public duplicateMenu(menuId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_MENU.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteMenu(restaurantId: number): Observable<any> {\r\n    const url = environment.DELETE_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public createMenu(data: any, restaurantId: number): Observable<any> {\r\n    const url = environment.CREATE_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editMenu(data: any, menuId: number): Observable<any> {\r\n    const url = environment.EDIT_MENU.replace('{menuId}', menuId.toString());\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public orderMenu(restaurantId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_MENU.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n\r\n  public getCategory(menuId: number): Observable<any> {\r\n    const url = environment.GET_CATEGORY.replace('{menuId}', menuId.toString());\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createCategory(data: any, menuId: number): Observable<any> {\r\n    const url = environment.CREATE_CATEGORY.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editCategory(data: any, categoryId: number): Observable<any> {\r\n    const url = environment.EDIT_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public duplicateCategory(categoryId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteCategory(categoryId: number): Observable<any> {\r\n    const url = environment.DELETE_CATEGORY.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public orderCategory(menuId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_CATEGORY.replace(\r\n      '{menuId}',\r\n      menuId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n\r\n  public getDishes(categoryId: number): Observable<any> {\r\n    const url = environment.GET_DISHES.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createDishes(data: any, categoryId: number): Observable<any> {\r\n    const url = environment.CREATE_DISHE.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editDishes(data: any, dishId: number): Observable<any> {\r\n    const url = environment.EDIT_DISHE.replace('{dishId}', dishId.toString());\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public duplicateDishes(dishId: number): Observable<any> {\r\n    const url = environment.DUPLICATE_DISHE.replace(\r\n      '{dishId}',\r\n      dishId.toString()\r\n    );\r\n    return this.http.post<any>(url, null);\r\n  }\r\n  public deleteDishes(dishId: number): Observable<any> {\r\n    const url = environment.DELETE_DISHE.replace('{dishId}', dishId.toString());\r\n    return this.http.delete<any>(url);\r\n  }\r\n  public orderDishes(categoryId: number, data: any): Observable<any> {\r\n    const url = environment.ORDER_DISHES.replace(\r\n      '{categoryId}',\r\n      categoryId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public updateDishStatus(dishId: number): Observable<any> {\r\n    const url = environment.UPDATE_DISH.replace('{dishId}', dishId.toString());\r\n    return this.http.put<any>(url, {});\r\n  }\r\n  public getModifier(restaurantId: number): Observable<any> {\r\n    const url = environment.GET_MODIFIERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.get<any>(url);\r\n  }\r\n  public createModifier(data: any, restaurantId: number): Observable<any> {\r\n    const url = environment.CREATE_MODIFIERS.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post<any>(url, data);\r\n  }\r\n  public editModifier(data: any, modifierId: number): Observable<any> {\r\n    const url = environment.EDIT_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.put<any>(url, data);\r\n  }\r\n  public deleteModifier(modifierId: number): Observable<any> {\r\n    const url = environment.EDIT_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.delete<any>(url);\r\n  }\r\n\r\n  public getRestaurant(): Observable<any> {\r\n    return this.restaurantSelected.asObservable();\r\n  }\r\n  public updateRestaurant(restaurant: any) {\r\n    this.restaurantSelected.next(restaurant);\r\n  }\r\n\r\n  public deleteModifierLocal(modifierId: number) {\r\n    const url = environment.DELETE_MODIFIERS.replace(\r\n      '{modifierId}',\r\n      modifierId.toString()\r\n    );\r\n    return this.http.delete(url);\r\n  }\r\n\r\n  public uploadZip(zip: FormData, restaurantId: number) {\r\n    const url = environment.UPLOAD_TEMPLATE.replace(\r\n      '{restaurantId}',\r\n      restaurantId.toString()\r\n    );\r\n    return this.http.post(url, zip);\r\n  }\r\n}\r\n","import { Directive, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/toolbar.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatToolbar.\n/**\n * \\@docs-private\n */\nclass MatToolbarBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatToolbarBase.prototype._elementRef;\n}\n/** @type {?} */\nconst _MatToolbarMixinBase = mixinColor(MatToolbarBase);\nclass MatToolbarRow {\n}\nMatToolbarRow.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-toolbar-row',\n                exportAs: 'matToolbarRow',\n                host: { 'class': 'mat-toolbar-row' },\n            },] }\n];\nclass MatToolbar extends _MatToolbarMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _platform\n     * @param {?=} document\n     */\n    constructor(elementRef, _platform, document) {\n        super(elementRef);\n        this._platform = _platform;\n        // TODO: make the document a required param when doing breaking changes.\n        this._document = document;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!isDevMode() || !this._platform.isBrowser) {\n            return;\n        }\n        this._checkToolbarMixedModes();\n        this._toolbarRows.changes.subscribe((/**\n         * @return {?}\n         */\n        () => this._checkToolbarMixedModes()));\n    }\n    /**\n     * Throws an exception when developers are attempting to combine the different toolbar row modes.\n     * @private\n     * @return {?}\n     */\n    _checkToolbarMixedModes() {\n        if (!this._toolbarRows.length) {\n            return;\n        }\n        // Check if there are any other DOM nodes that can display content but aren't inside of\n        // a <mat-toolbar-row> element.\n        /** @type {?} */\n        const isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes)\n            .filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => !(node.classList && node.classList.contains('mat-toolbar-row'))))\n            .filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)))\n            .some((/**\n         * @param {?} node\n         * @return {?}\n         */\n        node => !!(node.textContent && node.textContent.trim())));\n        if (isCombinedUsage) {\n            throwToolbarMixedModesError();\n        }\n    }\n}\nMatToolbar.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-toolbar',\n                exportAs: 'matToolbar',\n                template: \"<ng-content></ng-content>\\n<ng-content select=\\\"mat-toolbar-row\\\"></ng-content>\\n\",\n                inputs: ['color'],\n                host: {\n                    'class': 'mat-toolbar',\n                    '[class.mat-toolbar-multiple-rows]': '_toolbarRows.length > 0',\n                    '[class.mat-toolbar-single-row]': '_toolbarRows.length === 0',\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                styles: [\".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatToolbar.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nMatToolbar.propDecorators = {\n    _toolbarRows: [{ type: ContentChildren, args: [MatToolbarRow, { descendants: true },] }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatToolbar.prototype._document;\n    /**\n     * Reference to all toolbar row elements that have been projected.\n     * @type {?}\n     */\n    MatToolbar.prototype._toolbarRows;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatToolbar.prototype._platform;\n}\n/**\n * Throws an exception when attempting to combine the different toolbar row modes.\n * \\@docs-private\n * @return {?}\n */\nfunction throwToolbarMixedModesError() {\n    throw Error('MatToolbar: Attempting to combine different toolbar modes. ' +\n        'Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content ' +\n        'inside of a `<mat-toolbar>` for a single row.');\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/toolbar-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatToolbarModule {\n}\nMatToolbarModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [MatCommonModule],\n                exports: [MatToolbar, MatToolbarRow, MatCommonModule],\n                declarations: [MatToolbar, MatToolbarRow],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/toolbar/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatToolbar, MatToolbarModule, MatToolbarRow, throwToolbarMixedModesError };\n//# sourceMappingURL=toolbar.js.map\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period = 0, scheduler = async) {\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(subscriber => {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, counter, period } = state;\n    subscriber.next(counter);\n    this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n//# sourceMappingURL=interval.js.map","import { Injectable, NgZone, Inject, ÉµÉµdefineInjectable, ÉµÉµinject, InjectionToken, Directive, ElementRef, Optional, Input, TemplateRef, EventEmitter, isDevMode, SkipSelf, ViewContainerRef, ChangeDetectorRef, ContentChildren, ContentChild, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { normalizePassiveListenerOptions, _supportsShadowDom } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { Subject, Subscription, interval, animationFrameScheduler, Observable, merge } from 'rxjs';\nimport { startWith, takeUntil, map, take, tap, switchMap } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-styling.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extended CSSStyleDeclaration that includes a couple of drag-related\n * properties that aren't in the built-in TS typings.\n * @record\n */\nfunction DragCSSStyleDeclaration() { }\nif (false) {\n    /** @type {?} */\n    DragCSSStyleDeclaration.prototype.webkitUserDrag;\n    /** @type {?} */\n    DragCSSStyleDeclaration.prototype.MozUserSelect;\n}\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = (/** @type {?} */ (source[key]));\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/transition-duration.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    const computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    const property = transitionedProperties.find((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => prop === 'transform' || prop === 'all'));\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    const propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map((/**\n     * @param {?} part\n     * @return {?}\n     */\n    part => part.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Object that can be used to configure the behavior of DragRef.\n * @record\n */\nfunction DragRefConfig() { }\nif (false) {\n    /**\n     * Minimum amount of pixels that the user should\n     * drag, before the CDK initiates a drag sequence.\n     * @type {?}\n     */\n    DragRefConfig.prototype.dragStartThreshold;\n    /**\n     * Amount the pixels the user should drag before the CDK\n     * considers them to have changed the drag direction.\n     * @type {?}\n     */\n    DragRefConfig.prototype.pointerDirectionChangeThreshold;\n}\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Internal compile-time-only representation of a `DragRef`.\n * Used to avoid circular import issues between the `DragRef` and the `DropListRef`.\n * \\@docs-private\n * @record\n */\nfunction DragRefInternal() { }\n/**\n * Template that can be used to create a drag helper element (e.g. a preview or a placeholder).\n * @record\n * @template T\n */\nfunction DragHelperTemplate() { }\nif (false) {\n    /** @type {?} */\n    DragHelperTemplate.prototype.template;\n    /** @type {?} */\n    DragHelperTemplate.prototype.viewContainer;\n    /** @type {?} */\n    DragHelperTemplate.prototype.context;\n}\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * @template T\n */\nclass DragRef {\n    /**\n     * @param {?} element\n     * @param {?} _config\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being scrolled.\n         */\n        this._scrollSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being resized.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new Subject();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new Subject();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new Subject();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents.asObservable();\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                /** @type {?} */\n                const targetHandle = this._handles.find((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => {\n                    /** @type {?} */\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                }));\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        });\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Prevent the default action as early as possible in order to block\n            // native actions like dragging the selected text or images with the mouse.\n            event.preventDefault();\n            if (!this._hasStartedDragging) {\n                /** @type {?} */\n                const pointerPosition = this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                /** @type {?} */\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                /** @type {?} */\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    /** @type {?} */\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!this._dropContainer || !this._dropContainer.isDragging()) {\n                        this._hasStartedDragging = true;\n                        this._ngZone.run((/**\n                         * @return {?}\n                         */\n                        () => this._startDragSequence(event)));\n                    }\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(event);\n            this._hasMoved = true;\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta\n                    });\n                }));\n            }\n        });\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this._endDragSequence(event);\n        });\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        /** @type {?} */\n        const newValue = coerceBooleanProperty(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    withHandles(handles) {\n        (/** @type {?} */ (this))._handles = handles.map((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => coerceElement(handle)));\n        (/** @type {?} */ (this))._handles.forEach((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => toggleNativeDragInteractions(handle, false)));\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    withPreviewTemplate(template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    withPlaceholderTemplate(template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    withRootElement(rootElement) {\n        /** @type {?} */\n        const element = coerceElement(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    withBoundaryElement(boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        (/** @type {?} */ (this))._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            (/** @type {?} */ (this))._resizeSubscription = (/** @type {?} */ (this))._viewportRuler\n                .change(10)\n                .subscribe((/**\n             * @return {?}\n             */\n            () => (/** @type {?} */ (this))._containInsideBoundaryOnResize()));\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeNode(this._rootElement);\n        }\n        removeNode(this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._resizeSubscription.unsubscribe();\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._anchor = (/** @type {?} */ (null));\n    }\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    disableHandle(handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    enableHandle(handle) {\n        this._disabledHandles.delete(handle);\n    }\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        /** @type {?} */\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} value New position to be set.\n     * @return {THIS}\n     */\n    setFreeDragPosition(value) {\n        (/** @type {?} */ (this))._activeTransform = { x: 0, y: 0 };\n        (/** @type {?} */ (this))._passiveTransform.x = value.x;\n        (/** @type {?} */ (this))._passiveTransform.y = value.y;\n        if (!(/** @type {?} */ (this))._dropContainer) {\n            (/** @type {?} */ (this))._applyRootElementTransform(value.x, value.y);\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Updates the item's sort order based on the last-known pointer position.\n     * @return {?}\n     */\n    _sortFromLastPointerPosition() {\n        /** @type {?} */\n        const position = this._pointerPositionAtLastDirectionChange;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(position);\n        }\n    }\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPreview() {\n        if (this._preview) {\n            removeNode(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeNode(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @private\n     * @param {?} event Browser event object that ended the sequence.\n     * @return {?}\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then((/**\n             * @return {?}\n             */\n            () => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            }));\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(this._getPointerPositionOnPage(event))\n                });\n            }));\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _startDragSequence(event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        if (this._dropContainer) {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const parent = (/** @type {?} */ (element.parentNode));\n            /** @type {?} */\n            const preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            /** @type {?} */\n            const anchor = this._anchor = this._anchor || this._document.createComment('');\n            // Insert an anchor node so that we can restore the element's position in the DOM.\n            parent.insertBefore(anchor, element);\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild(parent.replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document).appendChild(preview);\n            this._dropContainer.start();\n        }\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        const isDragging = this.isDragging();\n        /** @type {?} */\n        const isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        const isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        const rootElement = this._rootElement;\n        /** @type {?} */\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry.scroll.pipe(startWith(null)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        }));\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        const pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        (/** @type {?} */ (this._anchor.parentNode)).replaceChild(this._rootElement, this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const container = (/** @type {?} */ (this._dropContainer));\n            /** @type {?} */\n            const currentIndex = container.getItemIndex(this);\n            /** @type {?} */\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            /** @type {?} */\n            const distance = this._getDragDistance(this._getPointerPositionOnPage(event));\n            /** @type {?} */\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialContainer.getItemIndex(this),\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance\n            });\n            container.drop(this, currentIndex, this._initialContainer, isPointerOverContainer, distance);\n            this._dropContainer = this._initialContainer;\n        }));\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    _updateActiveDropContainer({ x, y }) {\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: (/** @type {?} */ (this._dropContainer)) });\n                (/** @type {?} */ (this._dropContainer)).exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = (/** @type {?} */ (newContainer));\n                this._dropContainer.enter(this, x, y);\n                this.entered.next({\n                    item: this,\n                    container: (/** @type {?} */ (newContainer)),\n                    currentIndex: (/** @type {?} */ (newContainer)).getItemIndex(this)\n                });\n            }));\n        }\n        (/** @type {?} */ (this._dropContainer))._startScrollingIfNecessary(x, y);\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    _createPreviewElement() {\n        /** @type {?} */\n        const previewConfig = this._previewTemplate;\n        /** @type {?} */\n        const previewClass = this.previewClass;\n        /** @type {?} */\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        let preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            const viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = `${elementRect.width}px`;\n            preview.style.height = `${elementRect.height}px`;\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            // We have to reset the margin, because it can throw off positioning relative to the viewport.\n            margin: '0',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        if (previewClass) {\n            if (Array.isArray(previewClass)) {\n                previewClass.forEach((/**\n                 * @param {?} className\n                 * @return {?}\n                 */\n                className => preview.classList.add(className)));\n            }\n            else {\n                preview.classList.add(previewClass);\n            }\n        }\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            resolve => {\n                /** @type {?} */\n                const handler = (/** @type {?} */ (((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }))));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                const timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            }));\n        }));\n    }\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    _createPlaceholderElement() {\n        /** @type {?} */\n        const placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        const x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        const y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getPointerPositionOnPage(event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        const point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    }\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getConstrainedPointerPosition(event) {\n        /** @type {?} */\n        const point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        const constrainedPoint = this.constrainPosition ? this.constrainPosition(point, this) : point;\n        /** @type {?} */\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            constrainedPoint.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            constrainedPoint.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            /** @type {?} */\n            const boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            const previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            const minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            const minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            constrainedPoint.x = clamp(constrainedPoint.x, minX, maxX);\n            constrainedPoint.y = clamp(constrainedPoint.y, minY, maxY);\n        }\n        return constrainedPoint;\n    }\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        /** @type {?} */\n        const delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @private\n     * @param {?} x New transform value along the X axis.\n     * @param {?} y New transform value along the Y axis.\n     * @return {?}\n     */\n    _applyRootElementTransform(x, y) {\n        /** @type {?} */\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @private\n     * @param {?} currentPosition Current position of the user's pointer.\n     * @return {?}\n     */\n    _getDragDistance(currentPosition) {\n        /** @type {?} */\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /**\n     * Cleans up any cached element dimensions that we don't need after dragging has stopped.\n     * @private\n     * @return {?}\n     */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     * @private\n     * @return {?}\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        /** @type {?} */\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        // It's possible that the element got hidden away after dragging (e.g. by switching to a\n        // different tab). Don't do anything in this case so we don't clear the user's position.\n        if ((boundaryRect.width === 0 && boundaryRect.height === 0) ||\n            (elementRect.width === 0 && elementRect.height === 0)) {\n            return;\n        }\n        /** @type {?} */\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        /** @type {?} */\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        /** @type {?} */\n        const topOverflow = boundaryRect.top - elementRect.top;\n        /** @type {?} */\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n    /**\n     * Gets the drag start delay, based on the event type.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getDragStartDelay(event) {\n        /** @type {?} */\n        const value = this.dragStartDelay;\n        if (typeof value === 'number') {\n            return value;\n        }\n        else if (isTouchEvent(event)) {\n            return value.touch;\n        }\n        return value ? value.mouse : 0;\n    }\n}\nif (false) {\n    /**\n     * Element displayed next to the user's pointer while the element is dragged.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._preview;\n    /**\n     * Reference to the view of the preview element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewRef;\n    /**\n     * Reference to the view of the placeholder element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholderRef;\n    /**\n     * Element that is rendered instead of the draggable item while it is being sorted.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholder;\n    /**\n     * Coordinates within the element at which the user picked up the element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pickupPositionInElement;\n    /**\n     * Coordinates on the page at which the user picked up the element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pickupPositionOnPage;\n    /**\n     * Anchor node used to save the place in the DOM where the element was\n     * picked up so that it can be restored at the end of the drag sequence.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._anchor;\n    /**\n     * CSS `transform` applied to the element when it isn't being dragged. We need a\n     * passive transform in order for the dragged element to retain its new position\n     * after the user has stopped dragging and because we need to know the relative\n     * position in case they start dragging again. This corresponds to `element.style.transform`.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._passiveTransform;\n    /**\n     * CSS `transform` that is applied to the element while it's being dragged.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._activeTransform;\n    /**\n     * Inline `transform` value that the element had before the first dragging sequence.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._initialTransform;\n    /**\n     * Whether the dragging sequence has been started. Doesn't\n     * necessarily mean that the element has been moved.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._hasStartedDragging;\n    /**\n     * Whether the element has moved since the user started dragging it.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._hasMoved;\n    /**\n     * Drop container in which the DragRef resided when dragging began.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._initialContainer;\n    /**\n     * Cached scroll position on the page when the element was picked up.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._scrollPosition;\n    /**\n     * Emits when the item is being moved.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._moveEvents;\n    /**\n     * Keeps track of the direction in which the user is dragging along each axis.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerDirectionDelta;\n    /**\n     * Pointer position at which the last change in the delta occurred.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerPositionAtLastDirectionChange;\n    /**\n     * Root DOM node of the drag instance. This is the element that will\n     * be moved around as the user is dragging.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._rootElement;\n    /**\n     * Inline style value of `-webkit-tap-highlight-color` at the time the\n     * dragging was started. Used to restore the value once we're done dragging.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._rootElementTapHighlight;\n    /**\n     * Subscription to pointer movement events.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerMoveSubscription;\n    /**\n     * Subscription to the event that is dispatched when the user lifts their pointer.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerUpSubscription;\n    /**\n     * Subscription to the viewport being scrolled.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._scrollSubscription;\n    /**\n     * Subscription to the viewport being resized.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._resizeSubscription;\n    /**\n     * Time at which the last touch event occurred. Used to avoid firing the same\n     * events multiple times on touch devices where the browser will fire a fake\n     * mouse event for each touch event, after a certain time.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._lastTouchEventTime;\n    /**\n     * Time at which the last dragging sequence was started.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dragStartTime;\n    /**\n     * Cached reference to the boundary element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._boundaryElement;\n    /**\n     * Whether the native dragging interactions have been enabled on the root element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._nativeInteractionsEnabled;\n    /**\n     * Cached dimensions of the preview element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewRect;\n    /**\n     * Cached dimensions of the boundary element.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._boundaryRect;\n    /**\n     * Element that will be used as a template to create the draggable item's preview.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._previewTemplate;\n    /**\n     * Template for placeholder element rendered to show where a draggable would be dropped.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._placeholderTemplate;\n    /**\n     * Elements that can be used to drag the draggable item.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._handles;\n    /**\n     * Registered handles that are currently disabled.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._disabledHandles;\n    /**\n     * Droppable container that the draggable is a part of.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dropContainer;\n    /**\n     * Layout direction of the item.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._direction;\n    /**\n     * Axis along which dragging is locked.\n     * @type {?}\n     */\n    DragRef.prototype.lockAxis;\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     * @type {?}\n     */\n    DragRef.prototype.dragStartDelay;\n    /**\n     * Class to be added to the preview element.\n     * @type {?}\n     */\n    DragRef.prototype.previewClass;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._disabled;\n    /**\n     * Emits as the drag sequence is being prepared.\n     * @type {?}\n     */\n    DragRef.prototype.beforeStarted;\n    /**\n     * Emits when the user starts dragging the item.\n     * @type {?}\n     */\n    DragRef.prototype.started;\n    /**\n     * Emits when the user has released a drag item, before any animations have started.\n     * @type {?}\n     */\n    DragRef.prototype.released;\n    /**\n     * Emits when the user stops dragging an item in the container.\n     * @type {?}\n     */\n    DragRef.prototype.ended;\n    /**\n     * Emits when the user has moved the item into a new container.\n     * @type {?}\n     */\n    DragRef.prototype.entered;\n    /**\n     * Emits when the user removes the item its container by dragging it into another container.\n     * @type {?}\n     */\n    DragRef.prototype.exited;\n    /**\n     * Emits when the user drops the item inside a container.\n     * @type {?}\n     */\n    DragRef.prototype.dropped;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     * @type {?}\n     */\n    DragRef.prototype.moved;\n    /**\n     * Arbitrary data that can be attached to the drag item.\n     * @type {?}\n     */\n    DragRef.prototype.data;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page and should return a point describing where the item should\n     * be rendered.\n     * @type {?}\n     */\n    DragRef.prototype.constrainPosition;\n    /**\n     * Handler for the `mousedown`/`touchstart` events.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerDown;\n    /**\n     * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerMove;\n    /**\n     * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._pointerUp;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._config;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._viewportRuler;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragRef.prototype._dragDropRegistry;\n}\n/**\n * Point on the page or within an element.\n * @record\n */\nfunction Point() { }\nif (false) {\n    /** @type {?} */\n    Point.prototype.x;\n    /** @type {?} */\n    Point.prototype.y;\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    const clone = (/** @type {?} */ (node.cloneNode(true)));\n    /** @type {?} */\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    /** @type {?} */\n    const descendantCanvases = node.querySelectorAll('canvas');\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    // `cloneNode` won't transfer the content of `canvas` elements so we have to do it ourselves.\n    // We match up the cloned canvas to their sources using their index in the DOM.\n    if (descendantCanvases.length) {\n        /** @type {?} */\n        const cloneCanvases = clone.querySelectorAll('canvas');\n        for (let i = 0; i < descendantCanvases.length; i++) {\n            /** @type {?} */\n            const correspondingCloneContext = cloneCanvases[i].getContext('2d');\n            if (correspondingCloneContext) {\n                correspondingCloneContext.drawImage(descendantCanvases[i], 0, 0);\n            }\n        }\n    }\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove a node from the DOM and to do all the necessary null checks.\n * @param {?} node Node to be removed.\n * @return {?}\n */\nfunction removeNode(node) {\n    if (node && node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the element into which the drag preview should be inserted.\n * @param {?} documentRef\n * @return {?}\n */\nfunction getPreviewInsertionPoint(documentRef) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n * @param {?} viewRef\n * @param {?} _document\n * @return {?}\n */\nfunction getRootNode(viewRef, _document) {\n    /** @type {?} */\n    const rootNode = viewRef.rootNodes[0];\n    if (rootNode.nodeType !== _document.ELEMENT_NODE) {\n        /** @type {?} */\n        const wrapper = _document.createElement('div');\n        wrapper.appendChild(rootNode);\n        return wrapper;\n    }\n    return (/** @type {?} */ (rootNode));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    const from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    const target = array[from];\n    /** @type {?} */\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drop-list-ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst AUTO_SCROLL_STEP = 2;\n/**\n * Entry in the position cache for draggable items.\n * \\@docs-private\n * @record\n */\nfunction CachedItemPosition() { }\nif (false) {\n    /**\n     * Instance of the drag item.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.drag;\n    /**\n     * Dimensions of the item.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.clientRect;\n    /**\n     * Amount by which the item has been moved since dragging started.\n     * @type {?}\n     */\n    CachedItemPosition.prototype.offset;\n}\n/**\n * Object holding the scroll position of something.\n * @record\n */\nfunction ScrollPosition() { }\nif (false) {\n    /** @type {?} */\n    ScrollPosition.prototype.top;\n    /** @type {?} */\n    ScrollPosition.prototype.left;\n}\n/** @enum {number} */\nconst AutoScrollVerticalDirection = {\n    NONE: 0, UP: 1, DOWN: 2,\n};\n/** @enum {number} */\nconst AutoScrollHorizontalDirection = {\n    NONE: 0, LEFT: 1, RIGHT: 2,\n};\n/**\n * Internal compile-time-only representation of a `DropListRef`.\n * Used to avoid circular import issues between the `DropListRef` and the `DragRef`.\n * \\@docs-private\n * @record\n */\nfunction DropListRefInternal() { }\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * @template T\n */\nclass DropListRef {\n    /**\n     * @param {?} element\n     * @param {?} _dragDropRegistry\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     */\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Whether sorting items within the list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new Subject();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the container's scroll position.\n         */\n        this._scrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the scroll position of the viewport.\n         */\n        this._viewportScrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        /**\n         * Subscription to the window being scrolled.\n         */\n        this._viewportScrollSubscription = Subscription.EMPTY;\n        /**\n         * Vertical direction in which the list is currently scrolling.\n         */\n        this._verticalScrollDirection = 0 /* NONE */;\n        /**\n         * Horizontal direction in which the list is currently scrolling.\n         */\n        this._horizontalScrollDirection = 0 /* NONE */;\n        /**\n         * Used to signal to the current auto-scroll sequence when to stop.\n         */\n        this._stopScrollTimers = new Subject();\n        /**\n         * Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly.\n         */\n        this._cachedShadowRoot = null;\n        /**\n         * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n         */\n        this._handleScroll = (/**\n         * @return {?}\n         */\n        () => {\n            if (!this.isDragging()) {\n                return;\n            }\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            this._updateAfterScroll(this._scrollPosition, element.scrollTop, element.scrollLeft);\n        });\n        /**\n         * Starts the interval that'll auto-scroll the element.\n         */\n        this._startScrollInterval = (/**\n         * @return {?}\n         */\n        () => {\n            this._stopScrolling();\n            interval(0, animationFrameScheduler)\n                .pipe(takeUntil(this._stopScrollTimers))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const node = this._scrollNode;\n                if (this._verticalScrollDirection === 1 /* UP */) {\n                    incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._verticalScrollDirection === 2 /* DOWN */) {\n                    incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n                }\n                if (this._horizontalScrollDirection === 1 /* LEFT */) {\n                    incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._horizontalScrollDirection === 2 /* RIGHT */) {\n                    incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n                }\n            }));\n        });\n        this.element = coerceElement(element);\n        this._document = _document;\n        _dragDropRegistry.registerDropContainer(this);\n    }\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._removeListeners();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = (/** @type {?} */ (null));\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._isDragging;\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._cacheItems();\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._startReceiving(this)));\n        this._removeListeners();\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => element.addEventListener('scroll', this._handleScroll)));\n        this._listenToScrollEvents();\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        /** @type {?} */\n        let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n        if (newIndex === -1) {\n            // We use the coordinates of where the item entered the drop\n            // zone to figure out at which index it should be inserted.\n            newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        }\n        /** @type {?} */\n        const activeDraggables = this._activeDraggables;\n        /** @type {?} */\n        const currentIndex = activeDraggables.indexOf(item);\n        /** @type {?} */\n        const placeholder = item.getPlaceholderElement();\n        /** @type {?} */\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            const element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            coerceElement(this.element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param {?} distance Distance the user has dragged since the start of the dragging sequence.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer, distance) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    withItems(items) {\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item._withDropContainer((/** @type {?} */ (this)))));\n        if ((/** @type {?} */ (this)).isDragging()) {\n            (/** @type {?} */ (this))._cacheItems();\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    connectedTo(connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    withOrientation(orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        const siblings = this._itemPositions;\n        /** @type {?} */\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentIndex = findIndex(siblings, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n        /** @type {?} */\n        const siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        const delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((/**\n         * @param {?} sibling\n         * @param {?} index\n         * @return {?}\n         */\n        (sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            const isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        }));\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param {?} pointerX User's pointer position along the x axis.\n     * @param {?} pointerY User's pointer position along the y axis.\n     * @return {?}\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        /** @type {?} */\n        let scrollNode;\n        /** @type {?} */\n        let verticalScrollDirection = 0 /* NONE */;\n        /** @type {?} */\n        let horizontalScrollDirection = 0 /* NONE */;\n        // Check whether we should start scrolling the container.\n        if (this._isPointerNearDropContainer(pointerX, pointerY)) {\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            [verticalScrollDirection, horizontalScrollDirection] =\n                getElementScrollDirections(element, this._clientRect, pointerX, pointerY);\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                scrollNode = element;\n            }\n        }\n        // Otherwise check if we can start scrolling the viewport.\n        if (!verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            /** @type {?} */\n            const clientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n            horizontalScrollDirection !== this._horizontalScrollDirection ||\n            scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                this._ngZone.runOutsideAngular(this._startScrollInterval);\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /**\n     * Stops any currently-running auto-scroll sequences.\n     * @return {?}\n     */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    _cacheOwnPosition() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this._clientRect = getMutableClientRect(element);\n        this._scrollPosition = { top: element.scrollTop, left: element.scrollLeft };\n    }\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    _cacheItemPositions() {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map((/**\n         * @param {?} drag\n         * @return {?}\n         */\n        drag => {\n            /** @type {?} */\n            const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            return { drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure) };\n        })).sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        }));\n    }\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    _reset() {\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item.getRootElement().style.transform = ''));\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._stopReceiving(this)));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._stopScrolling();\n        this._removeListeners();\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            const start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    _isPointerNearDropContainer(pointerX, pointerY) {\n        const { top, right, bottom, left, width, height } = this._clientRect;\n        /** @type {?} */\n        const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, (/**\n         * @param {?} __0\n         * @param {?} _\n         * @param {?} array\n         * @return {?}\n         */\n        ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        }));\n    }\n    /**\n     * Caches the current items in the list and their positions.\n     * @private\n     * @return {?}\n     */\n    _cacheItems() {\n        this._activeDraggables = this._draggables.slice();\n        this._cacheItemPositions();\n        this._cacheOwnPosition();\n    }\n    /**\n     * Updates the internal state of the container after a scroll event has happened.\n     * @private\n     * @param {?} scrollPosition Object that is keeping track of the scroll position.\n     * @param {?} newTop New top scroll position.\n     * @param {?} newLeft New left scroll position.\n     * @param {?=} extraClientRect Extra `ClientRect` object that should be updated, in addition to the\n     *  ones of the drag items. Useful when the viewport has been scrolled and we also need to update\n     *  the `ClientRect` of the list.\n     * @return {?}\n     */\n    _updateAfterScroll(scrollPosition, newTop, newLeft, extraClientRect) {\n        /** @type {?} */\n        const topDifference = scrollPosition.top - newTop;\n        /** @type {?} */\n        const leftDifference = scrollPosition.left - newLeft;\n        if (extraClientRect) {\n            adjustClientRect(extraClientRect, topDifference, leftDifference);\n        }\n        // Since we know the amount that the user has scrolled we can shift all of the client rectangles\n        // ourselves. This is cheaper than re-measuring everything and we can avoid inconsistent\n        // behavior where we might be measuring the element before its position has changed.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        }));\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        }));\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n    }\n    /**\n     * Removes the event listeners associated with this drop list.\n     * @private\n     * @return {?}\n     */\n    _removeListeners() {\n        coerceElement(this.element).removeEventListener('scroll', this._handleScroll);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._canReceive(item, x, y)));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _canReceive(item, x, y) {\n        if (!isInsideClientRect(this._clientRect, x, y) || !this.enterPredicate(item, this)) {\n            return false;\n        }\n        /** @type {?} */\n        const elementFromPoint = (/** @type {?} */ (this._getShadowRoot().elementFromPoint(x, y)));\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        /** @type {?} */\n        const nativeElement = coerceElement(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    _startReceiving(sibling) {\n        /** @type {?} */\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     * @private\n     * @return {?}\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n        this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (this.isDragging()) {\n                /** @type {?} */\n                const newPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n                this._updateAfterScroll(this._viewportScrollPosition, newPosition.top, newPosition.left, this._clientRect);\n            }\n            else if (this.isReceiving()) {\n                this._cacheOwnPosition();\n            }\n        }));\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     * @private\n     * @return {?}\n     */\n    _getShadowRoot() {\n        if (!this._cachedShadowRoot) {\n            this._cachedShadowRoot = getShadowRoot(coerceElement(this.element)) || this._document;\n        }\n        return this._cachedShadowRoot;\n    }\n}\nif (false) {\n    /**\n     * Element that the drop list is attached to.\n     * @type {?}\n     */\n    DropListRef.prototype.element;\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.disabled;\n    /**\n     * Whether sorting items within the list is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.sortingDisabled;\n    /**\n     * Locks the position of the draggable elements inside the container along the specified axis.\n     * @type {?}\n     */\n    DropListRef.prototype.lockAxis;\n    /**\n     * Whether auto-scrolling the view when the user\n     * moves their pointer close to the edges is disabled.\n     * @type {?}\n     */\n    DropListRef.prototype.autoScrollDisabled;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     * @type {?}\n     */\n    DropListRef.prototype.enterPredicate;\n    /**\n     * Emits right before dragging has started.\n     * @type {?}\n     */\n    DropListRef.prototype.beforeStarted;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     * @type {?}\n     */\n    DropListRef.prototype.entered;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     * @type {?}\n     */\n    DropListRef.prototype.exited;\n    /**\n     * Emits when the user drops an item inside the container.\n     * @type {?}\n     */\n    DropListRef.prototype.dropped;\n    /**\n     * Emits as the user is swapping items while actively dragging.\n     * @type {?}\n     */\n    DropListRef.prototype.sorted;\n    /**\n     * Arbitrary data that can be attached to the drop list.\n     * @type {?}\n     */\n    DropListRef.prototype.data;\n    /**\n     * Whether an item in the list is being dragged.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._isDragging;\n    /**\n     * Cache of the dimensions of all the items inside the container.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._itemPositions;\n    /**\n     * Keeps track of the container's scroll position.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._scrollPosition;\n    /**\n     * Keeps track of the scroll position of the viewport.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportScrollPosition;\n    /**\n     * Cached `ClientRect` of the drop list.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._clientRect;\n    /**\n     * Draggable items that are currently active inside the container. Includes the items\n     * from `_draggables`, as well as any items that have been dragged in, but haven't\n     * been dropped yet.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._activeDraggables;\n    /**\n     * Keeps track of the item that was last swapped with the dragged item, as\n     * well as what direction the pointer was moving in when the swap occured.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._previousSwap;\n    /**\n     * Draggable items in the container.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._draggables;\n    /**\n     * Drop lists that are connected to the current one.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._siblings;\n    /**\n     * Direction in which the list is oriented.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._orientation;\n    /**\n     * Connected siblings that currently have a dragged item.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._activeSiblings;\n    /**\n     * Layout direction of the drop list.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._direction;\n    /**\n     * Subscription to the window being scrolled.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportScrollSubscription;\n    /**\n     * Vertical direction in which the list is currently scrolling.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._verticalScrollDirection;\n    /**\n     * Horizontal direction in which the list is currently scrolling.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._horizontalScrollDirection;\n    /**\n     * Node that is being auto-scrolled.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._scrollNode;\n    /**\n     * Used to signal to the current auto-scroll sequence when to stop.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._stopScrollTimers;\n    /**\n     * Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._cachedShadowRoot;\n    /**\n     * Reference to the document.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._document;\n    /**\n     * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._handleScroll;\n    /**\n     * Starts the interval that'll auto-scroll the element.\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._startScrollInterval;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._dragDropRegistry;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DropListRef.prototype._viewportRuler;\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Gets a mutable version of an element's bounding `ClientRect`.\n * @param {?} element\n * @return {?}\n */\nfunction getMutableClientRect(element) {\n    /** @type {?} */\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height\n    };\n}\n/**\n * Increments the vertical scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementVerticalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(0, amount);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollTop += amount;\n    }\n}\n/**\n * Increments the horizontal scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementHorizontalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(amount, 0);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollLeft += amount;\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    /** @type {?} */\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* DOWN */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @return {?}\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    /** @type {?} */\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* RIGHT */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param {?} element Element for which we should calculate the scroll direction.\n * @param {?} clientRect Bounding client rectangle of the element.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    /** @type {?} */\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    /** @type {?} */\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    /** @type {?} */\n    let verticalScrollDirection = 0 /* NONE */;\n    /** @type {?} */\n    let horizontalScrollDirection = 0 /* NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        /** @type {?} */\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        /** @type {?} */\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n/**\n * Gets the shadow root of an element, if any.\n * @param {?} element\n * @return {?}\n */\nfunction getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        /** @type {?} */\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        if (rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop-registry.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _document\n     */\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         */\n        this.scroll = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        });\n        this._document = _document;\n    }\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            this._dropInstances.add(drop);\n        }\n    }\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            }));\n        }\n    }\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.has(drag)) {\n            return;\n        }\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            const isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            const moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            const upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerMove.next((/** @type {?} */ (e)))),\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerUp.next((/** @type {?} */ (e)))),\n                options: true\n            })\n                .set('scroll', {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.scroll.next(e)),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._globalListeners.forEach((/**\n                 * @param {?} config\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                }));\n            }));\n        }\n    }\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    stopDragging(drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    }\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    isDragging(drag) {\n        return this._activeDragInstances.has(drag);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dragInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDragItem(instance)));\n        this._dropInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDropContainer(instance)));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((/**\n         * @param {?} config\n         * @param {?} name\n         * @return {?}\n         */\n        (config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        }));\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nDragDropRegistry.ctorParameters = () => [\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ DragDropRegistry.Éµprov = ÉµÉµdefineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(ÉµÉµinject(NgZone), ÉµÉµinject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._document;\n    /**\n     * Registered drop container instances.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._dropInstances;\n    /**\n     * Registered drag item instances.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._dragInstances;\n    /**\n     * Drag item instances that are currently being dragged.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._activeDragInstances;\n    /**\n     * Keeps track of the event listeners that we've bound to the `document`.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._globalListeners;\n    /**\n     * Emits the `touchmove` or `mousemove` events that are dispatched\n     * while the user is dragging a drag item instance.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.pointerMove;\n    /**\n     * Emits the `touchend` or `mouseup` events that are dispatched\n     * while the user is dragging a drag item instance.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.pointerUp;\n    /**\n     * Emits when the viewport has been scrolled while the user is dragging an item.\n     * @type {?}\n     */\n    DragDropRegistry.prototype.scroll;\n    /**\n     * Event listener that will prevent the default browser action while the user is dragging.\n     * \\@param event Event whose default action should be prevented.\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._preventDefaultWhileDragging;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDropRegistry.prototype._ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    /**\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n}\nDragDrop.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nDragDrop.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewportRuler },\n    { type: DragDropRegistry }\n];\n/** @nocollapse */ DragDrop.Éµprov = ÉµÉµdefineInjectable({ factory: function DragDrop_Factory() { return new DragDrop(ÉµÉµinject(DOCUMENT), ÉµÉµinject(NgZone), ÉµÉµinject(ViewportRuler), ÉµÉµinject(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._viewportRuler;\n    /**\n     * @type {?}\n     * @private\n     */\n    DragDrop.prototype._dragDropRegistry;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-events.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Event emitted when the user starts dragging a draggable.\n * @record\n * @template T\n */\nfunction CdkDragStart() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragStart.prototype.source;\n}\n/**\n * Event emitted when the user releases an item, before any animations have started.\n * @record\n * @template T\n */\nfunction CdkDragRelease() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragRelease.prototype.source;\n}\n/**\n * Event emitted when the user stops dragging a draggable.\n * @record\n * @template T\n */\nfunction CdkDragEnd() { }\nif (false) {\n    /**\n     * Draggable that emitted the event.\n     * @type {?}\n     */\n    CdkDragEnd.prototype.source;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragEnd.prototype.distance;\n}\n/**\n * Event emitted when the user moves an item into a new drop container.\n * @record\n * @template T, I\n */\nfunction CdkDragEnter() { }\nif (false) {\n    /**\n     * Container into which the user has moved the item.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.container;\n    /**\n     * Item that was moved into the container.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.item;\n    /**\n     * Index at which the item has entered the container.\n     * @type {?}\n     */\n    CdkDragEnter.prototype.currentIndex;\n}\n/**\n * Event emitted when the user removes an item from a\n * drop container by moving it into another one.\n * @record\n * @template T, I\n */\nfunction CdkDragExit() { }\nif (false) {\n    /**\n     * Container from which the user has a removed an item.\n     * @type {?}\n     */\n    CdkDragExit.prototype.container;\n    /**\n     * Item that was removed from the container.\n     * @type {?}\n     */\n    CdkDragExit.prototype.item;\n}\n/**\n * Event emitted when the user drops a draggable item inside a drop container.\n * @record\n * @template T, O\n */\nfunction CdkDragDrop() { }\nif (false) {\n    /**\n     * Index of the item when it was picked up.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.previousIndex;\n    /**\n     * Current index of the item.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.currentIndex;\n    /**\n     * Item that is being dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.item;\n    /**\n     * Container in which the item was dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.container;\n    /**\n     * Container from which the item was picked up. Can be the same as the `container`.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.previousContainer;\n    /**\n     * Whether the user's pointer was over the container when the item was dropped.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.isPointerOverContainer;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragDrop.prototype.distance;\n}\n/**\n * Event emitted as the user is dragging a draggable item.\n * @record\n * @template T\n */\nfunction CdkDragMove() { }\nif (false) {\n    /**\n     * Item that is being dragged.\n     * @type {?}\n     */\n    CdkDragMove.prototype.source;\n    /**\n     * Position of the user's pointer on the page.\n     * @type {?}\n     */\n    CdkDragMove.prototype.pointerPosition;\n    /**\n     * Native event that is causing the dragging.\n     * @type {?}\n     */\n    CdkDragMove.prototype.event;\n    /**\n     * Distance in pixels that the user has dragged since the drag sequence started.\n     * @type {?}\n     */\n    CdkDragMove.prototype.distance;\n    /**\n     * Indicates the direction in which the user is dragging the element along each axis.\n     * `1` means that the position is increasing (e.g. the user is moving to the right or downwards),\n     * whereas `-1` means that it's decreasing (they're moving to the left or upwards). `0` means\n     * that the position hasn't changed.\n     * @type {?}\n     */\n    CdkDragMove.prototype.delta;\n}\n/**\n * Event emitted when the user swaps the position of two drag items.\n * @record\n * @template T, I\n */\nfunction CdkDragSortEvent() { }\nif (false) {\n    /**\n     * Index from which the item was sorted previously.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.previousIndex;\n    /**\n     * Index that the item is currently in.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.currentIndex;\n    /**\n     * Container that the item belongs to.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.container;\n    /**\n     * Item that is being sorted.\n     * @type {?}\n     */\n    CdkDragSortEvent.prototype.item;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-parent.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-handle.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nclass CdkDragHandle {\n    /**\n     * @param {?} element\n     * @param {?=} parentDrag\n     */\n    constructor(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    /**\n     * Whether starting to drag through this handle is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._stateChanges.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDragHandle]',\n                host: {\n                    'class': 'cdk-drag-handle'\n                }\n            },] }\n];\n/** @nocollapse */\nCdkDragHandle.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_PARENT,] }, { type: Optional }] }\n];\nCdkDragHandle.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDragHandleDisabled',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDragHandle.ngAcceptInputType_disabled;\n    /**\n     * Closest parent draggable instance.\n     * @type {?}\n     */\n    CdkDragHandle.prototype._parentDrag;\n    /**\n     * Emits when the state of the handle has changed.\n     * @type {?}\n     */\n    CdkDragHandle.prototype._stateChanges;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDragHandle.prototype._disabled;\n    /** @type {?} */\n    CdkDragHandle.prototype.element;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-placeholder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nclass CdkDragPlaceholder {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPlaceholder]'\n            },] }\n];\n/** @nocollapse */\nCdkDragPlaceholder.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPlaceholder.propDecorators = {\n    data: [{ type: Input }]\n};\nif (false) {\n    /**\n     * Context data to be added to the placeholder template instance.\n     * @type {?}\n     */\n    CdkDragPlaceholder.prototype.data;\n    /** @type {?} */\n    CdkDragPlaceholder.prototype.templateRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag-preview.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nclass CdkDragPreview {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPreview.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPreview]'\n            },] }\n];\n/** @nocollapse */\nCdkDragPreview.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPreview.propDecorators = {\n    data: [{ type: Input }]\n};\nif (false) {\n    /**\n     * Context data to be added to the preview template instance.\n     * @type {?}\n     */\n    CdkDragPreview.prototype.data;\n    /** @type {?} */\n    CdkDragPreview.prototype.templateRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drag.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nconst CDK_DROP_LIST = new InjectionToken('CDK_DROP_LIST');\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nclass CdkDrag {\n    /**\n     * @param {?} element\n     * @param {?} dropContainer\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} config\n     * @param {?} _dir\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     */\n    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new Subject();\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._dragRef.moved.pipe(map((/**\n             * @param {?} movedEvent\n             * @return {?}\n             */\n            movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance\n            })))).subscribe(observer);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n            });\n        }));\n        this._dragRef = dragDrop.createDrag(element, config);\n        this._dragRef.data = this;\n        // Note that usually the container is assigned when the drop list is picks up the item, but in\n        // some cases (mainly transplanted views with OnPush, see #18341) we may end up in a situation\n        // where there are no items on the first change detection pass, but the items get picked up as\n        // soon as the user triggers another pass by dragging. This is a problem, because the item would\n        // have to switch from standalone mode to drag mode in the middle of the dragging sequence which\n        // is too late since the two modes save different kinds of information. We work around it by\n        // assigning the drop container both from here and the list.\n        if (dropContainer) {\n            this._dragRef._withDropContainer(dropContainer._dropListRef);\n        }\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(take(1), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._updateRootElement();\n            // Listen for any newly-added handles.\n            this._handles.changes.pipe(startWith(this._handles), \n            // Sync the new handles with the DragRef.\n            tap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                /** @type {?} */\n                const childHandleElements = handles\n                    .filter((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle._parentDrag === this))\n                    .map((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle.element));\n                this._dragRef.withHandles(childHandleElements);\n            })), \n            // Listen if the state of any of the handles changes.\n            switchMap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                return (/** @type {?} */ (merge(...handles.map((/**\n                 * @param {?} item\n                 * @return {?}\n                 */\n                item => {\n                    return item._stateChanges.pipe(startWith(item));\n                })))));\n            })), takeUntil(this._destroyed)).subscribe((/**\n             * @param {?} handleInstance\n             * @return {?}\n             */\n            handleInstance => {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                const dragRef = this._dragRef;\n                /** @type {?} */\n                const handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            }));\n            if (this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        /** @type {?} */\n        const rootSelectorChange = changes['rootElementSelector'];\n        /** @type {?} */\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    }\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    _updateRootElement() {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        /** @type {?} */\n        const rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(`cdkDrag must be attached to an element node. ` +\n                `Currently attached to \"${rootElement.nodeName}\".`);\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /**\n     * Gets the boundary element, based on the `boundaryElement` value.\n     * @private\n     * @return {?}\n     */\n    _getBoundaryElement() {\n        /** @type {?} */\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return getClosestMatchingAncestor(this.element.nativeElement, boundary);\n        }\n        /** @type {?} */\n        const element = coerceElement(boundary);\n        if (isDevMode() && !element.contains(this.element.nativeElement)) {\n            throw Error('Draggable element is not inside of the node passed into cdkDragBoundary.');\n        }\n        return element;\n    }\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                const dir = this._dir;\n                /** @type {?} */\n                const dragStartDelay = this.dragStartDelay;\n                /** @type {?} */\n                const placeholder = this._placeholderTemplate ? {\n                    template: this._placeholderTemplate.templateRef,\n                    context: this._placeholderTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                const preview = this._previewTemplate ? {\n                    template: this._previewTemplate.templateRef,\n                    context: this._previewTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay = (typeof dragStartDelay === 'object' && dragStartDelay) ?\n                    dragStartDelay : coerceNumberProperty(dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref.previewClass = this.previewClass;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        }));\n    }\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.started.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.started.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.released.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.released.emit({ source: this });\n        }));\n        ref.ended.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.ended.emit({ source: this, distance: event.distance });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: event.container.data,\n                item: this,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: this,\n                distance: event.distance\n            });\n        }));\n    }\n}\nCdkDrag.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDrag]',\n                exportAs: 'cdkDrag',\n                host: {\n                    'class': 'cdk-drag',\n                    '[class.cdk-drag-disabled]': 'disabled',\n                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                },\n                providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n            },] }\n];\n/** @nocollapse */\nCdkDrag.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: DragDrop },\n    { type: ChangeDetectorRef }\n];\nCdkDrag.propDecorators = {\n    _handles: [{ type: ContentChildren, args: [CdkDragHandle, { descendants: true },] }],\n    _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview,] }],\n    _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder,] }],\n    data: [{ type: Input, args: ['cdkDragData',] }],\n    lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n    rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n    boundaryElement: [{ type: Input, args: ['cdkDragBoundary',] }],\n    dragStartDelay: [{ type: Input, args: ['cdkDragStartDelay',] }],\n    freeDragPosition: [{ type: Input, args: ['cdkDragFreeDragPosition',] }],\n    disabled: [{ type: Input, args: ['cdkDragDisabled',] }],\n    constrainPosition: [{ type: Input, args: ['cdkDragConstrainPosition',] }],\n    previewClass: [{ type: Input, args: ['cdkDragPreviewClass',] }],\n    started: [{ type: Output, args: ['cdkDragStarted',] }],\n    released: [{ type: Output, args: ['cdkDragReleased',] }],\n    ended: [{ type: Output, args: ['cdkDragEnded',] }],\n    entered: [{ type: Output, args: ['cdkDragEntered',] }],\n    exited: [{ type: Output, args: ['cdkDragExited',] }],\n    dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n    moved: [{ type: Output, args: ['cdkDragMoved',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDrag.ngAcceptInputType_disabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._destroyed;\n    /**\n     * Reference to the underlying drag instance.\n     * @type {?}\n     */\n    CdkDrag.prototype._dragRef;\n    /**\n     * Elements that can be used to drag the draggable item.\n     * @type {?}\n     */\n    CdkDrag.prototype._handles;\n    /**\n     * Element that will be used as a template to create the draggable item's preview.\n     * @type {?}\n     */\n    CdkDrag.prototype._previewTemplate;\n    /**\n     * Template for placeholder element rendered to show where a draggable would be dropped.\n     * @type {?}\n     */\n    CdkDrag.prototype._placeholderTemplate;\n    /**\n     * Arbitrary data to attach to this drag instance.\n     * @type {?}\n     */\n    CdkDrag.prototype.data;\n    /**\n     * Locks the position of the dragged element along the specified axis.\n     * @type {?}\n     */\n    CdkDrag.prototype.lockAxis;\n    /**\n     * Selector that will be used to determine the root draggable element, starting from\n     * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful\n     * when trying to enable dragging on an element that you might not have access to.\n     * @type {?}\n     */\n    CdkDrag.prototype.rootElementSelector;\n    /**\n     * Node or selector that will be used to determine the element to which the draggable's\n     * position will be constrained. If a string is passed in, it'll be used as a selector that\n     * will be matched starting from the element's parent and going up the DOM until a match\n     * has been found.\n     * @type {?}\n     */\n    CdkDrag.prototype.boundaryElement;\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     * @type {?}\n     */\n    CdkDrag.prototype.dragStartDelay;\n    /**\n     * Sets the position of a `CdkDrag` that is outside of a drop container.\n     * Can be used to restore the element's position for a returning user.\n     * @type {?}\n     */\n    CdkDrag.prototype.freeDragPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._disabled;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page and should return a point describing where the item should\n     * be rendered.\n     * @type {?}\n     */\n    CdkDrag.prototype.constrainPosition;\n    /**\n     * Class to be added to the preview element.\n     * @type {?}\n     */\n    CdkDrag.prototype.previewClass;\n    /**\n     * Emits when the user starts dragging the item.\n     * @type {?}\n     */\n    CdkDrag.prototype.started;\n    /**\n     * Emits when the user has released a drag item, before any animations have started.\n     * @type {?}\n     */\n    CdkDrag.prototype.released;\n    /**\n     * Emits when the user stops dragging an item in the container.\n     * @type {?}\n     */\n    CdkDrag.prototype.ended;\n    /**\n     * Emits when the user has moved the item into a new container.\n     * @type {?}\n     */\n    CdkDrag.prototype.entered;\n    /**\n     * Emits when the user removes the item its container by dragging it into another container.\n     * @type {?}\n     */\n    CdkDrag.prototype.exited;\n    /**\n     * Emits when the user drops the item inside a container.\n     * @type {?}\n     */\n    CdkDrag.prototype.dropped;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     * @type {?}\n     */\n    CdkDrag.prototype.moved;\n    /**\n     * Element that the draggable is attached to.\n     * @type {?}\n     */\n    CdkDrag.prototype.element;\n    /**\n     * Droppable container that the draggable is a part of.\n     * @type {?}\n     */\n    CdkDrag.prototype.dropContainer;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDrag.prototype._changeDetectorRef;\n}\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    let currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drop-list-group.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nclass CdkDropListGroup {\n    constructor() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /**\n     * Whether starting a dragging sequence from inside this group is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropListGroup]',\n                exportAs: 'cdkDropListGroup',\n            },] }\n];\nCdkDropListGroup.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDropListGroupDisabled',] }]\n};\nif (false) {\n    /** @type {?} */\n    CdkDropListGroup.ngAcceptInputType_disabled;\n    /**\n     * Drop lists registered inside the group.\n     * @type {?}\n     */\n    CdkDropListGroup.prototype._items;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropListGroup.prototype._disabled;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/directives/drop-list.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nlet _uniqueIdCounter = 0;\n/**\n * Internal compile-time-only representation of a `CdkDropList`.\n * Used to avoid circular import issues between the `CdkDropList` and the `CdkDrag`.\n * \\@docs-private\n * @record\n */\nfunction CdkDropListInternal() { }\nconst Éµ0 = undefined;\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nclass CdkDropList {\n    /**\n     * @param {?} element\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     * @param {?=} _dir\n     * @param {?=} _group\n     */\n    constructor(element, dragDrop, _changeDetectorRef, _dir, _group) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter++}`;\n        this._disabled = false;\n        /**\n         * Whether sorting within this drop list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new EventEmitter();\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = (/**\n         * @param {?} drag\n         * @param {?} drop\n         * @return {?}\n         */\n        (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        });\n        this._setupInputSyncSubscription(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        // Usually we sync the directive and ref state right before dragging starts, in order to have\n        // a single point of failure and to avoid having to use setters for everything. `disabled` is\n        // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n        // the user in a disabled state, so we also need to sync it as it's being set.\n        this._dropListRef.disabled = this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._draggables.changes\n            .pipe(startWith(this._draggables), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._dropListRef.withItems(items.reduce((/**\n             * @param {?} filteredItems\n             * @param {?} drag\n             * @return {?}\n             */\n            (filteredItems, drag) => {\n                if (drag.dropContainer === this) {\n                    filteredItems.push(drag._dragRef);\n                }\n                return filteredItems;\n            }), (/** @type {?} */ ([]))));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Starts dragging an item.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @return {?}\n     */\n    start() {\n        this._dropListRef.start();\n    }\n    /**\n     * Drops an item into this container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     *\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, previousContainer._dropListRef, isPointerOverContainer, { x: 0, y: 0 });\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._dropListRef.exit(item._dragRef);\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 10.0.0\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    }\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _setupInputSyncSubscription(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe((/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => ref.withDirection(value)));\n        }\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const siblings = coerceArray(this.connectedTo).map((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find((/**\n                     * @param {?} list\n                     * @return {?}\n                     */\n                    list => list.id === drop)))) : drop;\n            }));\n            if (this._group) {\n                this._group._items.forEach((/**\n                 * @param {?} drop\n                 * @return {?}\n                 */\n                drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                }));\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = coerceBooleanProperty(this.sortingDisabled);\n            ref.autoScrollDisabled = coerceBooleanProperty(this.autoScrollDisabled);\n            ref\n                .connectedTo(siblings.filter((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => drop && drop !== this)).map((/**\n             * @param {?} list\n             * @return {?}\n             */\n            list => list._dropListRef)))\n                .withOrientation(this.orientation);\n        }));\n    }\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data\n            });\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.sorted.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                distance: event.distance\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        }));\n    }\n}\n/**\n * Keeps track of the drop lists that are currently on the page.\n */\nCdkDropList._dropLists = [];\nCdkDropList.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropList], cdk-drop-list',\n                exportAs: 'cdkDropList',\n                providers: [\n                    // Prevent child drop lists from picking up the same group as their parent.\n                    { provide: CdkDropListGroup, useValue: Éµ0 },\n                    { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n                ],\n                host: {\n                    'class': 'cdk-drop-list',\n                    '[id]': 'id',\n                    '[class.cdk-drop-list-disabled]': 'disabled',\n                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                }\n            },] }\n];\n/** @nocollapse */\nCdkDropList.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragDrop },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\nCdkDropList.propDecorators = {\n    _draggables: [{ type: ContentChildren, args: [CdkDrag, { descendants: true },] }],\n    connectedTo: [{ type: Input, args: ['cdkDropListConnectedTo',] }],\n    data: [{ type: Input, args: ['cdkDropListData',] }],\n    orientation: [{ type: Input, args: ['cdkDropListOrientation',] }],\n    id: [{ type: Input }],\n    lockAxis: [{ type: Input, args: ['cdkDropListLockAxis',] }],\n    disabled: [{ type: Input, args: ['cdkDropListDisabled',] }],\n    sortingDisabled: [{ type: Input, args: ['cdkDropListSortingDisabled',] }],\n    enterPredicate: [{ type: Input, args: ['cdkDropListEnterPredicate',] }],\n    autoScrollDisabled: [{ type: Input, args: ['cdkDropListAutoScrollDisabled',] }],\n    dropped: [{ type: Output, args: ['cdkDropListDropped',] }],\n    entered: [{ type: Output, args: ['cdkDropListEntered',] }],\n    exited: [{ type: Output, args: ['cdkDropListExited',] }],\n    sorted: [{ type: Output, args: ['cdkDropListSorted',] }]\n};\nif (false) {\n    /**\n     * Keeps track of the drop lists that are currently on the page.\n     * @type {?}\n     * @private\n     */\n    CdkDropList._dropLists;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_disabled;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_sortingDisabled;\n    /** @type {?} */\n    CdkDropList.ngAcceptInputType_autoScrollDisabled;\n    /**\n     * Emits when the list has been destroyed.\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._destroyed;\n    /**\n     * Reference to the underlying drop list instance.\n     * @type {?}\n     */\n    CdkDropList.prototype._dropListRef;\n    /**\n     * Draggable items in the container.\n     * @type {?}\n     */\n    CdkDropList.prototype._draggables;\n    /**\n     * Other draggable containers that this container is connected to and into which the\n     * container's items can be transferred. Can either be references to other drop containers,\n     * or their unique IDs.\n     * @type {?}\n     */\n    CdkDropList.prototype.connectedTo;\n    /**\n     * Arbitrary data to attach to this container.\n     * @type {?}\n     */\n    CdkDropList.prototype.data;\n    /**\n     * Direction in which the list is oriented.\n     * @type {?}\n     */\n    CdkDropList.prototype.orientation;\n    /**\n     * Unique ID for the drop zone. Can be used as a reference\n     * in the `connectedTo` of another `CdkDropList`.\n     * @type {?}\n     */\n    CdkDropList.prototype.id;\n    /**\n     * Locks the position of the draggable elements inside the container along the specified axis.\n     * @type {?}\n     */\n    CdkDropList.prototype.lockAxis;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._disabled;\n    /**\n     * Whether sorting within this drop list is disabled.\n     * @type {?}\n     */\n    CdkDropList.prototype.sortingDisabled;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     * @type {?}\n     */\n    CdkDropList.prototype.enterPredicate;\n    /**\n     * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n     * @type {?}\n     */\n    CdkDropList.prototype.autoScrollDisabled;\n    /**\n     * Emits when the user drops an item inside the container.\n     * @type {?}\n     */\n    CdkDropList.prototype.dropped;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     * @type {?}\n     */\n    CdkDropList.prototype.entered;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     * @type {?}\n     */\n    CdkDropList.prototype.exited;\n    /**\n     * Emits as the user is swapping items while actively dragging.\n     * @type {?}\n     */\n    CdkDropList.prototype.sorted;\n    /**\n     * Element that the drop list is attached to.\n     * @type {?}\n     */\n    CdkDropList.prototype.element;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    CdkDropList.prototype._group;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/drag-drop-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragDropModule {\n}\nDragDropModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                exports: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                providers: [\n                    DragDrop,\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/drag-drop/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_DRAG_CONFIG, CDK_DRAG_CONFIG_FACTORY, CDK_DROP_LIST, CdkDrag, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropList, CdkDropListGroup, DragDrop, DragDropModule, DragDropRegistry, DragRef, DropListRef, copyArrayItem, moveItemInArray, transferArrayItem, CDK_DRAG_PARENT as Éµangular_material_src_cdk_drag_drop_drag_drop_b };\n//# sourceMappingURL=drag-drop.js.map\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { SectionHeaderComponent } from './section-header.component';\r\nimport { MatSelectModule } from '@angular/material/select';\r\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\r\nimport { MatDatepickerModule } from '@angular/material/datepicker';\r\nimport { MatMomentDateModule } from '@angular/material-moment-adapter';\r\nimport { MatFormFieldModule } from '@angular/material/form-field';\r\nimport { MatInputModule } from '@angular/material/input';\r\nimport { MatIconModule } from '@angular/material/icon';\r\nimport { RouterModule } from '@angular/router';\r\n\r\n@NgModule({\r\n  declarations: [SectionHeaderComponent],\r\n  imports: [\r\n    CommonModule,\r\n    MatSelectModule,\r\n    FormsModule,\r\n    ReactiveFormsModule,\r\n    MatDatepickerModule,\r\n    MatMomentDateModule,\r\n    MatFormFieldModule,\r\n    MatInputModule,\r\n    MatIconModule,\r\n    RouterModule,\r\n  ],\r\n  exports: [SectionHeaderComponent, MatInputModule, MatFormFieldModule],\r\n})\r\nexport class SectionHeaderModule {}\r\n","import { CdkAccordionItem, CdkAccordion, CdkAccordionModule } from '@angular/cdk/accordion';\nimport { TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { InjectionToken, Directive, TemplateRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, SkipSelf, Inject, ChangeDetectorRef, ViewContainerRef, Input, Output, ContentChild, ViewChild, Host, ElementRef, QueryList, ContentChildren, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';\nimport { ENTER, hasModifierKey, SPACE, HOME, END } from '@angular/cdk/keycodes';\nimport { distinctUntilChanged, startWith, filter, take } from 'rxjs/operators';\nimport { Subject, Subscription, EMPTY, merge } from 'rxjs';\nimport { trigger, state, style, transition, animate, group, query, animateChild } from '@angular/animations';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/accordion-base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Base interface for a `MatAccordion`.\n * \\@docs-private\n * @record\n */\nfunction MatAccordionBase() { }\nif (false) {\n    /**\n     * Whether the expansion indicator should be hidden.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.hideToggle;\n    /**\n     * Display mode used for all expansion panels in the accordion.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.displayMode;\n    /**\n     * The position of the expansion indicator.\n     * @type {?}\n     */\n    MatAccordionBase.prototype.togglePosition;\n    /**\n     * Handles keyboard events coming in from the panel headers.\n     * @type {?}\n     */\n    MatAccordionBase.prototype._handleHeaderKeydown;\n    /**\n     * Handles focus events on the panel headers.\n     * @type {?}\n     */\n    MatAccordionBase.prototype._handleHeaderFocus;\n}\n/**\n * Token used to provide a `MatAccordion` to `MatExpansionPanel`.\n * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.\n * @type {?}\n */\nconst MAT_ACCORDION = new InjectionToken('MAT_ACCORDION');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-animations.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Time and timing curve for expansion panel animations.\n * @type {?}\n */\nconst EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';\n/**\n * Animations used by the Material expansion panel.\n *\n * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()\n * causes the animation state of moved components to become `void` upon exit, and not update again\n * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state\n * of the panel is `expanded` or `collapsed` but the animation state is `void`.\n *\n * To correctly handle animating to the next state, we animate between `void` and `collapsed` which\n * are defined to have the same styles. Since angular animates from the current styles to the\n * destination state's style definition, in situations where we are moving from `void`'s styles to\n * `collapsed` this acts a noop since no style values change.\n *\n * In the case where angular's animation state is out of sync with the expansion panel's state, the\n * expansion panel being `expanded` and angular animations being `void`, the animation from the\n * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will\n * occur as expected.\n *\n * Angular Bug: https://github.com/angular/angular/issues/18847\n *\n * \\@docs-private\n * @type {?}\n */\nconst matExpansionAnimations = {\n    /**\n     * Animation that rotates the indicator arrow.\n     */\n    indicatorRotate: trigger('indicatorRotate', [\n        state('collapsed, void', style({ transform: 'rotate(0deg)' })),\n        state('expanded', style({ transform: 'rotate(180deg)' })),\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ]),\n    /**\n     * Animation that expands and collapses the panel header height.\n     */\n    expansionHeaderHeight: trigger('expansionHeight', [\n        state('collapsed, void', style({\n            height: '{{collapsedHeight}}',\n        }), {\n            params: { collapsedHeight: '48px' },\n        }),\n        state('expanded', style({\n            height: '{{expandedHeight}}'\n        }), {\n            params: { expandedHeight: '64px' }\n        }),\n        transition('expanded <=> collapsed, void => collapsed', group([\n            query('@indicatorRotate', animateChild(), { optional: true }),\n            animate(EXPANSION_PANEL_ANIMATION_TIMING),\n        ])),\n    ]),\n    /**\n     * Animation that expands and collapses the panel content.\n     */\n    bodyExpansion: trigger('bodyExpansion', [\n        state('collapsed, void', style({ height: '0px', visibility: 'hidden' })),\n        state('expanded', style({ height: '*', visibility: 'visible' })),\n        transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel-content.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Expansion panel content that will be rendered lazily\n * after the panel is opened for the first time.\n */\nclass MatExpansionPanelContent {\n    /**\n     * @param {?} _template\n     */\n    constructor(_template) {\n        this._template = _template;\n    }\n}\nMatExpansionPanelContent.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[matExpansionPanelContent]'\n            },] }\n];\n/** @nocollapse */\nMatExpansionPanelContent.ctorParameters = () => [\n    { type: TemplateRef }\n];\nif (false) {\n    /** @type {?} */\n    MatExpansionPanelContent.prototype._template;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter for generating unique element ids.\n * @type {?}\n */\nlet uniqueId = 0;\n/**\n * Object that can be used to override the default options\n * for all of the expansion panels in a module.\n * @record\n */\nfunction MatExpansionPanelDefaultOptions() { }\nif (false) {\n    /**\n     * Height of the header while the panel is expanded.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.expandedHeight;\n    /**\n     * Height of the header while the panel is collapsed.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.collapsedHeight;\n    /**\n     * Whether the toggle indicator should be hidden.\n     * @type {?}\n     */\n    MatExpansionPanelDefaultOptions.prototype.hideToggle;\n}\n/**\n * Injection token that can be used to configure the defalt\n * options for the expansion panel component.\n * @type {?}\n */\nconst MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new InjectionToken('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');\nconst Éµ0 = undefined;\n/**\n * `<mat-expansion-panel>`\n *\n * This component can be used as a single element to show expandable content, or as one of\n * multiple children of an element with the MatAccordion directive attached.\n */\nclass MatExpansionPanel extends CdkAccordionItem {\n    /**\n     * @param {?} accordion\n     * @param {?} _changeDetectorRef\n     * @param {?} _uniqueSelectionDispatcher\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     * @param {?} _animationMode\n     * @param {?=} defaultOptions\n     */\n    constructor(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {\n        super(accordion, _changeDetectorRef, _uniqueSelectionDispatcher);\n        this._viewContainerRef = _viewContainerRef;\n        this._animationMode = _animationMode;\n        this._hideToggle = false;\n        /**\n         * An event emitted after the body's expansion animation happens.\n         */\n        this.afterExpand = new EventEmitter();\n        /**\n         * An event emitted after the body's collapse animation happens.\n         */\n        this.afterCollapse = new EventEmitter();\n        /**\n         * Stream that emits for changes in `\\@Input` properties.\n         */\n        this._inputChanges = new Subject();\n        /**\n         * ID for the associated header element. Used for a11y labelling.\n         */\n        this._headerId = `mat-expansion-panel-header-${uniqueId++}`;\n        /**\n         * Stream of body animation done events.\n         */\n        this._bodyAnimationDone = new Subject();\n        this.accordion = accordion;\n        this._document = _document;\n        // We need a Subject with distinctUntilChanged, because the `done` event\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n        this._bodyAnimationDone.pipe(distinctUntilChanged((/**\n         * @param {?} x\n         * @param {?} y\n         * @return {?}\n         */\n        (x, y) => {\n            return x.fromState === y.fromState && x.toState === y.toState;\n        }))).subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            if (event.fromState !== 'void') {\n                if (event.toState === 'expanded') {\n                    this.afterExpand.emit();\n                }\n                else if (event.toState === 'collapsed') {\n                    this.afterCollapse.emit();\n                }\n            }\n        }));\n        if (defaultOptions) {\n            this.hideToggle = defaultOptions.hideToggle;\n        }\n    }\n    /**\n     * Whether the toggle indicator should be hidden.\n     * @return {?}\n     */\n    get hideToggle() {\n        return this._hideToggle || (this.accordion && this.accordion.hideToggle);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hideToggle(value) {\n        this._hideToggle = coerceBooleanProperty(value);\n    }\n    /**\n     * The position of the expansion indicator.\n     * @return {?}\n     */\n    get togglePosition() {\n        return this._togglePosition || (this.accordion && this.accordion.togglePosition);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set togglePosition(value) {\n        this._togglePosition = value;\n    }\n    /**\n     * Determines whether the expansion panel should have spacing between it and its siblings.\n     * @return {?}\n     */\n    _hasSpacing() {\n        if (this.accordion) {\n            return this.expanded && this.accordion.displayMode === 'default';\n        }\n        return false;\n    }\n    /**\n     * Gets the expanded state string.\n     * @return {?}\n     */\n    _getExpandedState() {\n        return this.expanded ? 'expanded' : 'collapsed';\n    }\n    /**\n     * Toggles the expanded state of the expansion panel.\n     * @return {?}\n     */\n    toggle() {\n        this.expanded = !this.expanded;\n    }\n    /**\n     * Sets the expanded state of the expansion panel to false.\n     * @return {?}\n     */\n    close() {\n        this.expanded = false;\n    }\n    /**\n     * Sets the expanded state of the expansion panel to true.\n     * @return {?}\n     */\n    open() {\n        this.expanded = true;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        if (this._lazyContent) {\n            // Render the content as soon as the panel becomes open.\n            this.opened.pipe(startWith((/** @type {?} */ (null))), filter((/**\n             * @return {?}\n             */\n            () => this.expanded && !this._portal)), take(1)).subscribe((/**\n             * @return {?}\n             */\n            () => {\n                this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);\n            }));\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this._inputChanges.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._bodyAnimationDone.complete();\n        this._inputChanges.complete();\n    }\n    /**\n     * Checks whether the expansion panel's content contains the currently-focused element.\n     * @return {?}\n     */\n    _containsFocus() {\n        if (this._body) {\n            /** @type {?} */\n            const focusedElement = this._document.activeElement;\n            /** @type {?} */\n            const bodyElement = this._body.nativeElement;\n            return focusedElement === bodyElement || bodyElement.contains(focusedElement);\n        }\n        return false;\n    }\n}\nMatExpansionPanel.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-expansion-panel',\n                exportAs: 'matExpansionPanel',\n                template: \"<ng-content select=\\\"mat-expansion-panel-header\\\"></ng-content>\\n<div class=\\\"mat-expansion-panel-content\\\"\\n     role=\\\"region\\\"\\n     [@bodyExpansion]=\\\"_getExpandedState()\\\"\\n     (@bodyExpansion.done)=\\\"_bodyAnimationDone.next($event)\\\"\\n     [attr.aria-labelledby]=\\\"_headerId\\\"\\n     [id]=\\\"id\\\"\\n     #body>\\n  <div class=\\\"mat-expansion-panel-body\\\">\\n    <ng-content></ng-content>\\n    <ng-template [cdkPortalOutlet]=\\\"_portal\\\"></ng-template>\\n  </div>\\n  <ng-content select=\\\"mat-action-row\\\"></ng-content>\\n</div>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                inputs: ['disabled', 'expanded'],\n                outputs: ['opened', 'closed', 'expandedChange'],\n                animations: [matExpansionAnimations.bodyExpansion],\n                providers: [\n                    // Provide MatAccordion as undefined to prevent nested expansion panels from registering\n                    // to the same accordion.\n                    { provide: MAT_ACCORDION, useValue: Éµ0 },\n                ],\n                host: {\n                    'class': 'mat-expansion-panel',\n                    '[class.mat-expanded]': 'expanded',\n                    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                    '[class.mat-expansion-panel-spacing]': '_hasSpacing()',\n                },\n                styles: [\".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatExpansionPanel.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [MAT_ACCORDION,] }] },\n    { type: ChangeDetectorRef },\n    { type: UniqueSelectionDispatcher },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\n];\nMatExpansionPanel.propDecorators = {\n    hideToggle: [{ type: Input }],\n    togglePosition: [{ type: Input }],\n    afterExpand: [{ type: Output }],\n    afterCollapse: [{ type: Output }],\n    _lazyContent: [{ type: ContentChild, args: [MatExpansionPanelContent,] }],\n    _body: [{ type: ViewChild, args: ['body',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_hideToggle;\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_expanded;\n    /** @type {?} */\n    MatExpansionPanel.ngAcceptInputType_disabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._hideToggle;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._togglePosition;\n    /**\n     * An event emitted after the body's expansion animation happens.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.afterExpand;\n    /**\n     * An event emitted after the body's collapse animation happens.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.afterCollapse;\n    /**\n     * Stream that emits for changes in `\\@Input` properties.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._inputChanges;\n    /**\n     * Optionally defined accordion the expansion panel belongs to.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype.accordion;\n    /**\n     * Content that will be rendered lazily.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._lazyContent;\n    /**\n     * Element containing the panel's user-provided content.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._body;\n    /**\n     * Portal holding the user's content.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._portal;\n    /**\n     * ID for the associated header element. Used for a11y labelling.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._headerId;\n    /**\n     * Stream of body animation done events.\n     * @type {?}\n     */\n    MatExpansionPanel.prototype._bodyAnimationDone;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanel.prototype._viewContainerRef;\n    /** @type {?} */\n    MatExpansionPanel.prototype._animationMode;\n}\nclass MatExpansionPanelActionRow {\n}\nMatExpansionPanelActionRow.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-action-row',\n                host: {\n                    class: 'mat-action-row'\n                }\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-panel-header.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * `<mat-expansion-panel-header>`\n *\n * This component corresponds to the header element of an `<mat-expansion-panel>`.\n */\nclass MatExpansionPanelHeader {\n    /**\n     * @param {?} panel\n     * @param {?} _element\n     * @param {?} _focusMonitor\n     * @param {?} _changeDetectorRef\n     * @param {?=} defaultOptions\n     */\n    constructor(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {\n        this.panel = panel;\n        this._element = _element;\n        this._focusMonitor = _focusMonitor;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._parentChangeSubscription = Subscription.EMPTY;\n        /**\n         * Whether Angular animations in the panel header should be disabled.\n         */\n        this._animationsDisabled = true;\n        /** @type {?} */\n        const accordionHideToggleChange = panel.accordion ?\n            panel.accordion._stateChanges.pipe(filter((/**\n             * @param {?} changes\n             * @return {?}\n             */\n            changes => !!(changes['hideToggle'] || changes['togglePosition'])))) :\n            EMPTY;\n        // Since the toggle state depends on an @Input on the panel, we\n        // need to subscribe and trigger change detection manually.\n        this._parentChangeSubscription =\n            merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter((/**\n             * @param {?} changes\n             * @return {?}\n             */\n            changes => {\n                return !!(changes['hideToggle'] ||\n                    changes['disabled'] ||\n                    changes['togglePosition']);\n            }))))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => this._changeDetectorRef.markForCheck()));\n        // Avoids focus being lost if the panel contained the focused element and was closed.\n        panel.closed\n            .pipe(filter((/**\n         * @return {?}\n         */\n        () => panel._containsFocus())))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => _focusMonitor.focusVia(_element, 'program')));\n        _focusMonitor.monitor(_element).subscribe((/**\n         * @param {?} origin\n         * @return {?}\n         */\n        origin => {\n            if (origin && panel.accordion) {\n                panel.accordion._handleHeaderFocus(this);\n            }\n        }));\n        if (defaultOptions) {\n            this.expandedHeight = defaultOptions.expandedHeight;\n            this.collapsedHeight = defaultOptions.collapsedHeight;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _animationStarted() {\n        // Currently the `expansionHeight` animation has a `void => collapsed` transition which is\n        // there to work around a bug in Angular (see #13088), however this introduces a different\n        // issue. The new transition will cause the header to animate in on init (see #16067), if the\n        // consumer has set a header height that is different from the default one. We work around it\n        // by disabling animations on the header and re-enabling them after the first animation has run.\n        // Note that Angular dispatches animation events even if animations are disabled. Ideally this\n        // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait\n        // for https://github.com/angular/angular/issues/18847 to be resolved.\n        this._animationsDisabled = false;\n    }\n    /**\n     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() {\n        return this.panel.disabled;\n    }\n    /**\n     * Toggles the expanded state of the panel.\n     * @return {?}\n     */\n    _toggle() {\n        if (!this.disabled) {\n            this.panel.toggle();\n        }\n    }\n    /**\n     * Gets whether the panel is expanded.\n     * @return {?}\n     */\n    _isExpanded() {\n        return this.panel.expanded;\n    }\n    /**\n     * Gets the expanded state string of the panel.\n     * @return {?}\n     */\n    _getExpandedState() {\n        return this.panel._getExpandedState();\n    }\n    /**\n     * Gets the panel id.\n     * @return {?}\n     */\n    _getPanelId() {\n        return this.panel.id;\n    }\n    /**\n     * Gets the toggle position for the header.\n     * @return {?}\n     */\n    _getTogglePosition() {\n        return this.panel.togglePosition;\n    }\n    /**\n     * Gets whether the expand indicator should be shown.\n     * @return {?}\n     */\n    _showToggle() {\n        return !this.panel.hideToggle && !this.panel.disabled;\n    }\n    /**\n     * Handle keydown event calling to toggle() if appropriate.\n     * @param {?} event\n     * @return {?}\n     */\n    _keydown(event) {\n        switch (event.keyCode) {\n            // Toggle for space and enter keys.\n            case SPACE:\n            case ENTER:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this._toggle();\n                }\n                break;\n            default:\n                if (this.panel.accordion) {\n                    this.panel.accordion._handleHeaderKeydown(event);\n                }\n                return;\n        }\n    }\n    /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * \\@docs-private\n     * @param {?=} origin Origin of the action that triggered the focus.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        this._focusMonitor.focusVia(this._element, origin, options);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._parentChangeSubscription.unsubscribe();\n        this._focusMonitor.stopMonitoring(this._element);\n    }\n}\nMatExpansionPanelHeader.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-expansion-panel-header',\n                template: \"<span class=\\\"mat-content\\\">\\n  <ng-content select=\\\"mat-panel-title\\\"></ng-content>\\n  <ng-content select=\\\"mat-panel-description\\\"></ng-content>\\n  <ng-content></ng-content>\\n</span>\\n<span [@indicatorRotate]=\\\"_getExpandedState()\\\" *ngIf=\\\"_showToggle()\\\"\\n      class=\\\"mat-expansion-indicator\\\"></span>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                animations: [\n                    matExpansionAnimations.indicatorRotate,\n                    matExpansionAnimations.expansionHeaderHeight\n                ],\n                host: {\n                    'class': 'mat-expansion-panel-header',\n                    'role': 'button',\n                    '[attr.id]': 'panel._headerId',\n                    '[attr.tabindex]': 'disabled ? -1 : 0',\n                    '[attr.aria-controls]': '_getPanelId()',\n                    '[attr.aria-expanded]': '_isExpanded()',\n                    '[attr.aria-disabled]': 'panel.disabled',\n                    '[class.mat-expanded]': '_isExpanded()',\n                    '[class.mat-expansion-toggle-indicator-after]': `_getTogglePosition() === 'after'`,\n                    '[class.mat-expansion-toggle-indicator-before]': `_getTogglePosition() === 'before'`,\n                    '(click)': '_toggle()',\n                    '(keydown)': '_keydown($event)',\n                    '[@.disabled]': '_animationsDisabled',\n                    '(@expansionHeight.start)': '_animationStarted()',\n                    '[@expansionHeight]': `{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }`,\n                },\n                styles: [\".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:\\\"\\\";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatExpansionPanelHeader.ctorParameters = () => [\n    { type: MatExpansionPanel, decorators: [{ type: Host }] },\n    { type: ElementRef },\n    { type: FocusMonitor },\n    { type: ChangeDetectorRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: Optional }] }\n];\nMatExpansionPanelHeader.propDecorators = {\n    expandedHeight: [{ type: Input }],\n    collapsedHeight: [{ type: Input }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._parentChangeSubscription;\n    /**\n     * Whether Angular animations in the panel header should be disabled.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype._animationsDisabled;\n    /**\n     * Height of the header while the panel is expanded.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype.expandedHeight;\n    /**\n     * Height of the header while the panel is collapsed.\n     * @type {?}\n     */\n    MatExpansionPanelHeader.prototype.collapsedHeight;\n    /** @type {?} */\n    MatExpansionPanelHeader.prototype.panel;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._element;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._focusMonitor;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatExpansionPanelHeader.prototype._changeDetectorRef;\n}\n/**\n * `<mat-panel-description>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nclass MatExpansionPanelDescription {\n}\nMatExpansionPanelDescription.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-panel-description',\n                host: {\n                    class: 'mat-expansion-panel-header-description'\n                }\n            },] }\n];\n/**\n * `<mat-panel-title>`\n *\n * This directive is to be used inside of the MatExpansionPanelHeader component.\n */\nclass MatExpansionPanelTitle {\n}\nMatExpansionPanelTitle.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-panel-title',\n                host: {\n                    class: 'mat-expansion-panel-header-title'\n                }\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/accordion.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive for a Material Design Accordion.\n */\nclass MatAccordion extends CdkAccordion {\n    constructor() {\n        super(...arguments);\n        /**\n         * Headers belonging to this accordion.\n         */\n        this._ownHeaders = new QueryList();\n        this._hideToggle = false;\n        /**\n         * Display mode used for all expansion panels in the accordion. Currently two display\n         * modes exist:\n         *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n         *     panel at a different elevation from the rest of the accordion.\n         *  flat - no spacing is placed around expanded panels, showing all panels at the same\n         *     elevation.\n         */\n        this.displayMode = 'default';\n        /**\n         * The position of the expansion indicator.\n         */\n        this.togglePosition = 'after';\n    }\n    /**\n     * Whether the expansion indicator should be hidden.\n     * @return {?}\n     */\n    get hideToggle() { return this._hideToggle; }\n    /**\n     * @param {?} show\n     * @return {?}\n     */\n    set hideToggle(show) { this._hideToggle = coerceBooleanProperty(show); }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._headers.changes\n            .pipe(startWith(this._headers))\n            .subscribe((/**\n         * @param {?} headers\n         * @return {?}\n         */\n        (headers) => {\n            this._ownHeaders.reset(headers.filter((/**\n             * @param {?} header\n             * @return {?}\n             */\n            header => header.panel.accordion === this)));\n            this._ownHeaders.notifyOnChanges();\n        }));\n        this._keyManager = new FocusKeyManager(this._ownHeaders).withWrap();\n    }\n    /**\n     * Handles keyboard events coming in from the panel headers.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleHeaderKeydown(event) {\n        const { keyCode } = event;\n        /** @type {?} */\n        const manager = this._keyManager;\n        if (keyCode === HOME) {\n            if (!hasModifierKey(event)) {\n                manager.setFirstItemActive();\n                event.preventDefault();\n            }\n        }\n        else if (keyCode === END) {\n            if (!hasModifierKey(event)) {\n                manager.setLastItemActive();\n                event.preventDefault();\n            }\n        }\n        else {\n            this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * @param {?} header\n     * @return {?}\n     */\n    _handleHeaderFocus(header) {\n        this._keyManager.updateActiveItem(header);\n    }\n}\nMatAccordion.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-accordion',\n                exportAs: 'matAccordion',\n                inputs: ['multi'],\n                providers: [{\n                        provide: MAT_ACCORDION,\n                        useExisting: MatAccordion\n                    }],\n                host: {\n                    class: 'mat-accordion',\n                    // Class binding which is only used by the test harness as there is no other\n                    // way for the harness to detect if multiple panel support is enabled.\n                    '[class.mat-accordion-multi]': 'this.multi',\n                }\n            },] }\n];\nMatAccordion.propDecorators = {\n    _headers: [{ type: ContentChildren, args: [MatExpansionPanelHeader, { descendants: true },] }],\n    hideToggle: [{ type: Input }],\n    displayMode: [{ type: Input }],\n    togglePosition: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    MatAccordion.ngAcceptInputType_hideToggle;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._keyManager;\n    /**\n     * Headers belonging to this accordion.\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._ownHeaders;\n    /**\n     * All headers inside the accordion. Includes headers inside nested accordions.\n     * @type {?}\n     */\n    MatAccordion.prototype._headers;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAccordion.prototype._hideToggle;\n    /**\n     * Display mode used for all expansion panels in the accordion. Currently two display\n     * modes exist:\n     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n     *     panel at a different elevation from the rest of the accordion.\n     *  flat - no spacing is placed around expanded panels, showing all panels at the same\n     *     elevation.\n     * @type {?}\n     */\n    MatAccordion.prototype.displayMode;\n    /**\n     * The position of the expansion indicator.\n     * @type {?}\n     */\n    MatAccordion.prototype.togglePosition;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/expansion-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatExpansionModule {\n}\nMatExpansionModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule, CdkAccordionModule, PortalModule],\n                exports: [\n                    MatAccordion,\n                    MatExpansionPanel,\n                    MatExpansionPanelActionRow,\n                    MatExpansionPanelHeader,\n                    MatExpansionPanelTitle,\n                    MatExpansionPanelDescription,\n                    MatExpansionPanelContent,\n                ],\n                declarations: [\n                    MatAccordion,\n                    MatExpansionPanel,\n                    MatExpansionPanelActionRow,\n                    MatExpansionPanelHeader,\n                    MatExpansionPanelTitle,\n                    MatExpansionPanelDescription,\n                    MatExpansionPanelContent,\n                ],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/expansion/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { EXPANSION_PANEL_ANIMATION_TIMING, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatAccordion, MatExpansionModule, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelContent, MatExpansionPanelDescription, MatExpansionPanelHeader, MatExpansionPanelTitle, matExpansionAnimations };\n//# sourceMappingURL=expansion.js.map\n","import { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UP_ARROW, DOWN_ARROW, END, hasModifierKey, HOME, RIGHT_ARROW, LEFT_ARROW, ESCAPE } from '@angular/cdk/keycodes';\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, ChangeDetectorRef, InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Optional, Input, HostListener, QueryList, EventEmitter, NgZone, ContentChildren, ViewChild, ContentChild, Output, Self, NgModule } from '@angular/core';\nimport { Subject, Subscription, merge, of, asapScheduler } from 'rxjs';\nimport { startWith, switchMap, take, filter, takeUntil, delay } from 'rxjs/operators';\nimport { trigger, state, style, transition, group, query, animate } from '@angular/animations';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { mixinDisableRipple, mixinDisabled, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-animations.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * \\@docs-private\n * @type {?}\n */\nconst matMenuAnimations = {\n    /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n    transformMenu: trigger('transformMenu', [\n        state('void', style({\n            opacity: 0,\n            transform: 'scale(0.8)'\n        })),\n        transition('void => enter', group([\n            query('.mat-menu-content, .mat-mdc-menu-content', animate('100ms linear', style({\n                opacity: 1\n            }))),\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\n        ])),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\n    ]),\n    /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n    fadeInItems: trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        state('showing', style({ opacity: 1 })),\n        transition('void => *', [\n            style({ opacity: 0 }),\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nconst transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-content.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nclass MatMenuContent {\n    /**\n     * @param {?} _template\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     * @param {?=} _changeDetectorRef\n     */\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n        this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * Emits when the menu content has been attached.\n         */\n        this._attached = new Subject();\n    }\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    attach(context = {}) {\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n        }\n        /** @type {?} */\n        const element = this._template.elementRef.nativeElement;\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        (/** @type {?} */ (element.parentNode)).insertBefore(this._outlet.outletElement, element);\n        // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\n        // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\n        // by Angular. This causes the `@ContentChildren` for menu items within the menu to\n        // not be updated by Angular. By explicitly marking for check here, we tell Angular that\n        // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\n        // @breaking-change 9.0.0 Make change detector ref required\n        if (this._changeDetectorRef) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    detach() {\n        if (this._portal.isAttached) {\n            this._portal.detach();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._outlet) {\n            this._outlet.dispose();\n        }\n    }\n}\nMatMenuContent.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[matMenuContent]'\n            },] }\n];\n/** @nocollapse */\nMatMenuContent.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ComponentFactoryResolver },\n    { type: ApplicationRef },\n    { type: Injector },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: ChangeDetectorRef }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._portal;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._outlet;\n    /**\n     * Emits when the menu content has been attached.\n     * @type {?}\n     */\n    MatMenuContent.prototype._attached;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._template;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._componentFactoryResolver;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._appRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._injector;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuContent.prototype._changeDetectorRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-errors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-panel.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n/**\n * Interface for a custom menu panel that can be used with `matMenuTriggerFor`.\n * \\@docs-private\n * @record\n * @template T\n */\nfunction MatMenuPanel() { }\nif (false) {\n    /** @type {?} */\n    MatMenuPanel.prototype.xPosition;\n    /** @type {?} */\n    MatMenuPanel.prototype.yPosition;\n    /** @type {?} */\n    MatMenuPanel.prototype.overlapTrigger;\n    /** @type {?} */\n    MatMenuPanel.prototype.templateRef;\n    /** @type {?} */\n    MatMenuPanel.prototype.close;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.parentMenu;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.direction;\n    /** @type {?} */\n    MatMenuPanel.prototype.focusFirstItem;\n    /** @type {?} */\n    MatMenuPanel.prototype.resetActiveItem;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.setPositionClasses;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.lazyContent;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.backdropClass;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.hasBackdrop;\n    /** @type {?|undefined} */\n    MatMenuPanel.prototype.panelId;\n    /**\n     * @deprecated To be removed.\n     * \\@breaking-change 8.0.0\n     * @type {?|undefined}\n     */\n    MatMenuPanel.prototype.addItem;\n    /**\n     * @deprecated To be removed.\n     * \\@breaking-change 8.0.0\n     * @type {?|undefined}\n     */\n    MatMenuPanel.prototype.removeItem;\n    /**\n     * @param {?} depth\n     * @return {?}\n     */\n    MatMenuPanel.prototype.setElevation = function (depth) { };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-item.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatMenuItem.\n/**\n * \\@docs-private\n */\nclass MatMenuItemBase {\n}\n/** @type {?} */\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nclass MatMenuItem extends _MatMenuItemMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?=} document\n     * @param {?=} _focusMonitor\n     * @param {?=} _parentMenu\n     */\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\n        super();\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._parentMenu = _parentMenu;\n        /**\n         * ARIA role for the menu item.\n         */\n        this.role = 'menuitem';\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        this._hovered = new Subject();\n        /**\n         * Stream that emits when the menu item is focused.\n         */\n        this._focused = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(this._elementRef, false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(this);\n        }\n        this._document = document;\n    }\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n        }\n        else {\n            this._getHostElement().focus(options);\n        }\n        this._focused.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n        this._focused.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n    _checkDisabled(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n    _handleMouseEnter() {\n        this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    getLabel() {\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        /** @type {?} */\n        const textNodeType = this._document ? this._document.TEXT_NODE : 3;\n        /** @type {?} */\n        let output = '';\n        if (element.childNodes) {\n            /** @type {?} */\n            const length = element.childNodes.length;\n            // Go through all the top-level text nodes and extract their text.\n            // We skip anything that's not a text node to prevent the text from\n            // being thrown off by something like an icon.\n            for (let i = 0; i < length; i++) {\n                if (element.childNodes[i].nodeType === textNodeType) {\n                    output += element.childNodes[i].textContent;\n                }\n            }\n        }\n        return output.trim();\n    }\n}\nMatMenuItem.decorators = [\n    { type: Component, args: [{\n                selector: '[mat-menu-item]',\n                exportAs: 'matMenuItem',\n                inputs: ['disabled', 'disableRipple'],\n                host: {\n                    '[attr.role]': 'role',\n                    '[class.mat-menu-item]': 'true',\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n                    '[attr.tabindex]': '_getTabIndex()',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.disabled]': 'disabled || null',\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                template: \"<ng-content></ng-content>\\n<div class=\\\"mat-menu-ripple\\\" matRipple\\n     [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n     [matRippleTrigger]=\\\"_getHostElement()\\\">\\n</div>\\n\"\n            }] }\n];\n/** @nocollapse */\nMatMenuItem.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: FocusMonitor },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\n];\nMatMenuItem.propDecorators = {\n    role: [{ type: Input }],\n    _checkDisabled: [{ type: HostListener, args: ['click', ['$event'],] }],\n    _handleMouseEnter: [{ type: HostListener, args: ['mouseenter',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatMenuItem.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatMenuItem.ngAcceptInputType_disableRipple;\n    /**\n     * ARIA role for the menu item.\n     * @type {?}\n     */\n    MatMenuItem.prototype.role;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._document;\n    /**\n     * Stream that emits when the menu item is hovered.\n     * @type {?}\n     */\n    MatMenuItem.prototype._hovered;\n    /**\n     * Stream that emits when the menu item is focused.\n     * @type {?}\n     */\n    MatMenuItem.prototype._focused;\n    /**\n     * Whether the menu item is highlighted.\n     * @type {?}\n     */\n    MatMenuItem.prototype._highlighted;\n    /**\n     * Whether the menu item acts as a trigger for a sub-menu.\n     * @type {?}\n     */\n    MatMenuItem.prototype._triggersSubmenu;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuItem.prototype._focusMonitor;\n    /** @type {?} */\n    MatMenuItem.prototype._parentMenu;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default `mat-menu` options that can be overridden.\n * @record\n */\nfunction MatMenuDefaultOptions() { }\nif (false) {\n    /**\n     * The x-axis position of the menu.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.xPosition;\n    /**\n     * The y-axis position of the menu.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.yPosition;\n    /**\n     * Whether the menu should overlap the menu trigger.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.overlapTrigger;\n    /**\n     * Class to be applied to the menu's backdrop.\n     * @type {?}\n     */\n    MatMenuDefaultOptions.prototype.backdropClass;\n    /**\n     * Whether the menu has a backdrop.\n     * @type {?|undefined}\n     */\n    MatMenuDefaultOptions.prototype.hasBackdrop;\n}\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n * @type {?}\n */\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: false,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_BASE_ELEVATION = 4;\n/** @type {?} */\nlet menuPanelUid = 0;\n/**\n * Base class with all of the `MatMenu` functionality.\n */\n// tslint:disable-next-line:class-name\nclass _MatMenuBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} _defaultOptions\n     */\n    constructor(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Only the direct descendant menu items.\n         */\n        this._directDescendantItems = new QueryList();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.close = this.closed;\n        this.panelId = `mat-menu-panel-${menuPanelUid++}`;\n    }\n    /**\n     * Position of the menu in the X axis.\n     * @return {?}\n     */\n    get xPosition() { return this._xPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set xPosition(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMatMenuInvalidPositionX();\n        }\n        this._xPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n    get yPosition() { return this._yPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set yPosition(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMatMenuInvalidPositionY();\n        }\n        this._yPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n    get overlapTrigger() { return this._overlapTrigger; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set overlapTrigger(value) {\n        this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n    get hasBackdrop() { return this._hasBackdrop; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hasBackdrop(value) {\n        this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n    set panelClass(classes) {\n        /** @type {?} */\n        const previousPanelClass = this._previousPanelClass;\n        if (previousPanelClass && previousPanelClass.length) {\n            previousPanelClass.split(' ').forEach((/**\n             * @param {?} className\n             * @return {?}\n             */\n            (className) => {\n                this._classList[className] = false;\n            }));\n        }\n        this._previousPanelClass = classes;\n        if (classes && classes.length) {\n            classes.split(' ').forEach((/**\n             * @param {?} className\n             * @return {?}\n             */\n            (className) => {\n                this._classList[className] = true;\n            }));\n            this._elementRef.nativeElement.className = '';\n        }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get classList() { return this.panelClass; }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    set classList(classes) { this.panelClass = classes; }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._updateDirectDescendants();\n        this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead();\n        this._tabSubscription = this._keyManager.tabOut.subscribe((/**\n         * @return {?}\n         */\n        () => this.closed.emit('tab')));\n        // If a user manually (programatically) focuses a menu item, we need to reflect that focus\n        // change back to the key manager. Note that we don't need to unsubscribe here because _focused\n        // is internal and we know that it gets completed on destroy.\n        this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap((/**\n         * @param {?} items\n         * @return {?}\n         */\n        items => merge(...items.map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => item._focused)))))).subscribe((/**\n         * @param {?} focusedItem\n         * @return {?}\n         */\n        focusedItem => this._keyManager.updateActiveItem(focusedItem)));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._directDescendantItems.destroy();\n        this._tabSubscription.unsubscribe();\n        this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    _hovered() {\n        // Coerce the `changes` property because Angular types it as `Observable<any>`\n        /** @type {?} */\n        const itemChanges = (/** @type {?} */ (this._directDescendantItems.changes));\n        return (/** @type {?} */ (itemChanges.pipe(startWith(this._directDescendantItems), switchMap((/**\n         * @param {?} items\n         * @return {?}\n         */\n        items => merge(...items.map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => item._hovered))))))));\n    }\n    /*\n       * Registers a menu item with the menu.\n       * @docs-private\n       * @deprecated No longer being used. To be removed.\n       * @breaking-change 9.0.0\n       */\n    /**\n     * @param {?} _item\n     * @return {?}\n     */\n    addItem(_item) { }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 9.0.0\n     * @param {?} _item\n     * @return {?}\n     */\n    removeItem(_item) { }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        /** @type {?} */\n        const manager = this._keyManager;\n        switch (keyCode) {\n            case ESCAPE:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this.closed.emit('keydown');\n                }\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case HOME:\n            case END:\n                if (!hasModifierKey(event)) {\n                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n                    event.preventDefault();\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    manager.setFocusOrigin('keyboard');\n                }\n                manager.onKeydown(event);\n        }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    focusFirstItem(origin = 'program') {\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n        if (this.lazyContent) {\n            this._ngZone.onStable.asObservable()\n                .pipe(take(1))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => this._focusFirstItem(origin)));\n        }\n        else {\n            this._focusFirstItem(origin);\n        }\n    }\n    /**\n     * Actual implementation that focuses the first item. Needs to be separated\n     * out so we don't repeat the same logic in the public `focusFirstItem` method.\n     * @private\n     * @param {?} origin\n     * @return {?}\n     */\n    _focusFirstItem(origin) {\n        /** @type {?} */\n        const manager = this._keyManager;\n        manager.setFocusOrigin(origin).setFirstItemActive();\n        // If there's no active item at this point, it means that all the items are disabled.\n        // Move focus to the menu panel so keyboard events like Escape still work. Also this will\n        // give _some_ feedback to screen readers.\n        if (!manager.activeItem && this._directDescendantItems.length) {\n            /** @type {?} */\n            let element = this._directDescendantItems.first._getHostElement().parentElement;\n            // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't\n            // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either\n            // because the panel is inside an `ng-template`. We work around it by starting from one of\n            // the items and walking up the DOM.\n            while (element) {\n                if (element.getAttribute('role') === 'menu') {\n                    element.focus();\n                    break;\n                }\n                else {\n                    element = element.parentElement;\n                }\n            }\n        }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    resetActiveItem() {\n        this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    setElevation(depth) {\n        // The elevation starts at the base and increases by one for each level.\n        // Capped at 24 because that's the maximum elevation defined in the Material design spec.\n        /** @type {?} */\n        const elevation = Math.min(MAT_MENU_BASE_ELEVATION + depth, 24);\n        /** @type {?} */\n        const newElevation = `mat-elevation-z${elevation}`;\n        /** @type {?} */\n        const customElevation = Object.keys(this._classList).find((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => c.startsWith('mat-elevation-z')));\n        if (!customElevation || customElevation === this._previousElevation) {\n            if (this._previousElevation) {\n                this._classList[this._previousElevation] = false;\n            }\n            this._classList[newElevation] = true;\n            this._previousElevation = newElevation;\n        }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n        /** @type {?} */\n        const classes = this._classList;\n        classes['mat-menu-before'] = posX === 'before';\n        classes['mat-menu-after'] = posX === 'after';\n        classes['mat-menu-above'] = posY === 'above';\n        classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    _startAnimation() {\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\n        this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    _resetAnimation() {\n        // @breaking-change 8.0.0 Combine with _startAnimation.\n        this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationDone(event) {\n        this._animationDone.next(event);\n        this._isAnimating = false;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationStart(event) {\n        this._isAnimating = true;\n        // Scroll the content element to the top as soon as the animation starts. This is necessary,\n        // because we move focus to the first item while it's still being animated, which can throw\n        // the browser off when it determines the scroll position. Alternatively we can move focus\n        // when the animation is done, however moving focus asynchronously will interrupt screen\n        // readers which are in the process of reading out the menu already. We take the `element`\n        // from the `event` since we can't use a `ViewChild` to access the pane.\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n            event.element.scrollTop = 0;\n        }\n    }\n    /**\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\n     * items that are part of child menus, and using a custom way of registering items is unreliable\n     * when it comes to maintaining the item order.\n     * @private\n     * @return {?}\n     */\n    _updateDirectDescendants() {\n        this._allItems.changes\n            .pipe(startWith(this._allItems))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._directDescendantItems.reset(items.filter((/**\n             * @param {?} item\n             * @return {?}\n             */\n            item => item._parentMenu === this)));\n            this._directDescendantItems.notifyOnChanges();\n        }));\n    }\n}\n_MatMenuBase.decorators = [\n    { type: Directive }\n];\n/** @nocollapse */\n_MatMenuBase.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n];\n_MatMenuBase.propDecorators = {\n    _allItems: [{ type: ContentChildren, args: [MatMenuItem, { descendants: true },] }],\n    backdropClass: [{ type: Input }],\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\n    ariaDescribedby: [{ type: Input, args: ['aria-describedby',] }],\n    xPosition: [{ type: Input }],\n    yPosition: [{ type: Input }],\n    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],\n    items: [{ type: ContentChildren, args: [MatMenuItem, { descendants: false },] }],\n    lazyContent: [{ type: ContentChild, args: [MatMenuContent,] }],\n    overlapTrigger: [{ type: Input }],\n    hasBackdrop: [{ type: Input }],\n    panelClass: [{ type: Input, args: ['class',] }],\n    classList: [{ type: Input }],\n    closed: [{ type: Output }],\n    close: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    _MatMenuBase.ngAcceptInputType_overlapTrigger;\n    /** @type {?} */\n    _MatMenuBase.ngAcceptInputType_hasBackdrop;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._keyManager;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._xPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._yPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._previousElevation;\n    /**\n     * All items inside the menu. Includes items nested inside another menu.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._allItems;\n    /**\n     * Only the direct descendant menu items.\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._directDescendantItems;\n    /**\n     * Subscription to tab events on the menu panel\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._tabSubscription;\n    /**\n     * Config object to be passed into the menu's ngClass\n     * @type {?}\n     */\n    _MatMenuBase.prototype._classList;\n    /**\n     * Current state of the panel animation.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._panelAnimationState;\n    /**\n     * Emits whenever an animation on the menu completes.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._animationDone;\n    /**\n     * Whether the menu is animating.\n     * @type {?}\n     */\n    _MatMenuBase.prototype._isAnimating;\n    /**\n     * Parent menu of the current menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.parentMenu;\n    /**\n     * Layout direction of the menu.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.direction;\n    /**\n     * Class to be added to the backdrop element.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.backdropClass;\n    /**\n     * aria-label for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaLabel;\n    /**\n     * aria-labelledby for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaLabelledby;\n    /**\n     * aria-describedby for the menu panel.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.ariaDescribedby;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    _MatMenuBase.prototype.templateRef;\n    /**\n     * List of the items inside of a menu.\n     * @deprecated\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    _MatMenuBase.prototype.items;\n    /**\n     * Menu content that will be rendered lazily.\n     * \\@docs-private\n     * @type {?}\n     */\n    _MatMenuBase.prototype.lazyContent;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._overlapTrigger;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._hasBackdrop;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._previousPanelClass;\n    /**\n     * Event emitted when the menu is closed.\n     * @type {?}\n     */\n    _MatMenuBase.prototype.closed;\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    _MatMenuBase.prototype.close;\n    /** @type {?} */\n    _MatMenuBase.prototype.panelId;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatMenuBase.prototype._defaultOptions;\n}\n/**\n * \\@docs-private We show the \"_MatMenu\" class as \"MatMenu\" in the docs.\n */\nclass MatMenu extends _MatMenuBase {\n}\nMatMenu.decorators = [\n    { type: Directive }\n];\n// Note on the weird inheritance setup: we need three classes, because the MDC-based menu has to\n// extend `MatMenu`, however keeping a reference to it will cause the inlined template and styles\n// to be retained as well. The MDC menu also has to provide itself as a `MatMenu` in order for\n// queries and DI to work correctly, while still not referencing the actual menu class.\n// Class responsibility is split up as follows:\n// * _MatMenuBase - provides all the functionality without any of the Angular metadata.\n// * MatMenu - keeps the same name symbol name as the current menu and\n// is used as a provider for DI and query purposes.\n// * _MatMenu - the actual menu component implementation with the Angular metadata that should\n// be tree shaken away for MDC.\n/**\n * \\@docs-public MatMenu\n */\n// tslint:disable-next-line:class-name\nclass _MatMenu extends MatMenu {\n    /**\n     * @param {?} elementRef\n     * @param {?} ngZone\n     * @param {?} defaultOptions\n     */\n    constructor(elementRef, ngZone, defaultOptions) {\n        super(elementRef, ngZone, defaultOptions);\n    }\n}\n_MatMenu.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-menu',\n                template: \"<ng-template>\\n  <div\\n    class=\\\"mat-menu-panel\\\"\\n    [id]=\\\"panelId\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    (keydown)=\\\"_handleKeydown($event)\\\"\\n    (click)=\\\"closed.emit('click')\\\"\\n    [@transformMenu]=\\\"_panelAnimationState\\\"\\n    (@transformMenu.start)=\\\"_onAnimationStart($event)\\\"\\n    (@transformMenu.done)=\\\"_onAnimationDone($event)\\\"\\n    tabindex=\\\"-1\\\"\\n    role=\\\"menu\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"ariaLabelledby || null\\\"\\n    [attr.aria-describedby]=\\\"ariaDescribedby || null\\\">\\n    <div class=\\\"mat-menu-content\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\",\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matMenu',\n                animations: [\n                    matMenuAnimations.transformMenu,\n                    matMenuAnimations.fadeInItems\n                ],\n                providers: [\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu },\n                    { provide: MatMenu, useExisting: _MatMenu }\n                ],\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:\\\"\\\";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"]\n            }] }\n];\n/** @nocollapse */\n_MatMenu.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n * @type {?}\n */\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return (/**\n     * @return {?}\n     */\n    () => overlay.scrollStrategies.reposition());\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n * @type {?}\n */\nconst MENU_PANEL_TOP_PADDING = 8;\n/**\n * Options for binding a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n// TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nclass MatMenuTrigger {\n    /**\n     * @param {?} _overlay\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} scrollStrategy\n     * @param {?} _parentMenu\n     * @param {?} _menuItemInstance\n     * @param {?} _dir\n     * @param {?=} _focusMonitor\n     */\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closingActionsSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        this._menuCloseSubscription = Subscription.EMPTY;\n        /**\n         * Handles touch start events on the trigger.\n         * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n         */\n        this._handleTouchStart = (/**\n         * @return {?}\n         */\n        () => this._openedBy = 'touch');\n        // Tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the menu is opened via the keyboard\n        this._openedBy = null;\n        /**\n         * Whether focus should be restored when the menu is closed.\n         * Note that disabling this option can have accessibility implications\n         * and it's up to you to manage focus, if you decide to turn it off.\n         */\n        this.restoreFocus = true;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuClose = this.menuClosed;\n        _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n        this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * @deprecated\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get _deprecatedMatMenuTriggerFor() { return this.menu; }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set _deprecatedMatMenuTriggerFor(v) {\n        this.menu = v;\n    }\n    /**\n     * References the menu instance that the trigger is associated with.\n     * @return {?}\n     */\n    get menu() { return this._menu; }\n    /**\n     * @param {?} menu\n     * @return {?}\n     */\n    set menu(menu) {\n        if (menu === this._menu) {\n            return;\n        }\n        this._menu = menu;\n        this._menuCloseSubscription.unsubscribe();\n        if (menu) {\n            this._menuCloseSubscription = menu.close.asObservable().subscribe((/**\n             * @param {?} reason\n             * @return {?}\n             */\n            reason => {\n                this._destroyMenu();\n                // If a click closed the menu, we should close the entire chain of nested menus.\n                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\n                    this._parentMenu.closed.emit(reason);\n                }\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._checkMenu();\n        this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        this._menuCloseSubscription.unsubscribe();\n        this._closingActionsSubscription.unsubscribe();\n        this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n    get menuOpen() {\n        return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    triggersSubmenu() {\n        return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    toggleMenu() {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    openMenu() {\n        if (this._menuOpen) {\n            return;\n        }\n        this._checkMenu();\n        /** @type {?} */\n        const overlayRef = this._createOverlay();\n        /** @type {?} */\n        const overlayConfig = overlayRef.getConfig();\n        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));\n        overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :\n            this.menu.hasBackdrop;\n        overlayRef.attach(this._getPortal());\n        if (this.menu.lazyContent) {\n            this.menu.lazyContent.attach(this.menuData);\n        }\n        this._closingActionsSubscription = this._menuClosingActions().subscribe((/**\n         * @return {?}\n         */\n        () => this.closeMenu()));\n        this._initMenu();\n        if (this.menu instanceof MatMenu) {\n            this.menu._startAnimation();\n        }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    closeMenu() {\n        this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(origin = 'program', options) {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._element, origin, options);\n        }\n        else {\n            this._element.nativeElement.focus(options);\n        }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @private\n     * @return {?}\n     */\n    _destroyMenu() {\n        if (!this._overlayRef || !this.menuOpen) {\n            return;\n        }\n        /** @type {?} */\n        const menu = this.menu;\n        this._closingActionsSubscription.unsubscribe();\n        this._overlayRef.detach();\n        if (menu instanceof MatMenu) {\n            menu._resetAnimation();\n            if (menu.lazyContent) {\n                // Wait for the exit animation to finish before detaching the content.\n                menu._animationDone\n                    .pipe(filter((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                event => event.toState === 'void')), take(1), \n                // Interrupt if the content got re-attached.\n                takeUntil(menu.lazyContent._attached))\n                    .subscribe({\n                    next: (/**\n                     * @return {?}\n                     */\n                    () => (/** @type {?} */ (menu.lazyContent)).detach()),\n                    // No matter whether the content got re-attached, reset the menu.\n                    complete: (/**\n                     * @return {?}\n                     */\n                    () => this._setIsMenuOpen(false))\n                });\n            }\n            else {\n                this._setIsMenuOpen(false);\n            }\n        }\n        else {\n            this._setIsMenuOpen(false);\n            if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        }\n        this._restoreFocus();\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    _initMenu() {\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n        this.menu.direction = this.dir;\n        this._setMenuElevation();\n        this._setIsMenuOpen(true);\n        this.menu.focusFirstItem(this._openedBy || 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @private\n     * @return {?}\n     */\n    _setMenuElevation() {\n        if (this.menu.setElevation) {\n            /** @type {?} */\n            let depth = 0;\n            /** @type {?} */\n            let parentMenu = this.menu.parentMenu;\n            while (parentMenu) {\n                depth++;\n                parentMenu = parentMenu.parentMenu;\n            }\n            this.menu.setElevation(depth);\n        }\n    }\n    /**\n     * Restores focus to the element that was focused before the menu was open.\n     * @private\n     * @return {?}\n     */\n    _restoreFocus() {\n        // We should reset focus if the user is navigating using a keyboard or\n        // if we have a top-level trigger which might cause focus to be lost\n        // when clicking on the backdrop.\n        if (this.restoreFocus) {\n            if (!this._openedBy) {\n                // Note that the focus style will show up both for `program` and\n                // `keyboard` so we don't have to specify which one it is.\n                this.focus();\n            }\n            else if (!this.triggersSubmenu()) {\n                this.focus(this._openedBy);\n            }\n        }\n        this._openedBy = null;\n    }\n    // set state rather than toggle to support triggers sharing a menu\n    /**\n     * @private\n     * @param {?} isOpen\n     * @return {?}\n     */\n    _setIsMenuOpen(isOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n            this._menuItemInstance._highlighted = isOpen;\n        }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @private\n     * @return {?}\n     */\n    _checkMenu() {\n        if (!this.menu) {\n            throwMatMenuMissingError();\n        }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @private\n     * @return {?}\n     */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            /** @type {?} */\n            const config = this._getOverlayConfig();\n            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));\n            this._overlayRef = this._overlay.create(config);\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\n            this._overlayRef.keydownEvents().subscribe();\n        }\n        return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @private\n     * @return {?} OverlayConfig\n     */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withLockedPosition()\n                .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir\n        });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @private\n     * @param {?} position\n     * @return {?}\n     */\n    _subscribeToPositions(position) {\n        if (this.menu.setPositionClasses) {\n            position.positionChanges.subscribe((/**\n             * @param {?} change\n             * @return {?}\n             */\n            change => {\n                /** @type {?} */\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                /** @type {?} */\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n                (/** @type {?} */ (this.menu.setPositionClasses))(posX, posY);\n            }));\n        }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @private\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    _setPosition(positionStrategy) {\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        /** @type {?} */\n        let offsetY = 0;\n        if (this.triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n        }\n        else if (!this.menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX, originY, overlayX, overlayY, offsetY },\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ]);\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @private\n     * @return {?}\n     */\n    _menuClosingActions() {\n        /** @type {?} */\n        const backdrop = (/** @type {?} */ (this._overlayRef)).backdropClick();\n        /** @type {?} */\n        const detachments = (/** @type {?} */ (this._overlayRef)).detachments();\n        /** @type {?} */\n        const parentClose = this._parentMenu ? this._parentMenu.closed : of();\n        /** @type {?} */\n        const hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter((/**\n         * @param {?} active\n         * @return {?}\n         */\n        active => active !== this._menuItemInstance)), filter((/**\n         * @return {?}\n         */\n        () => this._menuOpen))) : of();\n        return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleMousedown(event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            // Since right or middle button clicks won't trigger the `click` event,\n            // we shouldn't consider the menu as opened by mouse in those cases.\n            this._openedBy = event.button === 0 ? 'mouse' : null;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this.openMenu();\n        }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @private\n     * @return {?}\n     */\n    _handleHover() {\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (!this.triggersSubmenu()) {\n            return;\n        }\n        this._hoverSubscription = this._parentMenu._hovered()\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n            // with different data and triggers), we have to delay it by a tick to ensure that\n            // it won't be closed immediately after it is opened.\n            .pipe(filter((/**\n         * @param {?} active\n         * @return {?}\n         */\n        active => active === this._menuItemInstance && !active.disabled)), delay(0, asapScheduler))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._openedBy = 'mouse';\n            // If the same menu is used between multiple triggers, it might still be animating\n            // while the new trigger tries to re-open it. Wait for the animation to finish\n            // before doing so. Also interrupt if the user moves to another item.\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\n                // We need the `delay(0)` here in order to avoid\n                // 'changed after checked' errors in some cases. See #12194.\n                this.menu._animationDone\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))\n                    .subscribe((/**\n                 * @return {?}\n                 */\n                () => this.openMenu()));\n            }\n            else {\n                this.openMenu();\n            }\n        }));\n    }\n    /**\n     * Gets the portal that should be attached to the overlay.\n     * @private\n     * @return {?}\n     */\n    _getPortal() {\n        // Note that we can avoid this check by keeping the portal on the menu panel.\n        // While it would be cleaner, we'd have to introduce another required method on\n        // `MatMenuPanel`, making it harder to consume.\n        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n        }\n        return this._portal;\n    }\n}\nMatMenuTrigger.decorators = [\n    { type: Directive, args: [{\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\n                host: {\n                    'class': 'mat-menu-trigger',\n                    'aria-haspopup': 'true',\n                    '[attr.aria-expanded]': 'menuOpen || null',\n                    '[attr.aria-controls]': 'menuOpen ? menu.panelId : null',\n                    '(mousedown)': '_handleMousedown($event)',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(click)': '_handleClick($event)',\n                },\n                exportAs: 'matMenuTrigger'\n            },] }\n];\n/** @nocollapse */\nMatMenuTrigger.ctorParameters = () => [\n    { type: Overlay },\n    { type: ElementRef },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\n    { type: MatMenu, decorators: [{ type: Optional }] },\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: FocusMonitor }\n];\nMatMenuTrigger.propDecorators = {\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\n    restoreFocus: [{ type: Input, args: ['matMenuTriggerRestoreFocus',] }],\n    menuOpened: [{ type: Output }],\n    onMenuOpen: [{ type: Output }],\n    menuClosed: [{ type: Output }],\n    onMenuClose: [{ type: Output }]\n};\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._portal;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._overlayRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuOpen;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._closingActionsSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._hoverSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuCloseSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._scrollStrategy;\n    /**\n     * Handles touch start events on the trigger.\n     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._handleTouchStart;\n    /** @type {?} */\n    MatMenuTrigger.prototype._openedBy;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menu;\n    /**\n     * Data to be passed along to any lazily-rendered content.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuData;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.restoreFocus;\n    /**\n     * Event emitted when the associated menu is opened.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuOpened;\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.onMenuOpen;\n    /**\n     * Event emitted when the associated menu is closed.\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.menuClosed;\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * \\@breaking-change 8.0.0\n     * @type {?}\n     */\n    MatMenuTrigger.prototype.onMenuClose;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._overlay;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._element;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._parentMenu;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._menuItemInstance;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatMenuTrigger.prototype._focusMonitor;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used by both the current `MatMenuModule` and the MDC `MatMenuModule`\n * to declare the menu-related directives.\n */\n// tslint:disable-next-line:class-name\nclass _MatMenuDirectivesModule {\n}\n_MatMenuDirectivesModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [MatMenuTrigger, MatMenuContent, MatCommonModule],\n                declarations: [\n                    MatMenuTrigger,\n                    MatMenuContent,\n                ],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            },] }\n];\nclass MatMenuModule {\n}\nMatMenuModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    CommonModule,\n                    MatCommonModule,\n                    MatRippleModule,\n                    OverlayModule,\n                    _MatMenuDirectivesModule,\n                ],\n                exports: [_MatMenu, MatMenuItem, _MatMenuDirectivesModule],\n                declarations: [_MatMenu, MatMenuItem],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/menu-positions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/menu/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger, _MatMenu, _MatMenuBase, _MatMenuDirectivesModule, fadeInItems, matMenuAnimations, transformMenu, MAT_MENU_DEFAULT_OPTIONS_FACTORY as Éµangular_material_src_material_menu_menu_a, MAT_MENU_SCROLL_STRATEGY_FACTORY as Éµangular_material_src_material_menu_menu_b, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as Éµangular_material_src_material_menu_menu_c };\n//# sourceMappingURL=menu.js.map\n","<div class=\"dashboard-header\">\r\n  <div class=\"left-options\">\r\n    <div class=\"section-name-action\">\r\n      <p class=\"title\">\r\n        <b>{{ sectionName }}</b>\r\n      </p>\r\n      <div class=\"inl action\" *ngIf=\"actionName\" (click)=\"emitActionClicked()\">\r\n        <img src=\"assets/images/icons/icon-add.svg\" />\r\n        <p class=\"clr-yellow\">{{ actionName }}</p>\r\n      </div>\r\n    </div>\r\n    <form class=\"grey-select\" [formGroup]=\"form\">\r\n      <mat-select\r\n        formControlName=\"month\"\r\n        *ngIf=\"isMonthsSelectorVisible\"\r\n        (selectionChange)=\"monthChanged.emit($event.value)\"\r\n      >\r\n        <mat-option *ngFor=\"let month of months\" [value]=\"month.value\">{{\r\n          month.name\r\n        }}</mat-option>\r\n      </mat-select>\r\n      <!-- Month/year calendar -->\r\n      <mat-form-field\r\n        appearance=\"fill\"\r\n        *ngIf=\"hasTheMonthYearCalendarToBeVisible\"\r\n        class=\"month-year-picker\"\r\n      >\r\n        <input\r\n          matInput\r\n          [matDatepicker]=\"dp\"\r\n          [max]=\"monthYearMaxDate\"\r\n          formControlName=\"monthYear\"\r\n          readonly\r\n        />\r\n        <mat-datepicker-toggle matSuffix [for]=\"dp\">\r\n          <mat-icon matDatepickerToggleIcon>arrow_drop_down</mat-icon>\r\n        </mat-datepicker-toggle>\r\n        <mat-datepicker #picker></mat-datepicker>\r\n        <mat-datepicker\r\n          #dp\r\n          (monthSelected)=\"chosenMonthHandler($event, dp)\"\r\n          (yearSelected)=\"chosenYearHandler($event)\"\r\n          startView=\"multi-year\"\r\n          panelClass=\"example-month-picker\"\r\n        >\r\n        </mat-datepicker>\r\n      </mat-form-field>\r\n      <!-- End of the month/year calendar -->\r\n    </form>\r\n  </div>\r\n  <div class=\"profile relative\">\r\n    <div class=\"backImg user relative\" (click)=\"openMenu = !openMenu\"></div>\r\n    <ul class=\"menu\" [class.open]=\"openMenu\">\r\n      <li>\r\n        <a routerLink=\"/admin/profile\">\r\n          <p>Perfil</p>\r\n        </a>\r\n      </li>\r\n      <li (click)=\"logout(); openMenu = false\">\r\n        <p>Cerrar sesiÃ³n</p>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n"]}